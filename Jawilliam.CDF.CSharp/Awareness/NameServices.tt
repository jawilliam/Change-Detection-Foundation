<#@ template language="C#" debug="True" hostSpecific="true"#>
<#@ output extension=".cs" #>
<#@ include file="..\TemplateFileManagerV2.1.ttinclude" #>
<#@ assembly name="$(SolutionDir)\packages\Microsoft.CodeAnalysis.Common.2.7.0\lib\netstandard1.3\Microsoft.CodeAnalysis.dll" #>
<#@ assembly name="$(SolutionDir)\packages\Microsoft.CodeAnalysis.CSharp.2.7.0\lib\netstandard1.3\Microsoft.CodeAnalysis.CSharp.dll" #>
<#@ assembly name="$(SolutionDir)\packages\CodePlex.LinqToXsd.2.0.2\lib\Xml.Schema.Linq.dll" #>
<#@ assembly name="$(SolutionDir)\Jawilliam.CDF\bin\Debug\Jawilliam.CDF.dll" #>
<#@ assembly name="$(SolutionDir)\Jawilliam.CDF.XObjects\bin\Debug\Jawilliam.CDF.XObjects.dll" #>
<#@ assembly name="$(SolutionDir)\packages\System.Collections.Immutable.1.3.1\lib\portable-net45+win8+wp8+wpa81\System.Collections.Immutable.dll" #>
<#@ assembly name="System.Runtime" #>
<#@ assembly name="System.Linq" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.CodeAnalysis.CSharp" #>
<#@ import namespace="Jawilliam.CDF" #>
<#@ import namespace="Jawilliam.CDF.GTED" #>
<#@ import namespace="Jawilliam.CDF.XObjects.RDSL" #>
<#
// <copyright file="LearningFromCSharpSyntaxVisitor.tt" company="Jasoco" author="Jawilliam">
//  Copyright Â© . All Rights Reserved.
// </copyright>

Type csharpSyntaxVisitor = typeof(CSharpSyntaxVisitor);
MethodInfo[] allMethods = csharpSyntaxVisitor.GetMembers().OfType<MethodInfo>().ToArray();

// Filters to methods starting with 'Visit' prefix, except that being called just 'Visit'.
MethodInfo[] visitMethods = allMethods.Where(m => m.Name.StartsWith("Visit") && m.Name != "Visit").ToArray();

// This methods represents the case logic of CSharpSyntaxVisitor for each type of syntax node, then lets to collect all that syntax node types.
List<Type> syntaxNodeTypes = visitMethods.Select(m => m.GetParameters().Single(p => p.Name == "node").ParameterType).Distinct().ToList();

// Build up the class system of syntax node types by completing the total hierarchy. 
List<Type> syntaxNodeSystem = new List<Type>(syntaxNodeTypes);
List<Type> syntaxInnerNodes = new List<Type>(220);
syntaxInnerNodes.AddRange(syntaxNodeSystem.Where(n => n.BaseType != typeof(object)).Select(n => n.BaseType).Distinct().Intersect(syntaxNodeSystem));
List<Type> missingSyntaxTypes = syntaxNodeSystem.Where(n => n.BaseType != typeof(object)).Select(n => n.BaseType).Distinct().Except(syntaxNodeSystem).ToList();
while (missingSyntaxTypes.Any())
{
    syntaxInnerNodes.AddRange(missingSyntaxTypes);
    syntaxNodeSystem.AddRange(missingSyntaxTypes);
    missingSyntaxTypes = syntaxNodeSystem.Where(n => n.BaseType != typeof(object)).Select(n => n.BaseType).Distinct().Except(syntaxNodeSystem).ToList();
}

var syntaxNodeViews = syntaxNodeSystem
.Select(t => new
{
    Parent = t.BaseType.Name,
    Child = new Tree { Root = new Node { Label = t.Name } }
})
.ToList();

List<ITree> syntaxNodeHierarachies = new List<ITree>(220);
foreach (var parentType in syntaxInnerNodes)
{
    var parent = syntaxNodeViews.First(n => object.Equals(n.Child.Root.Label, parentType.Name));
    foreach (var child in syntaxNodeViews.Where(t => object.Equals(t.Parent, parent.Child.Root.Label)))
    {
        parent.Child.Children.Add(child.Child);
        child.Child.Parent = parent.Child;
    }
}

var syntaxSystemRoot = syntaxNodeViews.Where(t => t.Parent == typeof(object).Name).Single().Child;

CodeGenerationTools code = new CodeGenerationTools(this);
CodeRegion region = new CodeRegion(this, 1);
string namespaceName = code.VsNamespaceSuggestion();

var manager = TemplateFileManager.Create(this);

// var xSyntaxTypeSystem = Jawilliam.CDF.XObjects.RDSL.Syntax.NodeTypes.Load(@"E:\Projects\Software Development Investigation\Jawilliam.Msr.Roslyn\CSharp\NodeTypeSystem.xml");
var xSyntaxTypeSystem = Jawilliam.CDF.XObjects.RDSL.Syntax.Load(@"E:\MyRepositories\Change-Detection-Foundation\Jawilliam.CDF.CSharp\RDSL.xml");
#>
using Jawilliam.CDF.Approach.Awareness;
using Jawilliam.CDF.Approach.Criterions;
using Jawilliam.CDF.Approach.Flad;
using Jawilliam.CDF.Approach.Services;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;

<#
BeginNamespace(namespaceName, code);

#>
partial class SyntaxTokenServiceProvider : INameEqualityCriterion<SyntaxNodeOrToken?, SyntaxToken, SyntaxToken>
{
    /// <summary>
    /// Determines if two elements are name-based exactly equal.
    /// </summary>
    /// <param name="original">the original version.</param>
    /// <param name="modified">the modified version.</param>
    /// <param name="context">the context wherein certain matching criterion is currently running.</param>
    /// <returns>true if the given elements are name-based exactly equal, otherwise returns false.</returns>
    /// <param name="matchingDescription">in case the given elements are name-based exactly equal, this parameter will contain the corresponding matching description.</param>
    public virtual bool NameEqualityMatch(SyntaxToken original, SyntaxToken modified, MatchingContext<SyntaxNodeOrToken?> context, out MatchInfo<SyntaxNodeOrToken?> matchingDescription)
    {
		matchingDescription = null;

        if (original == null || modified == null)
            return false;
    
        if (!string.IsNullOrWhiteSpace(original.ValueText) && 
		    !string.IsNullOrWhiteSpace(modified.ValueText) && 
			original.ValueText == modified.ValueText)
		{
            matchingDescription = new MatchInfo<SyntaxNodeOrToken?>((int)MatchInfoCriterions.Equality) { Original = original, Modified = modified };
    		return true;
		}
    
        return false;
    }
}

partial class LanguageServiceProvider
{
	/*/// <summary>
    /// Determines if two elements are name-based exactly equal.
    /// </summary>
    /// <param name="original">the original version.</param>
    /// <param name="modified">the modified version.</param>
    /// <param name="context">the context wherein certain matching criterion is currently running.</param>
    /// <typeparam name="TOriginal">Specific type of the original element.</typeparam>
    /// <typeparam name="TModified">Specific type of the modified element.</typeparam>
    /// <returns>true if the given elements are name-based exactly equal, otherwise returns false.</returns>
    public virtual bool NameEqualityMatch<TOriginal, TModified>(TOriginal original, TModified modified, MatchingContext<SyntaxNodeOrToken?> context)
    where TOriginal : SyntaxNode where TModified : SyntaxNode
    {
        return this.NameEqualityMatch<TOriginal, TModified>(original, modified, context, out MatchInfo<SyntaxNodeOrToken?> matchingDescription);
    }

    /// <summary>
    /// Determines if two elements are name-based exactly equal.
    /// </summary>
    /// <param name="original">the original version.</param>
    /// <param name="modified">the modified version.</param>
    /// <param name="context">the context wherein certain matching criterion is currently running.</param>
    /// <typeparam name="TOriginal">Specific type of the original element.</typeparam>
    /// <typeparam name="TModified">Specific type of the modified element.</typeparam>
    /// <returns>true if the given elements are name-based exactly equal, otherwise returns false.</returns>
    /// <param name="matchingDescription">in case the given elements are name-based exactly equal, this parameter will contain the corresponding matching description.</param>
    public virtual bool NameEqualityMatch<TOriginal, TModified>(TOriginal original, TModified modified, MatchingContext<SyntaxNodeOrToken?> context, out MatchInfo<SyntaxNodeOrToken?> matchingDescription)
    where TOriginal : SyntaxNode where TModified : SyntaxNode
    {
        matchingDescription = null;
        if (original != null && modified != null)
        {
            if (this.GetElementTypeServiceProvider((SyntaxKind)original.RawKind) is INameEqualityCriterion<SyntaxNodeOrToken?, TOriginal, TModified> elementTypeServiceProvider)
                return elementTypeServiceProvider.NameEqualityMatch(original, modified, context, out matchingDescription);
        }
        return false;
    }

    /// <summary>
    /// Determines if two elements are name-based exactly equal.
    /// </summary>
    /// <param name="original">the original version.</param>
    /// <param name="modified">the modified version.</param>
    /// <param name="context">the context wherein certain matching criterion is currently running.</param>
    /// <returns>true if the given elements are name-based exactly equal, otherwise returns false.</returns>
    public virtual bool NameEqualityMatch(SyntaxNode original, SyntaxNode modified, MatchingContext<SyntaxNodeOrToken?> context)
    {
        return this.NameEqualityMatch(original, modified, context, out MatchInfo<SyntaxNodeOrToken?> matchingDescription);
    }

    /// <summary>
    /// Determines if two elements are name-based exactly equal.
    /// </summary>
    /// <param name="original">the original version.</param>
    /// <param name="modified">the modified version.</param>
    /// <param name="context">the context wherein certain matching criterion is currently running.</param>
    /// <returns>true if the given elements are name-based exactly equal, otherwise returns false.</returns>
    /// <param name="matchingDescription">in case the given elements are name-based exactly equal, this parameter will contain the corresponding matching description.</param>
    public virtual bool NameEqualityMatch(SyntaxNode original, SyntaxNode modified, MatchingContext<SyntaxNodeOrToken?> context, out MatchInfo<SyntaxNodeOrToken?> matchingDescription)
    {
        var parameterModifier = new System.Reflection.ParameterModifier(4);
        parameterModifier[3] = true;
        var genericMethod = this.GetType().GetMethod("NameEqualityMatch", 
			new[] { original.GetType(), modified.GetType(), typeof(MatchingContext<SyntaxNodeOrToken?>), typeof(MatchInfo<SyntaxNodeOrToken?>) }, 
			new System.Reflection.ParameterModifier[] { parameterModifier }).MakeGenericMethod(original.GetType(), modified.GetType());
    
        matchingDescription = null;
        return (bool)genericMethod.Invoke(this, new object[] { original, modified, context, matchingDescription });
    }*/

	/// <summary>
    /// Determines if two elements are name-based exactly equal.
    /// </summary>
    /// <param name="original">the original version.</param>
    /// <param name="modified">the modified version.</param>
    /// <param name="context">the context wherein certain matching criterion is currently running.</param>
    /// <typeparam name="TOriginal">Specific type of the original element.</typeparam>
    /// <typeparam name="TModified">Specific type of the modified element.</typeparam>
    /// <returns>true if the given elements are name-based exactly equal, otherwise returns false.</returns>
    /// <param name="matchingDescription">in case the given elements are name-based exactly equal, this parameter will contain the corresponding matching description.</param>
    protected virtual bool NameEqualityMatch<TOriginal, TModified>(IEnumerable<TOriginal> original, IEnumerable<TModified> modified, Func<TOriginal, TModified, bool> equal, MatchingContext<SyntaxNodeOrToken?> context, out MatchInfo<SyntaxNodeOrToken?> matchingDescription)
    where TOriginal : SyntaxNode where TModified : SyntaxNode
    {
		matchingDescription = null;

		if (original == null || modified == null)
            return false;
    
        if (original.Count() != modified.Count())
            return false;

		var originalList = original.ToList();
		var modifiedList = modified.ToList();

        if (originalList.Select((o, i) => equal(o, modifiedList[i])).All(r => r))
        {
            matchingDescription = new MatchInfo<SyntaxNodeOrToken?>((int)MatchInfoCriterions.NameEquality) { Original = original as SyntaxNode, Modified = modified as SyntaxNode };
            return true;
        }

		while(originalList.Count() > 0)
		{
			var o = originalList.First();
			originalList.Remove(o);

			var equalModifieds = modifiedList.Where(m => equal(o, m)).ToList();
			if(equalModifieds.Count() != 1)
				return false;

			modifiedList.Remove(equalModifieds.Single());
		}

		if (originalList.Count() != modifiedList.Count())
            return false;
        
		matchingDescription = new MatchInfo<SyntaxNodeOrToken?>((int)MatchInfoCriterions.NameEquality) { Original = original as SyntaxNode, Modified = modified as SyntaxNode };
    	return true;
	}

	/// <summary>
    /// Determines if two elements are name-based exactly equal.
    /// </summary>
    /// <param name="original">the original version.</param>
    /// <param name="modified">the modified version.</param>
    /// <param name="context">the context wherein certain matching criterion is currently running.</param>
    /// <typeparam name="TOriginal">Specific type of the original element.</typeparam>
    /// <typeparam name="TModified">Specific type of the modified element.</typeparam>
    /// <returns>true if the given elements are name-based exactly equal, otherwise returns false.</returns>
    /// <param name="matchingDescription">in case the given elements are name-based exactly equal, this parameter will contain the corresponding matching description.</param>
    public virtual bool NameEqualityMatch<TOriginal, TModified>(SeparatedSyntaxList<TOriginal> original, SeparatedSyntaxList<TModified> modified, MatchingContext<SyntaxNodeOrToken?> context, out MatchInfo<SyntaxNodeOrToken?> matchingDescription)
    where TOriginal : SyntaxNode where TModified : SyntaxNode
    {
		return this.NameEqualityMatch(original, modified, (o, m) => this.MatchBy(typeof(INameEqualityCriterion<,,>), "NameEquality", o, m, context), context, out matchingDescription);
	}		

	/// <summary>
    /// Determines if two elements are name-based exactly equal.
    /// </summary>
    /// <param name="original">the original version.</param>
    /// <param name="modified">the modified version.</param>
    /// <param name="context">the context wherein certain matching criterion is currently running.</param>
    /// <typeparam name="TOriginal">Specific type of the original element.</typeparam>
    /// <typeparam name="TModified">Specific type of the modified element.</typeparam>
    /// <returns>true if the given elements are name-based exactly equal, otherwise returns false.</returns>
    /// <param name="matchingDescription">in case the given elements are name-based exactly equal, this parameter will contain the corresponding matching description.</param>
    public virtual bool NameEqualityMatch<TOriginal, TModified>(SyntaxList<TOriginal> original, SyntaxList<TModified> modified, MatchingContext<SyntaxNodeOrToken?> context, out MatchInfo<SyntaxNodeOrToken?> matchingDescription)
    where TOriginal : SyntaxNode where TModified : SyntaxNode
    {
		return this.NameEqualityMatch(original, modified, (o, m) => this.MatchBy(typeof(INameEqualityCriterion<,,>), "NameEquality", o, m, context), context, out matchingDescription);
	}	
    /*
    /// <summary>
    /// Determines if two <see cref="SyntaxToken"/> elements are equal.
    /// </summary>
    /// <param name="original">the original version.</param>
    /// <param name="modified">the modified version.</param>
    /// <param name="context">the context wherein certain matching criterion is currently running.</param>
    /// <returns>true if the given elements are name-based exactly equal, otherwise returns false.</returns>
    /// <param name="matchingDescription">in case the given elements are name-based exactly equal, this parameter will contain the corresponding matching description.</param>
    public virtual bool NameEqualityMatch(SyntaxToken original, SyntaxToken modified, MatchingContext<SyntaxNodeOrToken?> context)
    {
        return this.SyntaxTokenServiceProvider.NameEqualityMatch(original, modified, context, out MatchInfo<SyntaxNodeOrToken?> matchingDescription);
    }*/
}

partial class OmittedTypeArgumentServiceProvider : INameEqualityCriterion<SyntaxNodeOrToken?, OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax>
{
    /// <summary>
    /// Determines if two elements are name-based exactly equal.
    /// </summary>
    /// <param name="original">the original version.</param>
    /// <param name="modified">the modified version.</param>
    /// <param name="context">the context wherein certain matching criterion is currently running.</param>
    /// <returns>true if the given elements are name-based exactly equal, otherwise returns false.</returns>
    /// <param name="matchingDescription">in case the given elements are name-based exactly equal, this parameter will contain the corresponding matching description.</param>
    public virtual bool NameEqualityMatch(OmittedTypeArgumentSyntax original, OmittedTypeArgumentSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, out MatchInfo<SyntaxNodeOrToken?> matchingDescription)
    {
        if (original == null || modified == null)
        {
            matchingDescription = null;
            return false;
        }

        matchingDescription = new MatchInfo<SyntaxNodeOrToken?>((int)MatchInfoCriterions.NameEquality) { Original = original, Modified = modified };
    	return true;
    }
}

<#
var nameProviders = xSyntaxTypeSystem.Nodes.Type
	.Where(t => !t.@abstract && t.Properties.Property.Any(p => p.Rules?.Name.Any(n => n.equality && n.absolute) ?? false))
	.ToList();

foreach(ITree syntaxNode in syntaxSystemRoot.PostOrder<ITree>(e => e.Children)
.Where(n => !object.Equals(n.Root.Label, "SyntaxNode") && 
            !object.Equals(n.Root.Label, "CSharpSyntaxNode")))
{
	var xSyntaxNodeType = xSyntaxTypeSystem.Nodes.Type.SingleOrDefault(n => n.name == syntaxNode.Root.Label.ToString());
	if(xSyntaxNodeType == null) continue;

	if(!nameProviders.Any(t => t == xSyntaxNodeType)) 
		continue;

	var keyProperties = xSyntaxNodeType.Properties.Property
		.Where(p => p.Rules?.Name.Any(n => n.equality && n.absolute) ?? false)
		.ToList();

	if(!keyProperties.Any()) 
		continue;

	var xSyntaxNodeBaseType = xSyntaxNodeType != null && xSyntaxNodeType.@base != null ?
	 xSyntaxTypeSystem.Nodes.Type.SingleOrDefault(n => n.name == xSyntaxNodeType.@base) 
	 : null;
	
	var isUpdatable = false;
	if(xSyntaxNodeType != null && xSyntaxNodeType.Properties != null && xSyntaxNodeType.Properties.Property != null)
		isUpdatable = xSyntaxNodeType.Properties.Property.Any(p => p.changepoint);

	if(xSyntaxNodeType != null)
    {
		var xSyntaxNodeBaseTypeProperties = xSyntaxNodeBaseType != null && xSyntaxNodeBaseType.Properties != null && xSyntaxNodeBaseType.Properties.Property != null 
				? xSyntaxNodeBaseType.Properties.Property
				: new Syntax.NodesLocalType.TypeLocalType.PropertiesLocalType.PropertyLocalType[0];

		var xSyntaxNodeProperties = xSyntaxNodeType.Properties != null && xSyntaxNodeType.Properties.Property != null 
			? xSyntaxNodeType.Properties.Property
			: new Syntax.NodesLocalType.TypeLocalType.PropertiesLocalType.PropertyLocalType[0];

		var currentType = typeof(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
			.Assembly.GetType("Microsoft.CodeAnalysis.CSharp.Syntax." + code.Escape(syntaxNode.Root.Label.ToString()));
		var currentPropertiesMetadata = currentType.GetMembers().OfType<PropertyInfo>()
			.Where(p => xSyntaxNodeProperties.Any(n => n.name == p.Name))
			.Select(p => new Tuple<PropertyInfo, Syntax.NodesLocalType.TypeLocalType.PropertiesLocalType.PropertyLocalType>(p, xSyntaxNodeProperties.Single(n => n.name == p.Name)))
			.OrderBy(p => p.Item2.index)
			.ToArray();

	if(xSyntaxNodeType != null)
	{
		var compatibilityRules = xSyntaxNodeType.Rules?.Compatibility?.Name.Where(n => n.equality && n.absolute).ToArray();
		var reversedCompatibilityRules = nameProviders
			.Where(np => np.Rules?.Compatibility?.Name.Any(n => n.equality && n.absolute && n.type == xSyntaxNodeType.name && n.twoWay) ?? false)
			.SelectMany(np => np.Rules?.Compatibility?.Name
							 .Where(n => n.equality && n.absolute && n.type == xSyntaxNodeType.name && n.twoWay)
							 .Select(n => new {Type = np, Rule = n}))
		.ToArray();

		var compatibleInterfaces = compatibilityRules?.Aggregate("", (prev, cr) => prev + 
			$", INameEqualityCriterion<SyntaxNodeOrToken?, {code.Escape(syntaxNode.Root.Label.ToString())}, {code.Escape(cr.type)}>")
		?? "";
		compatibleInterfaces += reversedCompatibilityRules?.Aggregate("", (prev, cr) => prev + 
			$", INameEqualityCriterion<SyntaxNodeOrToken?, {code.Escape(syntaxNode.Root.Label.ToString())}, {code.Escape(cr.Type.name)}>")
		?? "";
#>
public <#= xSyntaxNodeType.@abstract ? "abstract " : "" #>partial class <#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>ServiceProvider : INameEqualityCriterion<SyntaxNodeOrToken?, <#= code.Escape(syntaxNode.Root.Label.ToString()) #>, <#= code.Escape(syntaxNode.Root.Label.ToString()) #>><#= compatibleInterfaces #>
{
	/// <summary>
    /// Method hook for implementing logic to execute before the <see cref="NameEqualityMatch(<#= code.Escape(syntaxNode.Root.Label.ToString()) #>, <#= code.Escape(syntaxNode.Root.Label.ToString()) #>, MatchingContext{SyntaxNodeOrToken?}, ref MatchInfo{SyntaxNodeOrToken?})"/>.
    /// </summary>
    /// <param name="original">the original version.</param>
    /// <param name="modified">the modified version.</param>
    /// <param name="context">the context wherein certain matching criterion is currently running.</param>
    /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
    /// <param name="result">Mechanism to modify the result of <see cref="NameEqualityMatch(<#= code.Escape(syntaxNode.Root.Label.ToString()) #>, <#= code.Escape(syntaxNode.Root.Label.ToString()) #>, MatchingContext{SyntaxNodeOrToken?}, ref MatchInfo{SyntaxNodeOrToken?})"/>.</param>
    /// <param name="ignoreCore">If true, the <see cref="NameEqualityMatchCore(<#= code.Escape(syntaxNode.Root.Label.ToString()) #>, <#= code.Escape(syntaxNode.Root.Label.ToString()) #>, MatchingContext{SyntaxNodeOrToken?}, ref MatchInfo{SyntaxNodeOrToken?})"/> is not executed and <see cref="NameEqualityMatch(<#= code.Escape(syntaxNode.Root.Label.ToString()) #>, <#= code.Escape(syntaxNode.Root.Label.ToString()) #>, MatchingContext{SyntaxNodeOrToken?}, ref MatchInfo{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
    /// <param name="matchingDescription">in case the given elements are name-based exactly equal, this parameter will contain the corresponding matching description. It should be actually an "out" parameter, but partial methods do not support "out" parameters.</param>
    partial void NameEqualityMatchBefore(<#= code.Escape(syntaxNode.Root.Label.ToString()) #> original, <#= code.Escape(syntaxNode.Root.Label.ToString()) #> modified, MatchingContext<SyntaxNodeOrToken?> context, ref MatchInfo<SyntaxNodeOrToken?> matchingDescription, ref bool result, ref bool ignoreCore);
    
    /// <summary>
    /// Method hook for implementing logic to execute after the <see cref="NameEqualityMatchCore(<#= code.Escape(syntaxNode.Root.Label.ToString()) #>, <#= code.Escape(syntaxNode.Root.Label.ToString()) #>, MatchingContext{SyntaxNodeOrToken?})"/>.
    /// </summary>
    /// <param name="original">the original version.</param>
    /// <param name="modified">the modified version.</param>
    /// <param name="context">the context wherein certain matching criterion is currently running.</param>
    /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
    /// <param name="result">Mechanism to modify the result of <see cref="NameEqualityMatch(<#= code.Escape(syntaxNode.Root.Label.ToString()) #>, <#= code.Escape(syntaxNode.Root.Label.ToString()) #>, MatchingContext{SyntaxNodeOrToken?}, ref MatchInfo{SyntaxNodeOrToken?})"/>.</param>
    /// <param name="matchingDescription">in case the given elements are name-based exactly equal, this parameter will contain the corresponding matching description. It should be actually an "out" parameter, but partial methods do not support "out" parameters.</param>
    partial void NameEqualityMatchAfter(<#= code.Escape(syntaxNode.Root.Label.ToString()) #> original, <#= code.Escape(syntaxNode.Root.Label.ToString()) #> modified, MatchingContext<SyntaxNodeOrToken?> context, ref MatchInfo<SyntaxNodeOrToken?> matchingDescription, ref bool result);

    /// <summary>
    /// Determines if two elements are name-based exactly equal.
    /// </summary>
    /// <param name="original">the original version.</param>
    /// <param name="modified">the modified version.</param>
    /// <param name="context">the context wherein certain matching criterion is currently running.</param>
    /// <returns>true if the given elements are name-based exactly equal, otherwise returns false.</returns>
    /// <param name="matchingDescription">in case the given elements are name-based exactly equal, this parameter will contain the corresponding matching description. It should be actually an "out" parameter, but partial methods do not support "out" parameters.</param>
    /// <remarks>This is the default implementation for <see cref="NameEqualityMatch(<#= code.Escape(syntaxNode.Root.Label.ToString()) #>, <#= code.Escape(syntaxNode.Root.Label.ToString()) #>, MatchingContext{SyntaxNodeOrToken?}, ref MatchInfo{SyntaxNodeOrToken?})"/>.</remarks>
    protected virtual bool NameEqualityMatchCore(<#= code.Escape(syntaxNode.Root.Label.ToString()) #> original, <#= code.Escape(syntaxNode.Root.Label.ToString()) #> modified, MatchingContext<SyntaxNodeOrToken?> context, out MatchInfo<SyntaxNodeOrToken?> matchingDescription)
	{
		if(original == null || modified == null) 
		{
			matchingDescription = null;
			return false;
		}

<#
	for (int i = 0; i < keyProperties.Count; i++)
	{
		var keyProperty = currentPropertiesMetadata.Single(p => keyProperties[i].name == p.Item2.name);
		var prefix = i == 0 ? "if (" : "    ";
		var line = prefix + (keyProperties.Count > 1 ? "(" : "") + 
		           (keyProperty.Item2.optional 
					? ((currentPropertiesMetadata.Where(p => keyProperties.Any(kp => kp.name == p.Item2.name)).Any(kp => !kp.Item2.optional) ? $"(original.{keyProperty.Item2.name} == null && modified.{keyProperty.Item2.name} == null) || (" : "") + 
					  $"original.{keyProperty.Item2.name} != null && modified.{keyProperty.Item2.name} != null && ") 
					: "");
		var postfix = (keyProperty.Item2.optional && currentPropertiesMetadata.Where(p => keyProperties.Any(kp => kp.name == p.Item2.name)).Any(kp => !kp.Item2.optional) ? ")" : "") +
		              (keyProperties.Count > 1 ? ")" : "") + 
		              (keyProperties.Count > 1 && i != (keyProperties.Count - 1) ? (currentPropertiesMetadata.Where(p => keyProperties.Any(kp => kp.name == p.Item2.name)).All(kp => kp.Item2.optional) ? " ||" : " &&") : "") + 
					  (i == (keyProperties.Count - 1) ? ")" : "");
		line += $"this.LanguageServiceProvider.MatchBy(typeof(INameEqualityCriterion<,,>), \"NameEquality\", original.{keyProperty.Item2.name}, modified.{keyProperty.Item2.name}, context)";
		 
		line += postfix;
#>
        <#= line #>
<# 
	}
#>
		{
			matchingDescription = new MatchInfo<SyntaxNodeOrToken?>((int)MatchInfoCriterions.NameEquality) { Original = original, Modified = modified };
			return true;
		}
<#
	var compatibleProperties = keyProperties
		.Where(kp => kp.Rules?.Compatibility?.Exclusive.Any(w => w.with != null) ?? false)
		.SelectMany(kp => kp.Rules.Compatibility.Exclusive
						 .Where(w => w.with != null)
						 .Select(w => new { Left = kp, Right = keyProperties.SingleOrDefault(kp2 => kp2.name == w.with), Rule = w }))
		.ToArray();

	foreach(var compatibleProperty in compatibleProperties.Where(cp => cp.Right != null))
	{
		var remainingKeyProperties = keyProperties.Where(kp => kp != compatibleProperty.Right).ToList();
		for (int i = 0; i < remainingKeyProperties.Count; i++)
		{
			var keyProperty = currentPropertiesMetadata.Single(p => remainingKeyProperties[i].name == p.Item2.name);
			var otherProperty = remainingKeyProperties[i] == compatibleProperty.Left 
				? currentPropertiesMetadata.Single(p => compatibleProperty.Right.name == p.Item2.name)
				: null;
				
			var prefix = i == 0 ? System.Environment.NewLine + "		if (" : "    ";
			var line = prefix + (remainingKeyProperties.Count > 1 ? "(" : "") + 
					(keyProperty.Item2.optional 
						? ((currentPropertiesMetadata.Where(p => remainingKeyProperties.Any(kp => kp.name == p.Item2.name)).Any(kp => !kp.Item2.optional) ? $"(original.{keyProperty.Item2.name} == null && modified.{(otherProperty != null ? otherProperty : keyProperty).Item2.name} == null) || (" : "") + 
						$"original.{keyProperty.Item2.name} != null && modified.{(otherProperty != null ? otherProperty : keyProperty).Item2.name} != null && ") 
						: "");
			var postfix = (keyProperty.Item2.optional && currentPropertiesMetadata.Where(p => remainingKeyProperties.Any(kp => kp.name == p.Item2.name)).Any(kp => !kp.Item2.optional) ? ")" : "") +
						(remainingKeyProperties.Count > 1 ? ")" : "") + 
						(remainingKeyProperties.Count > 1 && i != (remainingKeyProperties.Count - 1) ? (currentPropertiesMetadata.Where(p => remainingKeyProperties.Any(kp => kp.name == p.Item2.name)).All(kp => kp.Item2.optional) ? " ||" : " &&") : "") + 
						(i == (remainingKeyProperties.Count - 1) ? ")" : "");
			line += $"this.LanguageServiceProvider.MatchBy(typeof(INameEqualityCriterion<,,>), \"NameEquality\", original.{keyProperty.Item2.name}, modified.{(otherProperty != null ? otherProperty : keyProperty).Item2.name}, context)";
		 
			line += postfix;
#>
		<#= line #>
<# 
		}
#>
		{
			matchingDescription = new MatchInfo<SyntaxNodeOrToken?>((int)MatchInfoCriterions.NameEquality) { Original = original, Modified = modified };
			return true;
		}
<#
		if(compatibleProperty.Rule.mutually)
		{
			remainingKeyProperties = keyProperties.Where(kp => kp != compatibleProperty.Right).ToList();
			for (int i = 0; i < remainingKeyProperties.Count; i++)
			{
				var keyProperty = currentPropertiesMetadata.Single(p => remainingKeyProperties[i].name == p.Item2.name);
				var otherProperty = remainingKeyProperties[i] == compatibleProperty.Left 
					? currentPropertiesMetadata.Single(p => compatibleProperty.Right.name == p.Item2.name)
					: null;
					
				var prefix = i == 0 ? System.Environment.NewLine + "		if (" : "    ";
				var line = prefix + (remainingKeyProperties.Count > 1 ? "(" : "") + 
						(keyProperty.Item2.optional 
							? ((currentPropertiesMetadata.Where(p => remainingKeyProperties.Any(kp => kp.name == p.Item2.name)).Any(kp => !kp.Item2.optional) ? $"(original.{(otherProperty != null ? otherProperty : keyProperty).Item2.name} == null && modified.{keyProperty.Item2.name} == null) || (" : "") + 
							$"original.{(otherProperty != null ? otherProperty : keyProperty).Item2.name} != null && modified.{keyProperty.Item2.name} != null && ") 
							: "");
				var postfix = (keyProperty.Item2.optional && currentPropertiesMetadata.Where(p => remainingKeyProperties.Any(kp => kp.name == p.Item2.name)).Any(kp => !kp.Item2.optional) ? ")" : "") +
							(remainingKeyProperties.Count > 1 ? ")" : "") + 
							(remainingKeyProperties.Count > 1 && i != (remainingKeyProperties.Count - 1) ? (currentPropertiesMetadata.Where(p => remainingKeyProperties.Any(kp => kp.name == p.Item2.name)).All(kp => kp.Item2.optional) ? " ||" : " &&") : "") + 
							(i == (remainingKeyProperties.Count - 1) ? ")" : "");
				line += $"this.LanguageServiceProvider.MatchBy(typeof(INameEqualityCriterion<,,>), \"NameEquality\", original.{(otherProperty != null ? otherProperty : keyProperty).Item2.name}, modified.{keyProperty.Item2.name}, context)";
		 
				line += postfix;
#>
		<#= line #>
<# 
			}
#>
		{
			matchingDescription = new MatchInfo<SyntaxNodeOrToken?>((int)MatchInfoCriterions.NameEquality) { Original = original, Modified = modified };
			return true;
		}
<#
		}
	}
#>

		matchingDescription = null;
	    return false;
	}

    /// <summary>
    /// Determines if two elements are name-based exactly equal.
    /// </summary>
    /// <param name="original">the original version.</param>
    /// <param name="modified">the modified version.</param>
    /// <param name="context">the context wherein certain matching criterion is currently running.</param>
    /// <returns>true if the given elements are name-based exactly equal, otherwise returns false.</returns>
    /// <param name="matchingDescription">in case the given elements are name-based exactly equal, this parameter will contain the corresponding matching description. It should be actually an "out" parameter, but partial methods do not support "out" parameters.</param>
    public virtual bool NameEqualityMatch(<#= code.Escape(syntaxNode.Root.Label.ToString()) #> original, <#= code.Escape(syntaxNode.Root.Label.ToString()) #> modified, MatchingContext<SyntaxNodeOrToken?> context, out MatchInfo<SyntaxNodeOrToken?> matchingDescription)
	{
		bool result = false;
		var ignoreCore = false;
		matchingDescription = null;
		NameEqualityMatchBefore(original, modified, context, ref matchingDescription, ref result, ref ignoreCore);
		if(ignoreCore) 
			return result;
		
		result = this.NameEqualityMatchCore(original, modified, context, out matchingDescription);
		NameEqualityMatchAfter(original, modified, context, ref matchingDescription, ref result);
		return result;
	}
<#

	if(compatibilityRules?.Any() ?? false)
	{
		foreach(var rule in compatibilityRules)
		{
#>

	/// <summary>
    /// Method hook for implementing logic to execute before the <see cref="NameEqualityMatch(<#= code.Escape(syntaxNode.Root.Label.ToString()) #>, <#= rule.type #>, MatchingContext{SyntaxNodeOrToken?}, ref MatchInfo{SyntaxNodeOrToken?})"/>.
    /// </summary>
    /// <param name="original">the original version.</param>
    /// <param name="modified">the modified version.</param>
    /// <param name="context">the context wherein certain matching criterion is currently running.</param>
    /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
    /// <param name="result">Mechanism to modify the result of <see cref="NameEqualityMatch(<#= code.Escape(syntaxNode.Root.Label.ToString()) #>, <#= rule.type #>, MatchingContext{SyntaxNodeOrToken?}, ref MatchInfo{SyntaxNodeOrToken?})"/>.</param>
    /// <param name="ignoreCore">If true, the <see cref="NameEqualityMatchCore(<#= code.Escape(syntaxNode.Root.Label.ToString()) #>, <#= rule.type #>, MatchingContext{SyntaxNodeOrToken?}, ref MatchInfo{SyntaxNodeOrToken?})"/> is not executed and <see cref="NameEqualityMatch(<#= code.Escape(syntaxNode.Root.Label.ToString()) #>, <#= rule.type #>, MatchingContext{SyntaxNodeOrToken?}, ref MatchInfo{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
    /// <param name="matchingDescription">in case the given elements are name-based exactly equal, this parameter will contain the corresponding matching description.</param>
    partial void NameEqualityMatchBefore(<#= code.Escape(syntaxNode.Root.Label.ToString()) #> original, <#= rule.type #> modified, MatchingContext<SyntaxNodeOrToken?> context, ref MatchInfo<SyntaxNodeOrToken?> matchingDescription, ref bool result, ref bool ignoreCore);
    
    /// <summary>
    /// Method hook for implementing logic to execute after the <see cref="NameEqualityMatchCore(<#= code.Escape(syntaxNode.Root.Label.ToString()) #>, <#= rule.type #>, MatchingContext{SyntaxNodeOrToken?})"/>.
    /// </summary>
    /// <param name="original">the original version.</param>
    /// <param name="modified">the modified version.</param>
    /// <param name="context">the context wherein certain matching criterion is currently running.</param>
    /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
    /// <param name="result">Mechanism to modify the result of <see cref="NameEqualityMatch(<#= code.Escape(syntaxNode.Root.Label.ToString()) #>, <#= rule.type #>, MatchingContext{SyntaxNodeOrToken?}, ref MatchInfo{SyntaxNodeOrToken?})"/>.</param>
    /// <param name="matchingDescription">in case the given elements are name-based exactly equal, this parameter will contain the corresponding matching description.</param>
    partial void NameEqualityMatchAfter(<#= code.Escape(syntaxNode.Root.Label.ToString()) #> original, <#= rule.type #> modified, MatchingContext<SyntaxNodeOrToken?> context, ref MatchInfo<SyntaxNodeOrToken?> matchingDescription, ref bool result);

    /// <summary>
    /// Determines if two elements are name-based exactly equal.
    /// </summary>
    /// <param name="original">the original version.</param>
    /// <param name="modified">the modified version.</param>
    /// <param name="context">the context wherein certain matching criterion is currently running.</param>
    /// <returns>true if the given elements are name-based exactly equal, otherwise returns false.</returns>
    /// <param name="matchingDescription">in case the given elements are name-based exactly equal, this parameter will contain the corresponding matching description.</param>
    /// <remarks>This is the default implementation for <see cref="NameEqualityMatch(<#= code.Escape(syntaxNode.Root.Label.ToString()) #>, <#= rule.type #>, MatchingContext{SyntaxNodeOrToken?}, ref MatchInfo{SyntaxNodeOrToken?})"/>.</remarks>
    protected virtual bool NameEqualityMatchCore(<#= code.Escape(syntaxNode.Root.Label.ToString()) #> original, <#= rule.type #> modified, MatchingContext<SyntaxNodeOrToken?> context, out MatchInfo<SyntaxNodeOrToken?> matchingDescription)
	{
		if(original == null) 
			throw new ArgumentNullException(nameof(original));

		if(modified == null) 
			throw new ArgumentNullException(nameof(modified));
<#
		var @case = new StringBuilder();
		var conditions = rule.Condition;

		for(int j = 0; j < conditions.Count(); j++)
		{
			var condition = conditions[j] as Syntax.NodesLocalType.TypeLocalType.RulesLocalType.CompatibilityLocalType.NameLocalType.ConditionLocalType;
			if(condition != null)
			{
				@case.AppendLine((j == 0 ? "if(" : "           && ") + 
					string.Format(condition.code, "original", "modified") +
					(j == conditions.Count() - 1 ? ")" : ""));

				continue;
			}
		}
#>		
		<#= @case.ToString() #>		{		
			matchingDescription = new MatchInfo<SyntaxNodeOrToken?>((int)MatchInfoCriterions.NameEquality) { Original = original, Modified = modified };
			return true;
		}

		matchingDescription = null;
	    return false;
	}

    /// <summary>
    /// Determines if two elements are name-based exactly equal.
    /// </summary>
    /// <param name="original">the original version.</param>
    /// <param name="modified">the modified version.</param>
    /// <param name="context">the context wherein certain matching criterion is currently running.</param>
    /// <returns>true if the given elements are name-based exactly equal, otherwise returns false.</returns>
    /// <param name="matchingDescription">in case the given elements are name-based exactly equal, this parameter will contain the corresponding matching description.</param>
    public virtual bool NameEqualityMatch(<#= code.Escape(syntaxNode.Root.Label.ToString()) #> original, <#= rule.type #> modified, MatchingContext<SyntaxNodeOrToken?> context, out MatchInfo<SyntaxNodeOrToken?> matchingDescription)
	{
		bool result = false;
		var ignoreCore = false;
		matchingDescription = null;
		NameEqualityMatchBefore(original, modified, context, ref matchingDescription, ref result, ref ignoreCore);
		if(ignoreCore) 
			return result;
		
		result = this.NameEqualityMatchCore(original, modified, context, out matchingDescription);
		NameEqualityMatchAfter(original, modified, context, ref matchingDescription, ref result);
		return result;
	}
<#
		}
	}

	if(reversedCompatibilityRules?.Any() ?? false)
	{
		foreach(var rule in reversedCompatibilityRules)
		{
#>

	/// <summary>
    /// Method hook for implementing logic to execute before the <see cref="NameEqualityMatch(<#= code.Escape(syntaxNode.Root.Label.ToString()) #>, <#= rule.Type.name #>, MatchingContext{SyntaxNodeOrToken?}, ref MatchInfo{SyntaxNodeOrToken?})"/>.
    /// </summary>
    /// <param name="original">the original version.</param>
    /// <param name="modified">the modified version.</param>
    /// <param name="context">the context wherein certain matching criterion is currently running.</param>
    /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
    /// <param name="result">Mechanism to modify the result of <see cref="NameEqualityMatch(<#= code.Escape(syntaxNode.Root.Label.ToString()) #>, <#= rule.Type.name #>, MatchingContext{SyntaxNodeOrToken?}, ref MatchInfo{SyntaxNodeOrToken?})"/>.</param>
    /// <param name="ignoreCore">If true, the <see cref="NameEqualityMatchCore(<#= code.Escape(syntaxNode.Root.Label.ToString()) #>, <#= rule.Type.name #>, MatchingContext{SyntaxNodeOrToken?}, ref MatchInfo{SyntaxNodeOrToken?})"/> is not executed and <see cref="NameEqualityMatch(<#= code.Escape(syntaxNode.Root.Label.ToString()) #>, <#= rule.Type.name #>, MatchingContext{SyntaxNodeOrToken?}, ref MatchInfo{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
    /// <param name="matchingDescription">in case the given elements are name-based exactly equal, this parameter will contain the corresponding matching description.</param>
    partial void NameEqualityMatchBefore(<#= code.Escape(syntaxNode.Root.Label.ToString()) #> original, <#= rule.Type.name #> modified, MatchingContext<SyntaxNodeOrToken?> context, ref MatchInfo<SyntaxNodeOrToken?> matchingDescription, ref bool result, ref bool ignoreCore);
    
    /// <summary>
    /// Method hook for implementing logic to execute after the <see cref="NameEqualityMatchCore(<#= code.Escape(syntaxNode.Root.Label.ToString()) #>, <#= rule.Type.name #>, MatchingContext{SyntaxNodeOrToken?})"/>.
    /// </summary>
    /// <param name="original">the original version.</param>
    /// <param name="modified">the modified version.</param>
    /// <param name="context">the context wherein certain matching criterion is currently running.</param>
    /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
    /// <param name="result">Mechanism to modify the result of <see cref="NameEqualityMatch(<#= code.Escape(syntaxNode.Root.Label.ToString()) #>, <#= rule.Type.name #>, MatchingContext{SyntaxNodeOrToken?}, ref MatchInfo{SyntaxNodeOrToken?})"/>.</param>
    /// <param name="matchingDescription">in case the given elements are name-based exactly equal, this parameter will contain the corresponding matching description. It should be actually an "out" parameter, but partial methods do not support "out" parameters.</param>
    partial void NameEqualityMatchAfter(<#= code.Escape(syntaxNode.Root.Label.ToString()) #> original, <#= rule.Type.name #> modified, MatchingContext<SyntaxNodeOrToken?> context, ref MatchInfo<SyntaxNodeOrToken?> matchingDescription, ref bool result);

    /// <summary>
    /// Determines if two elements are name-based exactly equal.
    /// </summary>
    /// <param name="original">the original version.</param>
    /// <param name="modified">the modified version.</param>
    /// <param name="context">the context wherein certain matching criterion is currently running.</param>
    /// <returns>true if the given elements are name-based exactly equal, otherwise returns false.</returns>
    /// <param name="matchingDescription">in case the given elements are name-based exactly equal, this parameter will contain the corresponding matching description.</param>
    /// <remarks>This is the default implementation for <see cref="NameEqualityMatch(<#= code.Escape(syntaxNode.Root.Label.ToString()) #>, <#= rule.Type.name #>, MatchingContext{SyntaxNodeOrToken?}, ref MatchInfo{SyntaxNodeOrToken?})"/>.</remarks>
    protected virtual bool NameEqualityMatchCore(<#= code.Escape(syntaxNode.Root.Label.ToString()) #> original, <#= rule.Type.name #> modified, MatchingContext<SyntaxNodeOrToken?> context, out MatchInfo<SyntaxNodeOrToken?> matchingDescription)
	{
		if(original == null) 
			throw new ArgumentNullException(nameof(original));

		if(modified == null) 
			throw new ArgumentNullException(nameof(modified));
<#
		var @case = new StringBuilder();
		var conditions = rule.Rule.Condition;

		for(int j = 0; j < conditions.Count(); j++)
		{
			var condition = conditions[j] as Syntax.NodesLocalType.TypeLocalType.RulesLocalType.CompatibilityLocalType.NameLocalType.ConditionLocalType;
			if(condition != null)
			{
				@case.AppendLine((j == 0 ? "if(" : "           && ") + 
					string.Format(condition.code, "modified", "original") +
					(j == conditions.Count() - 1 ? ")" : ""));

				continue;
			}
		}
#>		
		<#= @case.ToString() #>		{		
			matchingDescription = new MatchInfo<SyntaxNodeOrToken?>((int)MatchInfoCriterions.NameEquality) { Original = original, Modified = modified };
			return true;
		}

		matchingDescription = null;
	    return false;
	}

    /// <summary>
    /// Determines if two elements are name-based exactly equal.
    /// </summary>
    /// <param name="original">the original version.</param>
    /// <param name="modified">the modified version.</param>
    /// <param name="context">the context wherein certain matching criterion is currently running.</param>
    /// <returns>true if the given elements are name-based exactly equal, otherwise returns false.</returns>
    /// <param name="matchingDescription">in case the given elements are name-based exactly equal, this parameter will contain the corresponding matching description.</param>
    public virtual bool NameEqualityMatch(<#= code.Escape(syntaxNode.Root.Label.ToString()) #> original, <#= rule.Type.name #> modified, MatchingContext<SyntaxNodeOrToken?> context, out MatchInfo<SyntaxNodeOrToken?> matchingDescription)
	{
		bool result = false;
		var ignoreCore = false;
		matchingDescription = null;
		NameEqualityMatchBefore(original, modified, context, ref matchingDescription, ref result, ref ignoreCore);
		if(ignoreCore) 
			return result;
		
		result = this.NameEqualityMatchCore(original, modified, context, out matchingDescription);
		NameEqualityMatchAfter(original, modified, context, ref matchingDescription, ref result);
		return result;
	}
<#
		}
	}
#>
}

<#
	}
 }
}
	
EndNamespace(namespaceName);

manager.Process();
#>
<#+ 
void BeginNamespace(string namespaceName, CodeGenerationTools code)
{
    CodeRegion region = new CodeRegion(this);
    if (!String.IsNullOrEmpty(namespaceName))
    {
#>
namespace <#=code.EscapeNamespace(namespaceName)#>
{
<#+
        PushIndent(CodeRegion.GetIndent(1));
    }
}

void EndNamespace(string namespaceName)
{
    if (!String.IsNullOrEmpty(namespaceName))
    {
        PopIndent();
#>
}
<#+
    }
}
#>
