
using Jawilliam.CDF.Approach.Awareness;
using Jawilliam.CDF.Approach.Criterions;
using Jawilliam.CDF.Approach.Flad;
using Jawilliam.CDF.Approach.Services;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;

namespace Jawilliam.CDF.CSharp.Awareness
{
    public partial class AttributeArgumentServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (AttributeArgumentSyntax)node : throw new ArgumentNullException(nameof(node));
            if(n.NameEquals != null && n.NameEquals.Kind() != SyntaxKind.None)
    			yield return n.NameEquals;
            if(n.NameColon != null && n.NameColon.Kind() != SyntaxKind.None)
    			yield return n.NameColon;
            yield return n.Expression;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class NameEqualsServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (NameEqualsSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Name;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class TypeParameterListServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (TypeParameterListSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.Parameters)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class TypeParameterServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (TypeParameterSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.AttributeLists)
    			yield return e;
            yield return n.Identifier;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class BaseListServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (BaseListSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.Types)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class TypeParameterConstraintClauseServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (TypeParameterConstraintClauseSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Name;
            foreach (var e in n.Constraints)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ExplicitInterfaceSpecifierServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ExplicitInterfaceSpecifierSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Name;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ConstructorInitializerServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ConstructorInitializerSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.ArgumentList;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ArrowExpressionClauseServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ArrowExpressionClauseSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Expression;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class AccessorListServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (AccessorListSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.Accessors)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class AccessorDeclarationServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (AccessorDeclarationSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.AttributeLists)
    			yield return e;
            foreach (var e in n.Modifiers)
    			yield return e;
    		if(n.RawKind == (int)SyntaxKind.UnknownAccessorDeclaration)
    			yield return n.Keyword;
            if(n.Body != null && n.Body.Kind() != SyntaxKind.None)
    			yield return n.Body;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ParameterServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ParameterSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.AttributeLists)
    			yield return e;
            foreach (var e in n.Modifiers)
    			yield return e;
            if(n.Type != null && n.Type.Kind() != SyntaxKind.None)
    			yield return n.Type;
            yield return n.Identifier;
            if(n.Default != null && n.Default.Kind() != SyntaxKind.None)
    			yield return n.Default;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class CrefParameterServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (CrefParameterSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Type;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class XmlElementStartTagServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (XmlElementStartTagSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Name;
            foreach (var e in n.Attributes)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class XmlElementEndTagServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (XmlElementEndTagSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Name;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class XmlNameServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (XmlNameSyntax)node : throw new ArgumentNullException(nameof(node));
            if(n.Prefix != null && n.Prefix.Kind() != SyntaxKind.None)
    			yield return n.Prefix;
            yield return n.LocalName;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class XmlPrefixServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (XmlPrefixSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Prefix;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class TypeArgumentListServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (TypeArgumentListSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.Arguments)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ArrayRankSpecifierServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ArrayRankSpecifierSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.Sizes)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class TupleElementServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (TupleElementSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Type;
            if(n.Identifier != null && n.Identifier.Kind() != SyntaxKind.None && n.Identifier.ValueText != null)
    			yield return n.Identifier;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ArgumentServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ArgumentSyntax)node : throw new ArgumentNullException(nameof(node));
            if(n.NameColon != null && n.NameColon.Kind() != SyntaxKind.None)
    			yield return n.NameColon;
            yield return n.Expression;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class NameColonServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (NameColonSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Name;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class AnonymousObjectMemberDeclaratorServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (AnonymousObjectMemberDeclaratorSyntax)node : throw new ArgumentNullException(nameof(node));
            if(n.NameEquals != null && n.NameEquals.Kind() != SyntaxKind.None)
    			yield return n.NameEquals;
            yield return n.Expression;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class QueryBodyServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (QueryBodySyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.Clauses)
    			yield return e;
            yield return n.SelectOrGroup;
            if(n.Continuation != null && n.Continuation.Kind() != SyntaxKind.None)
    			yield return n.Continuation;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class JoinIntoClauseServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (JoinIntoClauseSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Identifier;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class OrderingServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (OrderingSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Expression;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class QueryContinuationServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (QueryContinuationSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Identifier;
            yield return n.Body;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class WhenClauseServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (WhenClauseSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Condition;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class InterpolationAlignmentClauseServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (InterpolationAlignmentClauseSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Value;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class InterpolationFormatClauseServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (InterpolationFormatClauseSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.FormatStringToken;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class VariableDeclarationServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (VariableDeclarationSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Type;
            foreach (var e in n.Variables)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class VariableDeclaratorServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (VariableDeclaratorSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Identifier;
            if(n.ArgumentList != null && n.ArgumentList.Kind() != SyntaxKind.None)
    			yield return n.ArgumentList;
            if(n.Initializer != null && n.Initializer.Kind() != SyntaxKind.None)
    			yield return n.Initializer;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class EqualsValueClauseServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (EqualsValueClauseSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Value;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ElseClauseServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ElseClauseSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Statement;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class SwitchSectionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (SwitchSectionSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.Labels)
    			yield return e;
            foreach (var e in n.Statements)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class CatchClauseServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (CatchClauseSyntax)node : throw new ArgumentNullException(nameof(node));
            if(n.Declaration != null && n.Declaration.Kind() != SyntaxKind.None)
    			yield return n.Declaration;
            if(n.Filter != null && n.Filter.Kind() != SyntaxKind.None)
    			yield return n.Filter;
            yield return n.Block;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class CatchDeclarationServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (CatchDeclarationSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Type;
            if(n.Identifier != null && n.Identifier.Kind() != SyntaxKind.None && n.Identifier.RawKind != (int)SyntaxKind.None)
    			yield return n.Identifier;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class CatchFilterClauseServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (CatchFilterClauseSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.FilterExpression;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class FinallyClauseServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (FinallyClauseSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Block;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class CompilationUnitServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (CompilationUnitSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.Externs)
    			yield return e;
            foreach (var e in n.Usings)
    			yield return e;
            foreach (var e in n.AttributeLists)
    			yield return e;
            foreach (var e in n.Members)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ExternAliasDirectiveServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ExternAliasDirectiveSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Identifier;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class UsingDirectiveServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (UsingDirectiveSyntax)node : throw new ArgumentNullException(nameof(node));
            if(n.Alias != null && n.Alias.Kind() != SyntaxKind.None)
    			yield return n.Alias;
            yield return n.Name;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class AttributeListServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (AttributeListSyntax)node : throw new ArgumentNullException(nameof(node));
            if(n.Target != null && n.Target.Kind() != SyntaxKind.None)
    			yield return n.Target;
            foreach (var e in n.Attributes)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class AttributeTargetSpecifierServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (AttributeTargetSpecifierSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Identifier;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class AttributeServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (AttributeSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Name;
            if(n.ArgumentList != null && n.ArgumentList.Kind() != SyntaxKind.None)
    			yield return n.ArgumentList;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class AttributeArgumentListServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (AttributeArgumentListSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.Arguments)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class DelegateDeclarationServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (DelegateDeclarationSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.AttributeLists)
    			yield return e;
            foreach (var e in n.Modifiers)
    			yield return e;
            yield return n.ReturnType;
            yield return n.Identifier;
            if(n.TypeParameterList != null && n.TypeParameterList.Kind() != SyntaxKind.None)
    			yield return n.TypeParameterList;
            yield return n.ParameterList;
            foreach (var e in n.ConstraintClauses)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class EnumMemberDeclarationServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (EnumMemberDeclarationSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.AttributeLists)
    			yield return e;
            yield return n.Identifier;
            if(n.EqualsValue != null && n.EqualsValue.Kind() != SyntaxKind.None)
    			yield return n.EqualsValue;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class IncompleteMemberServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (IncompleteMemberSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.AttributeLists)
    			yield return e;
            foreach (var e in n.Modifiers)
    			yield return e;
            if(n.Type != null && n.Type.Kind() != SyntaxKind.None)
    			yield return n.Type;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class GlobalStatementServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (GlobalStatementSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Statement;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class NamespaceDeclarationServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (NamespaceDeclarationSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Name;
            foreach (var e in n.Externs)
    			yield return e;
            foreach (var e in n.Usings)
    			yield return e;
            foreach (var e in n.Members)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class EnumDeclarationServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (EnumDeclarationSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.AttributeLists)
    			yield return e;
            foreach (var e in n.Modifiers)
    			yield return e;
            yield return n.Identifier;
            if(n.BaseList != null && n.BaseList.Kind() != SyntaxKind.None)
    			yield return n.BaseList;
            foreach (var e in n.Members)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ClassDeclarationServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ClassDeclarationSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.AttributeLists)
    			yield return e;
            foreach (var e in n.Modifiers)
    			yield return e;
            yield return n.Identifier;
            if(n.TypeParameterList != null && n.TypeParameterList.Kind() != SyntaxKind.None)
    			yield return n.TypeParameterList;
            if(n.BaseList != null && n.BaseList.Kind() != SyntaxKind.None)
    			yield return n.BaseList;
            foreach (var e in n.ConstraintClauses)
    			yield return e;
            foreach (var e in n.Members)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class StructDeclarationServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (StructDeclarationSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.AttributeLists)
    			yield return e;
            foreach (var e in n.Modifiers)
    			yield return e;
            yield return n.Identifier;
            if(n.TypeParameterList != null && n.TypeParameterList.Kind() != SyntaxKind.None)
    			yield return n.TypeParameterList;
            if(n.BaseList != null && n.BaseList.Kind() != SyntaxKind.None)
    			yield return n.BaseList;
            foreach (var e in n.ConstraintClauses)
    			yield return e;
            foreach (var e in n.Members)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class InterfaceDeclarationServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (InterfaceDeclarationSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.AttributeLists)
    			yield return e;
            foreach (var e in n.Modifiers)
    			yield return e;
            yield return n.Identifier;
            if(n.TypeParameterList != null && n.TypeParameterList.Kind() != SyntaxKind.None)
    			yield return n.TypeParameterList;
            if(n.BaseList != null && n.BaseList.Kind() != SyntaxKind.None)
    			yield return n.BaseList;
            foreach (var e in n.ConstraintClauses)
    			yield return e;
            foreach (var e in n.Members)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class FieldDeclarationServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (FieldDeclarationSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.AttributeLists)
    			yield return e;
            foreach (var e in n.Modifiers)
    			yield return e;
            yield return n.Declaration;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class EventFieldDeclarationServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (EventFieldDeclarationSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.AttributeLists)
    			yield return e;
            foreach (var e in n.Modifiers)
    			yield return e;
            yield return n.Declaration;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class MethodDeclarationServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (MethodDeclarationSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.AttributeLists)
    			yield return e;
            foreach (var e in n.Modifiers)
    			yield return e;
            yield return n.ReturnType;
            if(n.ExplicitInterfaceSpecifier != null && n.ExplicitInterfaceSpecifier.Kind() != SyntaxKind.None)
    			yield return n.ExplicitInterfaceSpecifier;
            yield return n.Identifier;
            if(n.TypeParameterList != null && n.TypeParameterList.Kind() != SyntaxKind.None)
    			yield return n.TypeParameterList;
            yield return n.ParameterList;
            foreach (var e in n.ConstraintClauses)
    			yield return e;
            if(n.Body != null && n.Body.Kind() != SyntaxKind.None)
    			yield return n.Body;
            if(n.ExpressionBody != null && n.ExpressionBody.Kind() != SyntaxKind.None)
    			yield return n.ExpressionBody;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class OperatorDeclarationServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (OperatorDeclarationSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.AttributeLists)
    			yield return e;
            foreach (var e in n.Modifiers)
    			yield return e;
            yield return n.ReturnType;
            yield return n.OperatorToken;
            yield return n.ParameterList;
            if(n.Body != null && n.Body.Kind() != SyntaxKind.None)
    			yield return n.Body;
            if(n.ExpressionBody != null && n.ExpressionBody.Kind() != SyntaxKind.None)
    			yield return n.ExpressionBody;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ConversionOperatorDeclarationServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ConversionOperatorDeclarationSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.AttributeLists)
    			yield return e;
            foreach (var e in n.Modifiers)
    			yield return e;
            yield return n.Type;
            yield return n.ParameterList;
            if(n.Body != null && n.Body.Kind() != SyntaxKind.None)
    			yield return n.Body;
            if(n.ExpressionBody != null && n.ExpressionBody.Kind() != SyntaxKind.None)
    			yield return n.ExpressionBody;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ConstructorDeclarationServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ConstructorDeclarationSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.AttributeLists)
    			yield return e;
            foreach (var e in n.Modifiers)
    			yield return e;
            yield return n.Identifier;
            yield return n.ParameterList;
            if(n.Initializer != null && n.Initializer.Kind() != SyntaxKind.None)
    			yield return n.Initializer;
            if(n.Body != null && n.Body.Kind() != SyntaxKind.None)
    			yield return n.Body;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class DestructorDeclarationServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (DestructorDeclarationSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.AttributeLists)
    			yield return e;
            foreach (var e in n.Modifiers)
    			yield return e;
            yield return n.Identifier;
            yield return n.ParameterList;
            if(n.Body != null && n.Body.Kind() != SyntaxKind.None)
    			yield return n.Body;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class PropertyDeclarationServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (PropertyDeclarationSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.AttributeLists)
    			yield return e;
            foreach (var e in n.Modifiers)
    			yield return e;
            yield return n.Type;
            if(n.ExplicitInterfaceSpecifier != null && n.ExplicitInterfaceSpecifier.Kind() != SyntaxKind.None)
    			yield return n.ExplicitInterfaceSpecifier;
            yield return n.Identifier;
            if(n.AccessorList != null && n.AccessorList.Kind() != SyntaxKind.None)
    			yield return n.AccessorList;
            if(n.ExpressionBody != null && n.ExpressionBody.Kind() != SyntaxKind.None)
    			yield return n.ExpressionBody;
            if(n.Initializer != null && n.Initializer.Kind() != SyntaxKind.None)
    			yield return n.Initializer;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class EventDeclarationServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (EventDeclarationSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.AttributeLists)
    			yield return e;
            foreach (var e in n.Modifiers)
    			yield return e;
            yield return n.Type;
            if(n.ExplicitInterfaceSpecifier != null && n.ExplicitInterfaceSpecifier.Kind() != SyntaxKind.None)
    			yield return n.ExplicitInterfaceSpecifier;
            yield return n.Identifier;
            yield return n.AccessorList;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class IndexerDeclarationServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (IndexerDeclarationSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.AttributeLists)
    			yield return e;
            foreach (var e in n.Modifiers)
    			yield return e;
            yield return n.Type;
            if(n.ExplicitInterfaceSpecifier != null && n.ExplicitInterfaceSpecifier.Kind() != SyntaxKind.None)
    			yield return n.ExplicitInterfaceSpecifier;
            yield return n.ParameterList;
            if(n.AccessorList != null && n.AccessorList.Kind() != SyntaxKind.None)
    			yield return n.AccessorList;
            if(n.ExpressionBody != null && n.ExpressionBody.Kind() != SyntaxKind.None)
    			yield return n.ExpressionBody;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class SimpleBaseTypeServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (SimpleBaseTypeSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Type;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ConstructorConstraintServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ConstructorConstraintSyntax)node : throw new ArgumentNullException(nameof(node));
    		yield break;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ClassOrStructConstraintServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ClassOrStructConstraintSyntax)node : throw new ArgumentNullException(nameof(node));
    		yield break;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class TypeConstraintServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (TypeConstraintSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Type;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ParameterListServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ParameterListSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.Parameters)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class BracketedParameterListServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (BracketedParameterListSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.Parameters)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class SkippedTokensTriviaServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (SkippedTokensTriviaSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.Tokens)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class DocumentationCommentTriviaServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (DocumentationCommentTriviaSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.Content.Where(c => !(c is XmlTextSyntax text && (string.IsNullOrEmpty(text.ToFullString()) || string.IsNullOrWhiteSpace(text.ToFullString()) || text.ToFullString().Trim(' ') == "///"))))
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class EndIfDirectiveTriviaServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (EndIfDirectiveTriviaSyntax)node : throw new ArgumentNullException(nameof(node));
    		yield break;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class RegionDirectiveTriviaServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (RegionDirectiveTriviaSyntax)node : throw new ArgumentNullException(nameof(node));
    		yield break;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class EndRegionDirectiveTriviaServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (EndRegionDirectiveTriviaSyntax)node : throw new ArgumentNullException(nameof(node));
    		yield break;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ErrorDirectiveTriviaServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ErrorDirectiveTriviaSyntax)node : throw new ArgumentNullException(nameof(node));
    		yield break;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class WarningDirectiveTriviaServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (WarningDirectiveTriviaSyntax)node : throw new ArgumentNullException(nameof(node));
    		yield break;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class BadDirectiveTriviaServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (BadDirectiveTriviaSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Identifier;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class DefineDirectiveTriviaServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (DefineDirectiveTriviaSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Name;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class UndefDirectiveTriviaServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (UndefDirectiveTriviaSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Name;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class LineDirectiveTriviaServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (LineDirectiveTriviaSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Line;
            if(n.File != null && n.File.Kind() != SyntaxKind.None)
    			yield return n.File;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class PragmaWarningDirectiveTriviaServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (PragmaWarningDirectiveTriviaSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.DisableOrRestoreKeyword;
            foreach (var e in n.ErrorCodes)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class PragmaChecksumDirectiveTriviaServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (PragmaChecksumDirectiveTriviaSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.File;
            yield return n.Guid;
            yield return n.Bytes;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ReferenceDirectiveTriviaServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ReferenceDirectiveTriviaSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.File;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class LoadDirectiveTriviaServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (LoadDirectiveTriviaSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.File;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ShebangDirectiveTriviaServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ShebangDirectiveTriviaSyntax)node : throw new ArgumentNullException(nameof(node));
    		yield break;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ElseDirectiveTriviaServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ElseDirectiveTriviaSyntax)node : throw new ArgumentNullException(nameof(node));
    		yield break;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class IfDirectiveTriviaServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (IfDirectiveTriviaSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Condition;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ElifDirectiveTriviaServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ElifDirectiveTriviaSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Condition;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class TypeCrefServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (TypeCrefSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Type;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class QualifiedCrefServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (QualifiedCrefSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Container;
            yield return n.Member;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class NameMemberCrefServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (NameMemberCrefSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Name;
            if(n.Parameters != null && n.Parameters.Kind() != SyntaxKind.None)
    			yield return n.Parameters;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class IndexerMemberCrefServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (IndexerMemberCrefSyntax)node : throw new ArgumentNullException(nameof(node));
            if(n.Parameters != null && n.Parameters.Kind() != SyntaxKind.None)
    			yield return n.Parameters;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class OperatorMemberCrefServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (OperatorMemberCrefSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.OperatorToken;
            if(n.Parameters != null && n.Parameters.Kind() != SyntaxKind.None)
    			yield return n.Parameters;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ConversionOperatorMemberCrefServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ConversionOperatorMemberCrefSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Type;
            if(n.Parameters != null && n.Parameters.Kind() != SyntaxKind.None)
    			yield return n.Parameters;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class CrefParameterListServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (CrefParameterListSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.Parameters)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class CrefBracketedParameterListServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (CrefBracketedParameterListSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.Parameters)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class XmlElementServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (XmlElementSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.StartTag;
            foreach (var e in n.Content)
    			yield return e;
            yield return n.EndTag;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class XmlEmptyElementServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (XmlEmptyElementSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Name;
            foreach (var e in n.Attributes)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class XmlTextServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (XmlTextSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.TextTokens)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class XmlCDataSectionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (XmlCDataSectionSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.TextTokens)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class XmlProcessingInstructionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (XmlProcessingInstructionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Name;
            foreach (var e in n.TextTokens)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class XmlCommentServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (XmlCommentSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.TextTokens)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class XmlTextAttributeServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (XmlTextAttributeSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Name;
            foreach (var e in n.TextTokens)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class XmlCrefAttributeServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (XmlCrefAttributeSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Cref;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class XmlNameAttributeServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (XmlNameAttributeSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Identifier;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ParenthesizedExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ParenthesizedExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Expression;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class TupleExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (TupleExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.Arguments)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class PrefixUnaryExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (PrefixUnaryExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Operand;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class AwaitExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (AwaitExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Expression;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class PostfixUnaryExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (PostfixUnaryExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Operand;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class MemberAccessExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (MemberAccessExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Expression;
            yield return n.Name;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ConditionalAccessExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ConditionalAccessExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Expression;
            yield return n.WhenNotNull;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class MemberBindingExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (MemberBindingExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Name;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ElementBindingExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ElementBindingExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.ArgumentList;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ImplicitElementAccessServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ImplicitElementAccessSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.ArgumentList;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class BinaryExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (BinaryExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Left;
            yield return n.Right;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class AssignmentExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (AssignmentExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Left;
            yield return n.Right;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ConditionalExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ConditionalExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Condition;
            yield return n.WhenTrue;
            yield return n.WhenFalse;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class LiteralExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (LiteralExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Token;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class MakeRefExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (MakeRefExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Expression;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class RefTypeExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (RefTypeExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Expression;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class RefValueExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (RefValueExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Expression;
            yield return n.Type;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class CheckedExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (CheckedExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Expression;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class DefaultExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (DefaultExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Type;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class TypeOfExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (TypeOfExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Type;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class SizeOfExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (SizeOfExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Type;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class InvocationExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (InvocationExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Expression;
            yield return n.ArgumentList;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ElementAccessExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ElementAccessExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Expression;
            yield return n.ArgumentList;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class DeclarationExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (DeclarationExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Type;
            yield return n.Designation;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class CastExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (CastExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Type;
            yield return n.Expression;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class RefExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (RefExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Expression;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class InitializerExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (InitializerExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.Expressions)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ObjectCreationExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ObjectCreationExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Type;
            if(n.ArgumentList != null && n.ArgumentList.Kind() != SyntaxKind.None)
    			yield return n.ArgumentList;
            if(n.Initializer != null && n.Initializer.Kind() != SyntaxKind.None)
    			yield return n.Initializer;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class AnonymousObjectCreationExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (AnonymousObjectCreationExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.Initializers)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ArrayCreationExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ArrayCreationExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Type;
            if(n.Initializer != null && n.Initializer.Kind() != SyntaxKind.None)
    			yield return n.Initializer;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ImplicitArrayCreationExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ImplicitArrayCreationExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.Commas)
    			yield return e;
            yield return n.Initializer;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class StackAllocArrayCreationExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (StackAllocArrayCreationExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Type;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class QueryExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (QueryExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.FromClause;
            yield return n.Body;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class OmittedArraySizeExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (OmittedArraySizeExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
    		yield break;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class InterpolatedStringExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (InterpolatedStringExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.Contents)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class IsPatternExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (IsPatternExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Expression;
            yield return n.Pattern;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ThrowExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ThrowExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Expression;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class PredefinedTypeServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (PredefinedTypeSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Keyword;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ArrayTypeServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ArrayTypeSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.ElementType;
            foreach (var e in n.RankSpecifiers)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class PointerTypeServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (PointerTypeSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.ElementType;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class NullableTypeServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (NullableTypeSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.ElementType;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class TupleTypeServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (TupleTypeSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.Elements)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class OmittedTypeArgumentServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (OmittedTypeArgumentSyntax)node : throw new ArgumentNullException(nameof(node));
    		yield break;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class RefTypeServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (RefTypeSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Type;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class QualifiedNameServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (QualifiedNameSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Left;
            yield return n.Right;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class AliasQualifiedNameServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (AliasQualifiedNameSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Alias;
            yield return n.Name;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class IdentifierNameServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (IdentifierNameSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Identifier;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class GenericNameServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (GenericNameSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Identifier;
            yield return n.TypeArgumentList;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ThisExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ThisExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
    		yield break;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class BaseExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (BaseExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
    		yield break;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class AnonymousMethodExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (AnonymousMethodExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            if(n.ParameterList != null && n.ParameterList.Kind() != SyntaxKind.None)
    			yield return n.ParameterList;
            yield return n.Body;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class SimpleLambdaExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (SimpleLambdaExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Parameter;
            yield return n.Body;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ParenthesizedLambdaExpressionServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ParenthesizedLambdaExpressionSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.ParameterList;
            yield return n.Body;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ArgumentListServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ArgumentListSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.Arguments)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class BracketedArgumentListServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (BracketedArgumentListSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.Arguments)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class FromClauseServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (FromClauseSyntax)node : throw new ArgumentNullException(nameof(node));
            if(n.Type != null && n.Type.Kind() != SyntaxKind.None)
    			yield return n.Type;
            yield return n.Identifier;
            yield return n.Expression;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class LetClauseServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (LetClauseSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Identifier;
            yield return n.Expression;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class JoinClauseServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (JoinClauseSyntax)node : throw new ArgumentNullException(nameof(node));
            if(n.Type != null && n.Type.Kind() != SyntaxKind.None)
    			yield return n.Type;
            yield return n.Identifier;
            yield return n.InExpression;
            yield return n.LeftExpression;
            yield return n.RightExpression;
            if(n.Into != null && n.Into.Kind() != SyntaxKind.None)
    			yield return n.Into;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class WhereClauseServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (WhereClauseSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Condition;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class OrderByClauseServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (OrderByClauseSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.Orderings)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class SelectClauseServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (SelectClauseSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Expression;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class GroupClauseServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (GroupClauseSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.GroupExpression;
            yield return n.ByExpression;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class DeclarationPatternServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (DeclarationPatternSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Type;
            yield return n.Designation;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ConstantPatternServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ConstantPatternSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Expression;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class InterpolatedStringTextServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (InterpolatedStringTextSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.TextToken;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class InterpolationServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (InterpolationSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Expression;
            if(n.AlignmentClause != null && n.AlignmentClause.Kind() != SyntaxKind.None)
    			yield return n.AlignmentClause;
            if(n.FormatClause != null && n.FormatClause.Kind() != SyntaxKind.None)
    			yield return n.FormatClause;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class BlockServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (BlockSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.Statements)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class LocalFunctionStatementServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (LocalFunctionStatementSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.Modifiers)
    			yield return e;
            yield return n.ReturnType;
            yield return n.Identifier;
            if(n.TypeParameterList != null && n.TypeParameterList.Kind() != SyntaxKind.None)
    			yield return n.TypeParameterList;
            yield return n.ParameterList;
            foreach (var e in n.ConstraintClauses)
    			yield return e;
            if(n.Body != null && n.Body.Kind() != SyntaxKind.None)
    			yield return n.Body;
            if(n.ExpressionBody != null && n.ExpressionBody.Kind() != SyntaxKind.None)
    			yield return n.ExpressionBody;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class LocalDeclarationStatementServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (LocalDeclarationStatementSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.Modifiers)
    			yield return e;
            yield return n.Declaration;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ExpressionStatementServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ExpressionStatementSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Expression;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class EmptyStatementServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (EmptyStatementSyntax)node : throw new ArgumentNullException(nameof(node));
    		yield break;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class LabeledStatementServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (LabeledStatementSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Identifier;
            yield return n.Statement;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class GotoStatementServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (GotoStatementSyntax)node : throw new ArgumentNullException(nameof(node));
            if(n.Expression != null && n.Expression.Kind() != SyntaxKind.None)
    			yield return n.Expression;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class BreakStatementServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (BreakStatementSyntax)node : throw new ArgumentNullException(nameof(node));
    		yield break;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ContinueStatementServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ContinueStatementSyntax)node : throw new ArgumentNullException(nameof(node));
    		yield break;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ReturnStatementServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ReturnStatementSyntax)node : throw new ArgumentNullException(nameof(node));
            if(n.Expression != null && n.Expression.Kind() != SyntaxKind.None)
    			yield return n.Expression;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ThrowStatementServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ThrowStatementSyntax)node : throw new ArgumentNullException(nameof(node));
            if(n.Expression != null && n.Expression.Kind() != SyntaxKind.None)
    			yield return n.Expression;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class YieldStatementServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (YieldStatementSyntax)node : throw new ArgumentNullException(nameof(node));
            if(n.Expression != null && n.Expression.Kind() != SyntaxKind.None)
    			yield return n.Expression;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class WhileStatementServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (WhileStatementSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Condition;
            yield return n.Statement;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class DoStatementServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (DoStatementSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Statement;
            yield return n.Condition;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ForStatementServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ForStatementSyntax)node : throw new ArgumentNullException(nameof(node));
            if(n.Declaration != null && n.Declaration.Kind() != SyntaxKind.None)
    			yield return n.Declaration;
            foreach (var e in n.Initializers)
    			yield return e;
            if(n.Condition != null && n.Condition.Kind() != SyntaxKind.None)
    			yield return n.Condition;
            foreach (var e in n.Incrementors)
    			yield return e;
            yield return n.Statement;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class UsingStatementServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (UsingStatementSyntax)node : throw new ArgumentNullException(nameof(node));
            if(n.Declaration != null && n.Declaration.Kind() != SyntaxKind.None)
    			yield return n.Declaration;
            if(n.Expression != null && n.Expression.Kind() != SyntaxKind.None)
    			yield return n.Expression;
            yield return n.Statement;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class FixedStatementServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (FixedStatementSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Declaration;
            yield return n.Statement;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class CheckedStatementServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (CheckedStatementSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Block;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class UnsafeStatementServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (UnsafeStatementSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Block;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class LockStatementServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (LockStatementSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Expression;
            yield return n.Statement;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class IfStatementServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (IfStatementSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Condition;
            yield return n.Statement;
            if(n.Else != null && n.Else.Kind() != SyntaxKind.None)
    			yield return n.Else;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class SwitchStatementServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (SwitchStatementSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Expression;
            foreach (var e in n.Sections)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class TryStatementServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (TryStatementSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Block;
            foreach (var e in n.Catches)
    			yield return e;
            if(n.Finally != null && n.Finally.Kind() != SyntaxKind.None)
    			yield return n.Finally;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ForEachStatementServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ForEachStatementSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Type;
            yield return n.Identifier;
            yield return n.Expression;
            yield return n.Statement;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ForEachVariableStatementServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ForEachVariableStatementSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Variable;
            yield return n.Expression;
            yield return n.Statement;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class SingleVariableDesignationServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (SingleVariableDesignationSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Identifier;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class DiscardDesignationServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (DiscardDesignationSyntax)node : throw new ArgumentNullException(nameof(node));
    		yield break;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class ParenthesizedVariableDesignationServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (ParenthesizedVariableDesignationSyntax)node : throw new ArgumentNullException(nameof(node));
            foreach (var e in n.Variables)
    			yield return e;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class CasePatternSwitchLabelServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (CasePatternSwitchLabelSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Pattern;
            if(n.WhenClause != null && n.WhenClause.Kind() != SyntaxKind.None)
    			yield return n.WhenClause;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class CaseSwitchLabelServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (CaseSwitchLabelSyntax)node : throw new ArgumentNullException(nameof(node));
            yield return n.Value;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
    public partial class DefaultSwitchLabelServiceProvider : IHierarchicalAbstractionService<SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Children(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Children(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ChildrenBefore(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ChildrenCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Children(SyntaxNodeOrToken?)"/>.</param>
        partial void ChildrenAfter(SyntaxNodeOrToken? node, ref IEnumerable<SyntaxNodeOrToken?> result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="Children(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual IEnumerable<SyntaxNodeOrToken?> ChildrenCore(SyntaxNodeOrToken? node)
    	{
    		var n = node != null ? (DefaultSwitchLabelSyntax)node : throw new ArgumentNullException(nameof(node));
    		yield break;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual IEnumerable<SyntaxNodeOrToken?> Children(SyntaxNodeOrToken? node)
    	{
    		IEnumerable<SyntaxNodeOrToken?> result = null;
    		var ignoreCore = false;
    		ChildrenBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ChildrenCore(node);
    		ChildrenAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Parent(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ParentCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Parent(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ParentBefore(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ParentCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Parent(SyntaxNodeOrToken?)"/>.</param>
        partial void ParentAfter(SyntaxNodeOrToken? node, ref SyntaxNodeOrToken? result);
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        /// <remarks>This is the default implementation for <see cref="Parent(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual SyntaxNodeOrToken? ParentCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.Parent;
    	}
    
        /// <summary>
        /// Access to the parent of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's parent.</returns>
        public virtual SyntaxNodeOrToken? Parent(SyntaxNodeOrToken? node)
    	{
    		SyntaxNodeOrToken? result = null;
    		var ignoreCore = false;
    		ParentBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ParentCore(node);
    		ParentAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Label(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="LabelCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Label(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void LabelBefore(SyntaxNodeOrToken? node, ref int result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="LabelCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Label(SyntaxNodeOrToken?)"/>.</param>
        partial void LabelAfter(SyntaxNodeOrToken? node, ref int result);
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        /// <remarks>This is the default implementation for <see cref="Label(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual int LabelCore(SyntaxNodeOrToken? node)
    	{
    		return node.Value.RawKind;
    	}
    
        /// <summary>
        /// Access to the label of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>a numeric identifier of the node type.</returns>
        public virtual int Label(SyntaxNodeOrToken? node)
    	{
    		int result = -1;
    		var ignoreCore = false;
    		LabelBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.LabelCore(node);
    		LabelAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Value(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="ValueCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="Value(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void ValueBefore(SyntaxNodeOrToken? node, ref object result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="ValueCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Value(SyntaxNodeOrToken?)"/>.</param>
        partial void ValueAfter(SyntaxNodeOrToken? node, ref object result);
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        /// <remarks>This is the default implementation for <see cref="Value(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual object ValueCore(SyntaxNodeOrToken? node)
    	{
    		return node != null && this.IsLeaf(node) ? node?.ToString() : null;
    	}
    
        /// <summary>
        /// Access to the value of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the value of the given node.</returns>
        public virtual object Value(SyntaxNodeOrToken? node)
    	{
    		object result = null;
    		var ignoreCore = false;
    		ValueBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.ValueCore(node);
    		ValueAfter(node, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/> is not executed and <see cref="IsLeaf(SyntaxNodeOrToken?)"/> returns the current value of <paramref name="result"/>.</param>
        partial void IsLeafBefore(SyntaxNodeOrToken? node, ref bool result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="IsLeafCore(SyntaxNodeOrToken?)"/>.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</param>
        partial void IsLeafAfter(SyntaxNodeOrToken? node, ref bool result);
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        /// <remarks>This is the default implementation for <see cref="IsLeaf(SyntaxNodeOrToken?)"/>.</remarks>
        protected virtual bool IsLeafCore(SyntaxNodeOrToken? node)
    	{
    		return this.Children(node.Value).Count() == 0;
    	}
    
        /// <summary>
        /// Access to the children of a node.
        /// </summary>
        /// <param name="node">node of interest.</param>
        /// <returns>the node's children.</returns>
        public virtual bool IsLeaf(SyntaxNodeOrToken? node)
    	{
    		bool result = false;
    		var ignoreCore = false;
    		IsLeafBefore(node, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.IsLeafCore(node);
    		IsLeafAfter(node, ref result);
    		return result;
    	}
    }
    
}
// Generated helper templates
// Generated items
