<#@ template language="C#" debug="True" hostSpecific="true"#>
<#@ output extension=".cs" #>
<#@ include file="..\TemplateFileManagerV2.1.ttinclude" #>
<#@ assembly name="$(SolutionDir)\packages\Microsoft.CodeAnalysis.Common.2.7.0\lib\netstandard1.3\Microsoft.CodeAnalysis.dll" #>
<#@ assembly name="$(SolutionDir)\packages\Microsoft.CodeAnalysis.CSharp.2.7.0\lib\netstandard1.3\Microsoft.CodeAnalysis.CSharp.dll" #>
<#@ assembly name="$(SolutionDir)\packages\CodePlex.LinqToXsd.2.0.2\lib\Xml.Schema.Linq.dll" #>
<#@ assembly name="$(SolutionDir)\Jawilliam.CDF\bin\Debug\Jawilliam.CDF.dll" #>
<#@ assembly name="$(SolutionDir)\Jawilliam.CDF.XObjects\bin\Debug\Jawilliam.CDF.XObjects.dll" #>
<#@ assembly name="$(SolutionDir)\packages\System.Collections.Immutable.1.3.1\lib\portable-net45+win8+wp8+wpa81\System.Collections.Immutable.dll" #>
<#@ assembly name="System.Runtime" #>
<#@ assembly name="System.Linq" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.CodeAnalysis.CSharp" #>
<#@ import namespace="Jawilliam.CDF" #>
<#@ import namespace="Jawilliam.CDF.GTED" #>
<#@ import namespace="Jawilliam.CDF.XObjects.RDSL" #>
<#
// <copyright file="LearningFromCSharpSyntaxVisitor.tt" company="Jasoco" author="Jawilliam">
//  Copyright Â© . All Rights Reserved.
// </copyright>

Type csharpSyntaxVisitor = typeof(CSharpSyntaxVisitor);
MethodInfo[] allMethods = csharpSyntaxVisitor.GetMembers().OfType<MethodInfo>().ToArray();

// Filters to methods starting with 'Visit' prefix, except that being called just 'Visit'.
MethodInfo[] visitMethods = allMethods.Where(m => m.Name.StartsWith("Visit") && m.Name != "Visit").ToArray();

// This methods represents the case logic of CSharpSyntaxVisitor for each type of syntax node, then lets to collect all that syntax node types.
List<Type> syntaxNodeTypes = visitMethods.Select(m => m.GetParameters().Single(p => p.Name == "node").ParameterType).Distinct().ToList();

// Build up the class system of syntax node types by completing the total hierarchy. 
List<Type> syntaxNodeSystem = new List<Type>(syntaxNodeTypes);
List<Type> syntaxInnerNodes = new List<Type>(220);
syntaxInnerNodes.AddRange(syntaxNodeSystem.Where(n => n.BaseType != typeof(object)).Select(n => n.BaseType).Distinct().Intersect(syntaxNodeSystem));
List<Type> missingSyntaxTypes = syntaxNodeSystem.Where(n => n.BaseType != typeof(object)).Select(n => n.BaseType).Distinct().Except(syntaxNodeSystem).ToList();
while (missingSyntaxTypes.Any())
{
    syntaxInnerNodes.AddRange(missingSyntaxTypes);
    syntaxNodeSystem.AddRange(missingSyntaxTypes);
    missingSyntaxTypes = syntaxNodeSystem.Where(n => n.BaseType != typeof(object)).Select(n => n.BaseType).Distinct().Except(syntaxNodeSystem).ToList();
}

var syntaxNodeViews = syntaxNodeSystem
.Select(t => new
{
    Parent = t.BaseType.Name,
    Child = new Tree { Root = new Node { Label = t.Name } }
})
.ToList();

List<ITree> syntaxNodeHierarachies = new List<ITree>(220);
foreach (var parentType in syntaxInnerNodes)
{
    var parent = syntaxNodeViews.First(n => object.Equals(n.Child.Root.Label, parentType.Name));
    foreach (var child in syntaxNodeViews.Where(t => object.Equals(t.Parent, parent.Child.Root.Label)))
    {
        parent.Child.Children.Add(child.Child);
        child.Child.Parent = parent.Child;
    }
}

var syntaxSystemRoot = syntaxNodeViews.Where(t => t.Parent == typeof(object).Name).Single().Child;

CodeGenerationTools code = new CodeGenerationTools(this);
CodeRegion region = new CodeRegion(this, 1);
string namespaceName = code.VsNamespaceSuggestion();

var manager = TemplateFileManager.Create(this);

// var xSyntaxTypeSystem = Jawilliam.CDF.XObjects.RDSL.Syntax.NodeTypes.Load(@"E:\Projects\Software Development Investigation\Jawilliam.Msr.Roslyn\CSharp\NodeTypeSystem.xml");
var xSyntaxTypeSystem = Jawilliam.CDF.XObjects.RDSL.Syntax.Load(@"E:\MyRepositories\Change-Detection-Foundation\Jawilliam.CDF.CSharp\RDSL.xml");

#>
using Jawilliam.CDF.CSharp.Flad;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using System;

<#
BeginNamespace(namespaceName, code);
#>
/// <summary>
/// Provides C#-specific information for source code change detection. 
/// </summary>
public partial class LanguageServiceProvider :  Jawilliam.CDF.Approach.Services.ILanguageServiceProvider
{
    /// <summary>
    /// Initializes the instance.
    /// </summary>
    /// <param name="approach">the solution wherein the current procedure is being called.</param>
    public LanguageServiceProvider(CSharpFlad approach)
    {
        this.Approach = approach ?? throw new ArgumentNullException(nameof(approach));
    }

    /// <summary>
    /// Gets or sets the solution wherein the current procedure is being called.
    /// </summary>
    public virtual CSharpFlad Approach { get; private set; }

	/// <summary>
    /// Gets the <see cref="IElementTypeServiceProvider"/> to provide information for the requested element type.
    /// </summary>
    /// <param name="type">requested element type.</param>
    /// <param name="kind">optionally the element type can be refined to an specific subtype.</param>
    /// <returns><see cref="IElementTypeServiceProvider"/> implementation intended to provide information for the requested element type.</returns>
    public virtual  Jawilliam.CDF.Approach.Services.IElementTypeServiceProvider GetElementTypeServiceProvider(string type, string subtype = null)
	{
		switch(type)
		{
<#

foreach(ITree syntaxNode in syntaxSystemRoot.PostOrder<ITree>(e => e.Children)
.Where(n => !object.Equals(n.Root.Label, "SyntaxNode") && 
            !object.Equals(n.Root.Label, "CSharpSyntaxNode")))
{
	//manager.StartNewFile(syntaxNode.Root.Label + ".cs");

	var xSyntaxNodeType = xSyntaxTypeSystem.Nodes.Type.SingleOrDefault(n => n.name == syntaxNode.Root.Label.ToString());
	if(xSyntaxNodeType == null) continue;
	var xSyntaxNodeBaseType = xSyntaxNodeType != null && xSyntaxNodeType.@base != null ?
	 xSyntaxTypeSystem.Nodes.Type.SingleOrDefault(n => n.name == xSyntaxNodeType.@base) 
	 : null;

	var isAbstract = xSyntaxNodeType.@abstract;
	if(xSyntaxNodeType != null)
    {
		var xSyntaxNodeBaseTypeProperties = xSyntaxNodeBaseType != null && xSyntaxNodeBaseType.Properties != null 
											&& xSyntaxNodeBaseType.Properties.Property != null 
				? xSyntaxNodeBaseType.Properties.Property
				: new Syntax.NodesLocalType.TypeLocalType.PropertiesLocalType.PropertyLocalType[0];

		var xSyntaxNodeProperties = xSyntaxNodeType.Properties != null && xSyntaxNodeType.Properties.Property != null 
			? xSyntaxNodeType.Properties.Property
			: new Syntax.NodesLocalType.TypeLocalType.PropertiesLocalType.PropertyLocalType[0];

	if(xSyntaxNodeType != null && !isAbstract)
	{
#>
			case "<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>": return this.<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>ServiceProvider;
<#
	}
 }
}
#>
			default: return null;//throw new ArgumentException(nameof(type));
		}
	}

	/// <summary>
    /// Gets the <see cref="IElementTypeServiceProvider"/> to provide information for the requested element type.
    /// </summary>
    /// <param name="type">requested element type.</param>
    /// <param name="kind">optionally the element type can be refined to an specific subtype.</param>
    /// <returns><see cref="IElementTypeServiceProvider"/> implementation intended to provide information for the requested element type.</returns>
    public virtual  Jawilliam.CDF.Approach.Services.IElementTypeServiceProvider GetElementTypeServiceProvider(SyntaxKind type, string subtype = null)
	{
		switch(type)
		{
<#

foreach(ITree syntaxNode in syntaxSystemRoot.PostOrder<ITree>(e => e.Children)
.Where(n => !object.Equals(n.Root.Label, "SyntaxNode") && 
            !object.Equals(n.Root.Label, "CSharpSyntaxNode")))
{
	//manager.StartNewFile(syntaxNode.Root.Label + ".cs");

	var xSyntaxNodeType = xSyntaxTypeSystem.Nodes.Type.SingleOrDefault(n => n.name == syntaxNode.Root.Label.ToString());
	if(xSyntaxNodeType == null) continue;
	var xSyntaxNodeBaseType = xSyntaxNodeType != null && xSyntaxNodeType.@base != null ?
	 xSyntaxTypeSystem.Nodes.Type.SingleOrDefault(n => n.name == xSyntaxNodeType.@base) 
	 : null;

	var isAbstract = xSyntaxNodeType.@abstract;
	if(xSyntaxNodeType != null)
    {
		var xSyntaxNodeBaseTypeProperties = xSyntaxNodeBaseType != null && xSyntaxNodeBaseType.Properties != null 
											&& xSyntaxNodeBaseType.Properties.Property != null 
				? xSyntaxNodeBaseType.Properties.Property
				: new Syntax.NodesLocalType.TypeLocalType.PropertiesLocalType.PropertyLocalType[0];

		var xSyntaxNodeProperties = xSyntaxNodeType.Properties != null && xSyntaxNodeType.Properties.Property != null 
			? xSyntaxNodeType.Properties.Property
			: new Syntax.NodesLocalType.TypeLocalType.PropertiesLocalType.PropertyLocalType[0];

	if(xSyntaxNodeType != null && !isAbstract)
	{
		if(xSyntaxNodeType.name == "ConstructorInitializerSyntax")
		{
#>
			case SyntaxKind.BaseConstructorInitializer:
			case SyntaxKind.ThisConstructorInitializer: return this.<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>ServiceProvider;
<#
		} 
		else if(xSyntaxNodeType.name == "AccessorDeclarationSyntax")
		{
#>
			case SyntaxKind.AddAccessorDeclaration:
			case SyntaxKind.RemoveAccessorDeclaration:
			case SyntaxKind.GetAccessorDeclaration:
			case SyntaxKind.SetAccessorDeclaration: return this.<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>ServiceProvider;
<#
		}
		else if(xSyntaxNodeType.name == "OrderingSyntax")
		{
#>
			case SyntaxKind.AscendingOrdering:
			case SyntaxKind.DescendingOrdering: return this.<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>ServiceProvider;
<#
		}
		else if(xSyntaxNodeType.name == "ClassOrStructConstraintSyntax")
		{
#>
			case SyntaxKind.ClassConstraint:
			case SyntaxKind.StructConstraint: return this.<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>ServiceProvider;
<#
		}
		else if(xSyntaxNodeType.name == "DocumentationCommentTriviaSyntax")
		{
#>
			case SyntaxKind.SingleLineDocumentationCommentTrivia:
			case SyntaxKind.MultiLineDocumentationCommentTrivia:  return this.<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>ServiceProvider;
<#
		}
		else if(xSyntaxNodeType.name == "PrefixUnaryExpressionSyntax")
		{
#>
			case SyntaxKind.UnaryPlusExpression:
            case SyntaxKind.UnaryMinusExpression:
            case SyntaxKind.BitwiseNotExpression:
            case SyntaxKind.LogicalNotExpression:
            case SyntaxKind.PreIncrementExpression:
            case SyntaxKind.PreDecrementExpression:
            case SyntaxKind.AddressOfExpression:
            case SyntaxKind.PointerIndirectionExpression: return this.<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>ServiceProvider;
<#
		}
		else if(xSyntaxNodeType.name == "PostfixUnaryExpressionSyntax")
		{
#>
			case SyntaxKind.PostIncrementExpression:
            case SyntaxKind.PostDecrementExpression: return this.<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>ServiceProvider;
<#
		}
		else if(xSyntaxNodeType.name == "MemberAccessExpressionSyntax")
		{
#>
			case SyntaxKind.SimpleMemberAccessExpression:
            case SyntaxKind.PointerMemberAccessExpression: return this.<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>ServiceProvider;
<#
		}
		else if(xSyntaxNodeType.name == "BinaryExpressionSyntax")
		{
#>
			case SyntaxKind.AddExpression:
            case SyntaxKind.SubtractExpression:
            case SyntaxKind.MultiplyExpression:
            case SyntaxKind.DivideExpression:
            case SyntaxKind.ModuloExpression:
            case SyntaxKind.LeftShiftExpression:
            case SyntaxKind.RightShiftExpression:
            case SyntaxKind.LogicalOrExpression:
            case SyntaxKind.LogicalAndExpression:
            case SyntaxKind.BitwiseOrExpression:
            case SyntaxKind.BitwiseAndExpression:
            case SyntaxKind.ExclusiveOrExpression:
            case SyntaxKind.EqualsExpression:
            case SyntaxKind.NotEqualsExpression:
            case SyntaxKind.LessThanExpression:
            case SyntaxKind.LessThanOrEqualExpression:
            case SyntaxKind.GreaterThanExpression:
            case SyntaxKind.GreaterThanOrEqualExpression:
            case SyntaxKind.IsExpression:
            case SyntaxKind.AsExpression:
            case SyntaxKind.CoalesceExpression: return this.<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>ServiceProvider;
<#
		}
		else if(xSyntaxNodeType.name == "AssignmentExpressionSyntax")
		{
#>
			case SyntaxKind.SimpleAssignmentExpression:
            case SyntaxKind.AddAssignmentExpression:
            case SyntaxKind.SubtractAssignmentExpression:
            case SyntaxKind.MultiplyAssignmentExpression:
            case SyntaxKind.DivideAssignmentExpression:
            case SyntaxKind.ModuloAssignmentExpression:
            case SyntaxKind.AndAssignmentExpression:
            case SyntaxKind.ExclusiveOrAssignmentExpression:
            case SyntaxKind.OrAssignmentExpression:
            case SyntaxKind.LeftShiftAssignmentExpression:
            case SyntaxKind.RightShiftAssignmentExpression: return this.<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>ServiceProvider;
<#
		}
		else if(xSyntaxNodeType.name == "LiteralExpressionSyntax")
		{
#>
			case SyntaxKind.ArgListExpression:
            case SyntaxKind.NumericLiteralExpression:
            case SyntaxKind.StringLiteralExpression:
            case SyntaxKind.CharacterLiteralExpression:
            case SyntaxKind.TrueLiteralExpression:
            case SyntaxKind.FalseLiteralExpression:
            case SyntaxKind.NullLiteralExpression: return this.<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>ServiceProvider;
<#
		}
		else if(xSyntaxNodeType.name == "InitializerExpressionSyntax")
		{
#>
			case SyntaxKind.ObjectInitializerExpression:
            case SyntaxKind.CollectionInitializerExpression:
            case SyntaxKind.ArrayInitializerExpression:
            case SyntaxKind.ComplexElementInitializerExpression: return this.<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>ServiceProvider;
<#
		}
		else if(xSyntaxNodeType.name == "YieldStatementSyntax")
		{
#>
			case SyntaxKind.YieldReturnStatement:
            case SyntaxKind.YieldBreakStatement: return this.<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>ServiceProvider;
<#
		}
		else
		{
#>
			case SyntaxKind.<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>: return this.<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>ServiceProvider;
<#
		}
	}
 }
}
#>
			default: throw new ArgumentException(nameof(type));
		}
	}

    /// <summary>
    /// Determines if two typed elements are name-based exactly equal.
    /// </summary>
    /// <param name="original">the original version.</param>
    /// <param name="modified">the modified version.</param>
    /// <typeparam name="TOriginal">Type of the original version.</typeparam>
    /// <typeparam name="TModified">Type of the original version.</typeparam>
    /// <returns>true if they are exactly equal, otherwise returns false.</returns>
    private bool TryToRun<TOriginal, TModified>(TOriginal original, TModified modified, Type serviceProviderType, string functionalityName, out object result) where TOriginal : SyntaxNode where TModified : SyntaxNode
    {
        result = null;
        if (original != null && modified != null)
        {
            var serviceProvider = this.GetElementTypeServiceProvider((SyntaxKind)original.RawKind);
            if (serviceProvider != null)
            {
                var functionality = serviceProvider.GetType().GetMethod(functionalityName, new[] { original.GetType(), modified.GetType() });
                if (functionality != null)
                {
                    result = (bool)functionality.Invoke(serviceProvider, new object[] { original, modified });
                    return true;
                }
            }
        }
        return false;
    }

    /// <summary>
    /// Provides language-specific information about the "SyntaxToken" type.
    /// </summary>
    public virtual SyntaxTokenServiceProvider SyntaxTokenServiceProvider
    {
        get => _syntaxTokenServiceProvider ?? (_syntaxTokenServiceProvider = new SyntaxTokenServiceProvider(this));
        set => _syntaxTokenServiceProvider = value;
    }
    private SyntaxTokenServiceProvider _syntaxTokenServiceProvider;

<#

foreach(ITree syntaxNode in syntaxSystemRoot.PostOrder<ITree>(e => e.Children)
.Where(n => !object.Equals(n.Root.Label, "SyntaxNode") && 
            !object.Equals(n.Root.Label, "CSharpSyntaxNode")))
{
	//manager.StartNewFile(syntaxNode.Root.Label + ".cs");

	var xSyntaxNodeType = xSyntaxTypeSystem.Nodes.Type.SingleOrDefault(n => n.name == syntaxNode.Root.Label.ToString());
	if(xSyntaxNodeType == null) continue;
	var xSyntaxNodeBaseType = xSyntaxNodeType != null && xSyntaxNodeType.@base != null ?
	 xSyntaxTypeSystem.Nodes.Type.SingleOrDefault(n => n.name == xSyntaxNodeType.@base) 
	 : null;

	var isAbstract = xSyntaxNodeType.@abstract;
	
	var isUpdatable = false;
	if(xSyntaxNodeType != null && xSyntaxNodeType.Properties != null && xSyntaxNodeType.Properties.Property != null)
		isUpdatable = xSyntaxNodeType.Properties.Property.Any(p => p.changepoint);

	if(xSyntaxNodeType != null)
    {
		var xSyntaxNodeBaseTypeProperties = xSyntaxNodeBaseType != null && xSyntaxNodeBaseType.Properties != null 
											&& xSyntaxNodeBaseType.Properties.Property != null 
				? xSyntaxNodeBaseType.Properties.Property
				: new Syntax.NodesLocalType.TypeLocalType.PropertiesLocalType.PropertyLocalType[0];

		var xSyntaxNodeProperties = xSyntaxNodeType.Properties != null && xSyntaxNodeType.Properties.Property != null 
			? xSyntaxNodeType.Properties.Property
			: new Syntax.NodesLocalType.TypeLocalType.PropertiesLocalType.PropertyLocalType[0];

		var currentType = typeof(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
			.Assembly.GetType("Microsoft.CodeAnalysis.CSharp.Syntax." + code.Escape(syntaxNode.Root.Label.ToString()));
		var currentPropertiesMetadata = currentType.GetMembers().OfType<PropertyInfo>()
			.Where(p => xSyntaxNodeProperties.Any(n => n.name == p.Name))
			.Select(p => new Tuple<PropertyInfo, Syntax.NodesLocalType.TypeLocalType.PropertiesLocalType.PropertyLocalType>(p, xSyntaxNodeProperties.Single(n => n.name == p.Name)))
			.OrderBy(p => p.Item2.index)
			.ToArray();

		//foreach (var currentProperty in currentPropertiesMetadata.Where(p => p.Item2.inherited != true))
		//{
		//	string listType = currentProperty.Item2.collectionType;
		//}

	if(xSyntaxNodeType != null && !isAbstract)
	{
#>
	/// <summary>
    /// Provides language-specific information about the "<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>" type.
    /// </summary>
	public virtual <#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>ServiceProvider <#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>ServiceProvider
	{
		get => <#= code.FieldName(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>ServiceProvider ?? (<#= code.FieldName(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>ServiceProvider = new <#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>ServiceProvider(this));
		set => <#= code.FieldName(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>ServiceProvider = value;
	}
	private <#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>ServiceProvider <#= code.FieldName(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>ServiceProvider;

<#
	}
 }
}
#>
}
<#
	
EndNamespace(namespaceName);

manager.Process();
#>
<#+ 
void BeginNamespace(string namespaceName, CodeGenerationTools code)
{
    CodeRegion region = new CodeRegion(this);
    if (!String.IsNullOrEmpty(namespaceName))
    {
#>
namespace <#=code.EscapeNamespace(namespaceName)#>
{
<#+
        PushIndent(CodeRegion.GetIndent(1));
    }
}

void EndNamespace(string namespaceName)
{
    if (!String.IsNullOrEmpty(namespaceName))
    {
        PopIndent();
#>
}
<#+
    }
}
#>
