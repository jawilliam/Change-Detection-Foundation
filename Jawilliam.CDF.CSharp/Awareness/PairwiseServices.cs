
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;
using Jawilliam.CDF.Approach.Flad;
using Jawilliam.CDF.Approach.Awareness;
using Jawilliam.CDF.Approach;
using Jawilliam.CDF.Approach.Services;
using Jawilliam.CDF.Approach.Criterions;

namespace Jawilliam.CDF.CSharp.Awareness
{
    partial class NameEqualsServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(NameEqualsSyntax, NameEqualsSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(NameEqualsSyntax, NameEqualsSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(NameEqualsSyntax, NameEqualsSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(NameEqualsSyntax, NameEqualsSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(NameEqualsSyntax original, NameEqualsSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(NameEqualsSyntax, NameEqualsSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(NameEqualsSyntax, NameEqualsSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(NameEqualsSyntax original, NameEqualsSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="NameEqualsSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(NameEqualsSyntax, NameEqualsSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(NameEqualsSyntax original, NameEqualsSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EqualsToken,
    		    Modified = modified.EqualsToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(NameEqualsSyntax original, NameEqualsSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class TypeParameterListServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(TypeParameterListSyntax, TypeParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(TypeParameterListSyntax, TypeParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(TypeParameterListSyntax, TypeParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(TypeParameterListSyntax, TypeParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(TypeParameterListSyntax original, TypeParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(TypeParameterListSyntax, TypeParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(TypeParameterListSyntax, TypeParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(TypeParameterListSyntax original, TypeParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TypeParameterListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(TypeParameterListSyntax, TypeParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(TypeParameterListSyntax original, TypeParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LessThanToken,
    		    Modified = modified.LessThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.GreaterThanToken,
    		    Modified = modified.GreaterThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(TypeParameterListSyntax original, TypeParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class TypeParameterServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(TypeParameterSyntax, TypeParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(TypeParameterSyntax, TypeParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(TypeParameterSyntax, TypeParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(TypeParameterSyntax, TypeParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(TypeParameterSyntax original, TypeParameterSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(TypeParameterSyntax, TypeParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(TypeParameterSyntax, TypeParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(TypeParameterSyntax original, TypeParameterSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TypeParameterSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(TypeParameterSyntax, TypeParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(TypeParameterSyntax original, TypeParameterSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.VarianceKeyword,
    		    Modified = modified.VarianceKeyword
    		};
    		if(original.VarianceKeyword != null && modified.VarianceKeyword != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.VarianceKeyword != null)
    			matchingSet.Originals.DisableMatching(original.VarianceKeyword);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.VarianceKeyword);
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(TypeParameterSyntax original, TypeParameterSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class BaseListServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(BaseListSyntax, BaseListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(BaseListSyntax, BaseListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(BaseListSyntax, BaseListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(BaseListSyntax, BaseListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(BaseListSyntax original, BaseListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(BaseListSyntax, BaseListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(BaseListSyntax, BaseListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(BaseListSyntax original, BaseListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BaseListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(BaseListSyntax, BaseListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(BaseListSyntax original, BaseListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(BaseListSyntax original, BaseListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class TypeParameterConstraintClauseServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(TypeParameterConstraintClauseSyntax original, TypeParameterConstraintClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(TypeParameterConstraintClauseSyntax original, TypeParameterConstraintClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TypeParameterConstraintClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(TypeParameterConstraintClauseSyntax original, TypeParameterConstraintClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.WhereKeyword,
    		    Modified = modified.WhereKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(TypeParameterConstraintClauseSyntax original, TypeParameterConstraintClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ExplicitInterfaceSpecifierServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ExplicitInterfaceSpecifierSyntax original, ExplicitInterfaceSpecifierSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ExplicitInterfaceSpecifierSyntax original, ExplicitInterfaceSpecifierSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ExplicitInterfaceSpecifierSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ExplicitInterfaceSpecifierSyntax original, ExplicitInterfaceSpecifierSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.DotToken,
    		    Modified = modified.DotToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ExplicitInterfaceSpecifierSyntax original, ExplicitInterfaceSpecifierSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ConstructorInitializerServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ConstructorInitializerSyntax, ConstructorInitializerSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ConstructorInitializerSyntax, ConstructorInitializerSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ConstructorInitializerSyntax, ConstructorInitializerSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ConstructorInitializerSyntax, ConstructorInitializerSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ConstructorInitializerSyntax original, ConstructorInitializerSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ConstructorInitializerSyntax, ConstructorInitializerSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ConstructorInitializerSyntax, ConstructorInitializerSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ConstructorInitializerSyntax original, ConstructorInitializerSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ConstructorInitializerSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ConstructorInitializerSyntax, ConstructorInitializerSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ConstructorInitializerSyntax original, ConstructorInitializerSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ThisOrBaseKeyword,
    		    Modified = modified.ThisOrBaseKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ConstructorInitializerSyntax original, ConstructorInitializerSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ArrowExpressionClauseServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ArrowExpressionClauseSyntax original, ArrowExpressionClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ArrowExpressionClauseSyntax original, ArrowExpressionClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ArrowExpressionClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ArrowExpressionClauseSyntax original, ArrowExpressionClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ArrowToken,
    		    Modified = modified.ArrowToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ArrowExpressionClauseSyntax original, ArrowExpressionClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class AccessorListServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(AccessorListSyntax, AccessorListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(AccessorListSyntax, AccessorListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(AccessorListSyntax, AccessorListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(AccessorListSyntax, AccessorListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(AccessorListSyntax original, AccessorListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(AccessorListSyntax, AccessorListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(AccessorListSyntax, AccessorListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(AccessorListSyntax original, AccessorListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AccessorListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(AccessorListSyntax, AccessorListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(AccessorListSyntax original, AccessorListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(AccessorListSyntax original, AccessorListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class AccessorDeclarationServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(AccessorDeclarationSyntax, AccessorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(AccessorDeclarationSyntax, AccessorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(AccessorDeclarationSyntax, AccessorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(AccessorDeclarationSyntax, AccessorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(AccessorDeclarationSyntax original, AccessorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(AccessorDeclarationSyntax, AccessorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(AccessorDeclarationSyntax, AccessorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(AccessorDeclarationSyntax original, AccessorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AccessorDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(AccessorDeclarationSyntax, AccessorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(AccessorDeclarationSyntax original, AccessorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && modified.SemicolonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.SemicolonToken != null)
    			matchingSet.Originals.DisableMatching(original.SemicolonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(AccessorDeclarationSyntax original, AccessorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ParameterServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ParameterSyntax, ParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ParameterSyntax, ParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ParameterSyntax, ParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ParameterSyntax, ParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ParameterSyntax original, ParameterSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ParameterSyntax, ParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ParameterSyntax, ParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ParameterSyntax original, ParameterSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ParameterSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ParameterSyntax, ParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ParameterSyntax original, ParameterSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ParameterSyntax original, ParameterSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class CrefParameterServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(CrefParameterSyntax, CrefParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(CrefParameterSyntax, CrefParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(CrefParameterSyntax, CrefParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(CrefParameterSyntax, CrefParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(CrefParameterSyntax original, CrefParameterSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(CrefParameterSyntax, CrefParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(CrefParameterSyntax, CrefParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(CrefParameterSyntax original, CrefParameterSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CrefParameterSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(CrefParameterSyntax, CrefParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(CrefParameterSyntax original, CrefParameterSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.RefKindKeyword,
    		    Modified = modified.RefKindKeyword
    		};
    		if(original.RefKindKeyword != null && modified.RefKindKeyword != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.RefKindKeyword != null)
    			matchingSet.Originals.DisableMatching(original.RefKindKeyword);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.RefKindKeyword);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(CrefParameterSyntax original, CrefParameterSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class XmlElementStartTagServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(XmlElementStartTagSyntax, XmlElementStartTagSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(XmlElementStartTagSyntax, XmlElementStartTagSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(XmlElementStartTagSyntax, XmlElementStartTagSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(XmlElementStartTagSyntax, XmlElementStartTagSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(XmlElementStartTagSyntax original, XmlElementStartTagSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(XmlElementStartTagSyntax, XmlElementStartTagSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(XmlElementStartTagSyntax, XmlElementStartTagSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(XmlElementStartTagSyntax original, XmlElementStartTagSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlElementStartTagSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(XmlElementStartTagSyntax, XmlElementStartTagSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(XmlElementStartTagSyntax original, XmlElementStartTagSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LessThanToken,
    		    Modified = modified.LessThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.GreaterThanToken,
    		    Modified = modified.GreaterThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(XmlElementStartTagSyntax original, XmlElementStartTagSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class XmlElementEndTagServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(XmlElementEndTagSyntax, XmlElementEndTagSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(XmlElementEndTagSyntax, XmlElementEndTagSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(XmlElementEndTagSyntax, XmlElementEndTagSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(XmlElementEndTagSyntax, XmlElementEndTagSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(XmlElementEndTagSyntax original, XmlElementEndTagSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(XmlElementEndTagSyntax, XmlElementEndTagSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(XmlElementEndTagSyntax, XmlElementEndTagSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(XmlElementEndTagSyntax original, XmlElementEndTagSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlElementEndTagSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(XmlElementEndTagSyntax, XmlElementEndTagSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(XmlElementEndTagSyntax original, XmlElementEndTagSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LessThanSlashToken,
    		    Modified = modified.LessThanSlashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.GreaterThanToken,
    		    Modified = modified.GreaterThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(XmlElementEndTagSyntax original, XmlElementEndTagSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class XmlNameServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(XmlNameSyntax, XmlNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(XmlNameSyntax, XmlNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(XmlNameSyntax, XmlNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(XmlNameSyntax, XmlNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(XmlNameSyntax original, XmlNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(XmlNameSyntax, XmlNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(XmlNameSyntax, XmlNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(XmlNameSyntax original, XmlNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlNameSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(XmlNameSyntax, XmlNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(XmlNameSyntax original, XmlNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LocalName,
    		    Modified = modified.LocalName
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(XmlNameSyntax original, XmlNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class XmlPrefixServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(XmlPrefixSyntax, XmlPrefixSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(XmlPrefixSyntax, XmlPrefixSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(XmlPrefixSyntax, XmlPrefixSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(XmlPrefixSyntax, XmlPrefixSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(XmlPrefixSyntax original, XmlPrefixSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(XmlPrefixSyntax, XmlPrefixSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(XmlPrefixSyntax, XmlPrefixSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(XmlPrefixSyntax original, XmlPrefixSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlPrefixSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(XmlPrefixSyntax, XmlPrefixSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(XmlPrefixSyntax original, XmlPrefixSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Prefix,
    		    Modified = modified.Prefix
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(XmlPrefixSyntax original, XmlPrefixSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class TypeArgumentListServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(TypeArgumentListSyntax, TypeArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(TypeArgumentListSyntax, TypeArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(TypeArgumentListSyntax, TypeArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(TypeArgumentListSyntax, TypeArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(TypeArgumentListSyntax original, TypeArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(TypeArgumentListSyntax, TypeArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(TypeArgumentListSyntax, TypeArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(TypeArgumentListSyntax original, TypeArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TypeArgumentListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(TypeArgumentListSyntax, TypeArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(TypeArgumentListSyntax original, TypeArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LessThanToken,
    		    Modified = modified.LessThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.GreaterThanToken,
    		    Modified = modified.GreaterThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(TypeArgumentListSyntax original, TypeArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ArrayRankSpecifierServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ArrayRankSpecifierSyntax original, ArrayRankSpecifierSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ArrayRankSpecifierSyntax original, ArrayRankSpecifierSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ArrayRankSpecifierSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ArrayRankSpecifierSyntax original, ArrayRankSpecifierSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBracketToken,
    		    Modified = modified.OpenBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBracketToken,
    		    Modified = modified.CloseBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ArrayRankSpecifierSyntax original, ArrayRankSpecifierSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class TupleElementServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(TupleElementSyntax, TupleElementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(TupleElementSyntax, TupleElementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(TupleElementSyntax, TupleElementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(TupleElementSyntax, TupleElementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(TupleElementSyntax original, TupleElementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(TupleElementSyntax, TupleElementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(TupleElementSyntax, TupleElementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(TupleElementSyntax original, TupleElementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TupleElementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(TupleElementSyntax, TupleElementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(TupleElementSyntax original, TupleElementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
    		if(original.Identifier != null && modified.Identifier != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.Identifier != null)
    			matchingSet.Originals.DisableMatching(original.Identifier);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.Identifier);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(TupleElementSyntax original, TupleElementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ArgumentServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ArgumentSyntax, ArgumentSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ArgumentSyntax, ArgumentSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ArgumentSyntax, ArgumentSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ArgumentSyntax, ArgumentSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ArgumentSyntax original, ArgumentSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ArgumentSyntax, ArgumentSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ArgumentSyntax, ArgumentSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ArgumentSyntax original, ArgumentSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ArgumentSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ArgumentSyntax, ArgumentSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ArgumentSyntax original, ArgumentSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.RefKindKeyword,
    		    Modified = modified.RefKindKeyword
    		};
    		if(original.RefKindKeyword != null && modified.RefKindKeyword != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.RefKindKeyword != null)
    			matchingSet.Originals.DisableMatching(original.RefKindKeyword);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.RefKindKeyword);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ArgumentSyntax original, ArgumentSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class NameColonServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(NameColonSyntax, NameColonSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(NameColonSyntax, NameColonSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(NameColonSyntax, NameColonSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(NameColonSyntax, NameColonSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(NameColonSyntax original, NameColonSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(NameColonSyntax, NameColonSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(NameColonSyntax, NameColonSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(NameColonSyntax original, NameColonSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="NameColonSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(NameColonSyntax, NameColonSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(NameColonSyntax original, NameColonSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(NameColonSyntax original, NameColonSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class JoinIntoClauseServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(JoinIntoClauseSyntax, JoinIntoClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(JoinIntoClauseSyntax, JoinIntoClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(JoinIntoClauseSyntax, JoinIntoClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(JoinIntoClauseSyntax, JoinIntoClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(JoinIntoClauseSyntax original, JoinIntoClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(JoinIntoClauseSyntax, JoinIntoClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(JoinIntoClauseSyntax, JoinIntoClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(JoinIntoClauseSyntax original, JoinIntoClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="JoinIntoClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(JoinIntoClauseSyntax, JoinIntoClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(JoinIntoClauseSyntax original, JoinIntoClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.IntoKeyword,
    		    Modified = modified.IntoKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(JoinIntoClauseSyntax original, JoinIntoClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class OrderingServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(OrderingSyntax, OrderingSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(OrderingSyntax, OrderingSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(OrderingSyntax, OrderingSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(OrderingSyntax, OrderingSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(OrderingSyntax original, OrderingSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(OrderingSyntax, OrderingSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(OrderingSyntax, OrderingSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(OrderingSyntax original, OrderingSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="OrderingSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(OrderingSyntax, OrderingSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(OrderingSyntax original, OrderingSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.AscendingOrDescendingKeyword,
    		    Modified = modified.AscendingOrDescendingKeyword
    		};
    		if(original.AscendingOrDescendingKeyword != null && modified.AscendingOrDescendingKeyword != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.AscendingOrDescendingKeyword != null)
    			matchingSet.Originals.DisableMatching(original.AscendingOrDescendingKeyword);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.AscendingOrDescendingKeyword);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(OrderingSyntax original, OrderingSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class QueryContinuationServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(QueryContinuationSyntax, QueryContinuationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(QueryContinuationSyntax, QueryContinuationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(QueryContinuationSyntax, QueryContinuationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(QueryContinuationSyntax, QueryContinuationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(QueryContinuationSyntax original, QueryContinuationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(QueryContinuationSyntax, QueryContinuationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(QueryContinuationSyntax, QueryContinuationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(QueryContinuationSyntax original, QueryContinuationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="QueryContinuationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(QueryContinuationSyntax, QueryContinuationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(QueryContinuationSyntax original, QueryContinuationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.IntoKeyword,
    		    Modified = modified.IntoKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(QueryContinuationSyntax original, QueryContinuationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class WhenClauseServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(WhenClauseSyntax, WhenClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(WhenClauseSyntax, WhenClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(WhenClauseSyntax, WhenClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(WhenClauseSyntax, WhenClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(WhenClauseSyntax original, WhenClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(WhenClauseSyntax, WhenClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(WhenClauseSyntax, WhenClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(WhenClauseSyntax original, WhenClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="WhenClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(WhenClauseSyntax, WhenClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(WhenClauseSyntax original, WhenClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.WhenKeyword,
    		    Modified = modified.WhenKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(WhenClauseSyntax original, WhenClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class InterpolationAlignmentClauseServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(InterpolationAlignmentClauseSyntax original, InterpolationAlignmentClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(InterpolationAlignmentClauseSyntax original, InterpolationAlignmentClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="InterpolationAlignmentClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(InterpolationAlignmentClauseSyntax original, InterpolationAlignmentClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CommaToken,
    		    Modified = modified.CommaToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(InterpolationAlignmentClauseSyntax original, InterpolationAlignmentClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class InterpolationFormatClauseServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(InterpolationFormatClauseSyntax original, InterpolationFormatClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(InterpolationFormatClauseSyntax original, InterpolationFormatClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="InterpolationFormatClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(InterpolationFormatClauseSyntax original, InterpolationFormatClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.FormatStringToken,
    		    Modified = modified.FormatStringToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(InterpolationFormatClauseSyntax original, InterpolationFormatClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class VariableDeclaratorServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(VariableDeclaratorSyntax, VariableDeclaratorSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(VariableDeclaratorSyntax, VariableDeclaratorSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(VariableDeclaratorSyntax, VariableDeclaratorSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(VariableDeclaratorSyntax, VariableDeclaratorSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(VariableDeclaratorSyntax original, VariableDeclaratorSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(VariableDeclaratorSyntax, VariableDeclaratorSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(VariableDeclaratorSyntax, VariableDeclaratorSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(VariableDeclaratorSyntax original, VariableDeclaratorSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="VariableDeclaratorSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(VariableDeclaratorSyntax, VariableDeclaratorSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(VariableDeclaratorSyntax original, VariableDeclaratorSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(VariableDeclaratorSyntax original, VariableDeclaratorSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class EqualsValueClauseServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(EqualsValueClauseSyntax, EqualsValueClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(EqualsValueClauseSyntax, EqualsValueClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(EqualsValueClauseSyntax, EqualsValueClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(EqualsValueClauseSyntax, EqualsValueClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(EqualsValueClauseSyntax original, EqualsValueClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(EqualsValueClauseSyntax, EqualsValueClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(EqualsValueClauseSyntax, EqualsValueClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(EqualsValueClauseSyntax original, EqualsValueClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EqualsValueClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(EqualsValueClauseSyntax, EqualsValueClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(EqualsValueClauseSyntax original, EqualsValueClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EqualsToken,
    		    Modified = modified.EqualsToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(EqualsValueClauseSyntax original, EqualsValueClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ElseClauseServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ElseClauseSyntax, ElseClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ElseClauseSyntax, ElseClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ElseClauseSyntax, ElseClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ElseClauseSyntax, ElseClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ElseClauseSyntax original, ElseClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ElseClauseSyntax, ElseClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ElseClauseSyntax, ElseClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ElseClauseSyntax original, ElseClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ElseClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ElseClauseSyntax, ElseClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ElseClauseSyntax original, ElseClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ElseKeyword,
    		    Modified = modified.ElseKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ElseClauseSyntax original, ElseClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class CatchClauseServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(CatchClauseSyntax, CatchClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(CatchClauseSyntax, CatchClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(CatchClauseSyntax, CatchClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(CatchClauseSyntax, CatchClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(CatchClauseSyntax original, CatchClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(CatchClauseSyntax, CatchClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(CatchClauseSyntax, CatchClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(CatchClauseSyntax original, CatchClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CatchClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(CatchClauseSyntax, CatchClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(CatchClauseSyntax original, CatchClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CatchKeyword,
    		    Modified = modified.CatchKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(CatchClauseSyntax original, CatchClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class CatchDeclarationServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(CatchDeclarationSyntax, CatchDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(CatchDeclarationSyntax, CatchDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(CatchDeclarationSyntax, CatchDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(CatchDeclarationSyntax, CatchDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(CatchDeclarationSyntax original, CatchDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(CatchDeclarationSyntax, CatchDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(CatchDeclarationSyntax, CatchDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(CatchDeclarationSyntax original, CatchDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CatchDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(CatchDeclarationSyntax, CatchDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(CatchDeclarationSyntax original, CatchDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
    		if(original.Identifier != null && modified.Identifier != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.Identifier != null)
    			matchingSet.Originals.DisableMatching(original.Identifier);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.Identifier);
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(CatchDeclarationSyntax original, CatchDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class CatchFilterClauseServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(CatchFilterClauseSyntax, CatchFilterClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(CatchFilterClauseSyntax, CatchFilterClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(CatchFilterClauseSyntax, CatchFilterClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(CatchFilterClauseSyntax, CatchFilterClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(CatchFilterClauseSyntax original, CatchFilterClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(CatchFilterClauseSyntax, CatchFilterClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(CatchFilterClauseSyntax, CatchFilterClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(CatchFilterClauseSyntax original, CatchFilterClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CatchFilterClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(CatchFilterClauseSyntax, CatchFilterClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(CatchFilterClauseSyntax original, CatchFilterClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.WhenKeyword,
    		    Modified = modified.WhenKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(CatchFilterClauseSyntax original, CatchFilterClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class FinallyClauseServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(FinallyClauseSyntax, FinallyClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(FinallyClauseSyntax, FinallyClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(FinallyClauseSyntax, FinallyClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(FinallyClauseSyntax, FinallyClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(FinallyClauseSyntax original, FinallyClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(FinallyClauseSyntax, FinallyClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(FinallyClauseSyntax, FinallyClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(FinallyClauseSyntax original, FinallyClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="FinallyClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(FinallyClauseSyntax, FinallyClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(FinallyClauseSyntax original, FinallyClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.FinallyKeyword,
    		    Modified = modified.FinallyKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(FinallyClauseSyntax original, FinallyClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class CompilationUnitServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(CompilationUnitSyntax, CompilationUnitSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(CompilationUnitSyntax, CompilationUnitSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(CompilationUnitSyntax, CompilationUnitSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(CompilationUnitSyntax, CompilationUnitSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(CompilationUnitSyntax original, CompilationUnitSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(CompilationUnitSyntax, CompilationUnitSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(CompilationUnitSyntax, CompilationUnitSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(CompilationUnitSyntax original, CompilationUnitSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CompilationUnitSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(CompilationUnitSyntax, CompilationUnitSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(CompilationUnitSyntax original, CompilationUnitSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfFileToken,
    		    Modified = modified.EndOfFileToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(CompilationUnitSyntax original, CompilationUnitSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ExternAliasDirectiveServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ExternAliasDirectiveSyntax original, ExternAliasDirectiveSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ExternAliasDirectiveSyntax original, ExternAliasDirectiveSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ExternAliasDirectiveSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ExternAliasDirectiveSyntax original, ExternAliasDirectiveSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ExternKeyword,
    		    Modified = modified.ExternKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.AliasKeyword,
    		    Modified = modified.AliasKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ExternAliasDirectiveSyntax original, ExternAliasDirectiveSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class UsingDirectiveServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(UsingDirectiveSyntax, UsingDirectiveSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(UsingDirectiveSyntax, UsingDirectiveSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(UsingDirectiveSyntax, UsingDirectiveSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(UsingDirectiveSyntax, UsingDirectiveSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(UsingDirectiveSyntax original, UsingDirectiveSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(UsingDirectiveSyntax, UsingDirectiveSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(UsingDirectiveSyntax, UsingDirectiveSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(UsingDirectiveSyntax original, UsingDirectiveSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="UsingDirectiveSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(UsingDirectiveSyntax, UsingDirectiveSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(UsingDirectiveSyntax original, UsingDirectiveSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.UsingKeyword,
    		    Modified = modified.UsingKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.StaticKeyword,
    		    Modified = modified.StaticKeyword
    		};
    		if(original.StaticKeyword != null && modified.StaticKeyword != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.StaticKeyword != null)
    			matchingSet.Originals.DisableMatching(original.StaticKeyword);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.StaticKeyword);
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(UsingDirectiveSyntax original, UsingDirectiveSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class AttributeListServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(AttributeListSyntax, AttributeListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(AttributeListSyntax, AttributeListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(AttributeListSyntax, AttributeListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(AttributeListSyntax, AttributeListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(AttributeListSyntax original, AttributeListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(AttributeListSyntax, AttributeListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(AttributeListSyntax, AttributeListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(AttributeListSyntax original, AttributeListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AttributeListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(AttributeListSyntax, AttributeListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(AttributeListSyntax original, AttributeListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBracketToken,
    		    Modified = modified.OpenBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBracketToken,
    		    Modified = modified.CloseBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(AttributeListSyntax original, AttributeListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class AttributeTargetSpecifierServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(AttributeTargetSpecifierSyntax original, AttributeTargetSpecifierSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(AttributeTargetSpecifierSyntax original, AttributeTargetSpecifierSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AttributeTargetSpecifierSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(AttributeTargetSpecifierSyntax original, AttributeTargetSpecifierSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(AttributeTargetSpecifierSyntax original, AttributeTargetSpecifierSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class AttributeArgumentListServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(AttributeArgumentListSyntax, AttributeArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(AttributeArgumentListSyntax, AttributeArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(AttributeArgumentListSyntax, AttributeArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(AttributeArgumentListSyntax, AttributeArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(AttributeArgumentListSyntax original, AttributeArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(AttributeArgumentListSyntax, AttributeArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(AttributeArgumentListSyntax, AttributeArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(AttributeArgumentListSyntax original, AttributeArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AttributeArgumentListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(AttributeArgumentListSyntax, AttributeArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(AttributeArgumentListSyntax original, AttributeArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(AttributeArgumentListSyntax original, AttributeArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class DelegateDeclarationServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(DelegateDeclarationSyntax, DelegateDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(DelegateDeclarationSyntax, DelegateDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(DelegateDeclarationSyntax, DelegateDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(DelegateDeclarationSyntax, DelegateDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(DelegateDeclarationSyntax original, DelegateDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(DelegateDeclarationSyntax, DelegateDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(DelegateDeclarationSyntax, DelegateDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(DelegateDeclarationSyntax original, DelegateDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DelegateDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(DelegateDeclarationSyntax, DelegateDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(DelegateDeclarationSyntax original, DelegateDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.DelegateKeyword,
    		    Modified = modified.DelegateKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(DelegateDeclarationSyntax original, DelegateDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class EnumMemberDeclarationServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(EnumMemberDeclarationSyntax original, EnumMemberDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(EnumMemberDeclarationSyntax original, EnumMemberDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EnumMemberDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(EnumMemberDeclarationSyntax original, EnumMemberDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(EnumMemberDeclarationSyntax original, EnumMemberDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class NamespaceDeclarationServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(NamespaceDeclarationSyntax, NamespaceDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(NamespaceDeclarationSyntax, NamespaceDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(NamespaceDeclarationSyntax, NamespaceDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(NamespaceDeclarationSyntax, NamespaceDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(NamespaceDeclarationSyntax original, NamespaceDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(NamespaceDeclarationSyntax, NamespaceDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(NamespaceDeclarationSyntax, NamespaceDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(NamespaceDeclarationSyntax original, NamespaceDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="NamespaceDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(NamespaceDeclarationSyntax, NamespaceDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(NamespaceDeclarationSyntax original, NamespaceDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.NamespaceKeyword,
    		    Modified = modified.NamespaceKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && modified.SemicolonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.SemicolonToken != null)
    			matchingSet.Originals.DisableMatching(original.SemicolonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(NamespaceDeclarationSyntax original, NamespaceDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class EnumDeclarationServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(EnumDeclarationSyntax, EnumDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(EnumDeclarationSyntax, EnumDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(EnumDeclarationSyntax, EnumDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(EnumDeclarationSyntax, EnumDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(EnumDeclarationSyntax original, EnumDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(EnumDeclarationSyntax, EnumDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(EnumDeclarationSyntax, EnumDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(EnumDeclarationSyntax original, EnumDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EnumDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(EnumDeclarationSyntax, EnumDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(EnumDeclarationSyntax original, EnumDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EnumKeyword,
    		    Modified = modified.EnumKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && modified.SemicolonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.SemicolonToken != null)
    			matchingSet.Originals.DisableMatching(original.SemicolonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(EnumDeclarationSyntax original, EnumDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ClassDeclarationServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ClassDeclarationSyntax, ClassDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ClassDeclarationSyntax, ClassDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ClassDeclarationSyntax, ClassDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ClassDeclarationSyntax, ClassDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ClassDeclarationSyntax original, ClassDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ClassDeclarationSyntax, ClassDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ClassDeclarationSyntax, ClassDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ClassDeclarationSyntax original, ClassDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ClassDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ClassDeclarationSyntax, ClassDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ClassDeclarationSyntax original, ClassDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && modified.SemicolonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.SemicolonToken != null)
    			matchingSet.Originals.DisableMatching(original.SemicolonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ClassDeclarationSyntax original, ClassDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class StructDeclarationServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(StructDeclarationSyntax, StructDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(StructDeclarationSyntax, StructDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(StructDeclarationSyntax, StructDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(StructDeclarationSyntax, StructDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(StructDeclarationSyntax original, StructDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(StructDeclarationSyntax, StructDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(StructDeclarationSyntax, StructDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(StructDeclarationSyntax original, StructDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="StructDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(StructDeclarationSyntax, StructDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(StructDeclarationSyntax original, StructDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && modified.SemicolonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.SemicolonToken != null)
    			matchingSet.Originals.DisableMatching(original.SemicolonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(StructDeclarationSyntax original, StructDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class InterfaceDeclarationServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(InterfaceDeclarationSyntax, InterfaceDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(InterfaceDeclarationSyntax, InterfaceDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(InterfaceDeclarationSyntax, InterfaceDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(InterfaceDeclarationSyntax, InterfaceDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(InterfaceDeclarationSyntax original, InterfaceDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(InterfaceDeclarationSyntax, InterfaceDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(InterfaceDeclarationSyntax, InterfaceDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(InterfaceDeclarationSyntax original, InterfaceDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="InterfaceDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(InterfaceDeclarationSyntax, InterfaceDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(InterfaceDeclarationSyntax original, InterfaceDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && modified.SemicolonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.SemicolonToken != null)
    			matchingSet.Originals.DisableMatching(original.SemicolonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(InterfaceDeclarationSyntax original, InterfaceDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class FieldDeclarationServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(FieldDeclarationSyntax, FieldDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(FieldDeclarationSyntax, FieldDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(FieldDeclarationSyntax, FieldDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(FieldDeclarationSyntax, FieldDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(FieldDeclarationSyntax original, FieldDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(FieldDeclarationSyntax, FieldDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(FieldDeclarationSyntax, FieldDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(FieldDeclarationSyntax original, FieldDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="FieldDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(FieldDeclarationSyntax, FieldDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(FieldDeclarationSyntax original, FieldDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(FieldDeclarationSyntax original, FieldDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class EventFieldDeclarationServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(EventFieldDeclarationSyntax, EventFieldDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(EventFieldDeclarationSyntax, EventFieldDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(EventFieldDeclarationSyntax, EventFieldDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(EventFieldDeclarationSyntax, EventFieldDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(EventFieldDeclarationSyntax original, EventFieldDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(EventFieldDeclarationSyntax, EventFieldDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(EventFieldDeclarationSyntax, EventFieldDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(EventFieldDeclarationSyntax original, EventFieldDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EventFieldDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(EventFieldDeclarationSyntax, EventFieldDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(EventFieldDeclarationSyntax original, EventFieldDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EventKeyword,
    		    Modified = modified.EventKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(EventFieldDeclarationSyntax original, EventFieldDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class MethodDeclarationServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(MethodDeclarationSyntax, MethodDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(MethodDeclarationSyntax, MethodDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(MethodDeclarationSyntax, MethodDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(MethodDeclarationSyntax, MethodDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(MethodDeclarationSyntax original, MethodDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(MethodDeclarationSyntax, MethodDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(MethodDeclarationSyntax, MethodDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(MethodDeclarationSyntax original, MethodDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="MethodDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(MethodDeclarationSyntax, MethodDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(MethodDeclarationSyntax original, MethodDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && modified.SemicolonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.SemicolonToken != null)
    			matchingSet.Originals.DisableMatching(original.SemicolonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(MethodDeclarationSyntax original, MethodDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class OperatorDeclarationServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(OperatorDeclarationSyntax, OperatorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(OperatorDeclarationSyntax, OperatorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(OperatorDeclarationSyntax, OperatorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(OperatorDeclarationSyntax, OperatorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(OperatorDeclarationSyntax original, OperatorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(OperatorDeclarationSyntax, OperatorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(OperatorDeclarationSyntax, OperatorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(OperatorDeclarationSyntax original, OperatorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="OperatorDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(OperatorDeclarationSyntax, OperatorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(OperatorDeclarationSyntax original, OperatorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorKeyword,
    		    Modified = modified.OperatorKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorToken,
    		    Modified = modified.OperatorToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && modified.SemicolonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.SemicolonToken != null)
    			matchingSet.Originals.DisableMatching(original.SemicolonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(OperatorDeclarationSyntax original, OperatorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ConversionOperatorDeclarationServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ConversionOperatorDeclarationSyntax original, ConversionOperatorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ConversionOperatorDeclarationSyntax original, ConversionOperatorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ConversionOperatorDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ConversionOperatorDeclarationSyntax original, ConversionOperatorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ImplicitOrExplicitKeyword,
    		    Modified = modified.ImplicitOrExplicitKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorKeyword,
    		    Modified = modified.OperatorKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && modified.SemicolonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.SemicolonToken != null)
    			matchingSet.Originals.DisableMatching(original.SemicolonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ConversionOperatorDeclarationSyntax original, ConversionOperatorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ConstructorDeclarationServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ConstructorDeclarationSyntax, ConstructorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ConstructorDeclarationSyntax, ConstructorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ConstructorDeclarationSyntax, ConstructorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ConstructorDeclarationSyntax, ConstructorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ConstructorDeclarationSyntax original, ConstructorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ConstructorDeclarationSyntax, ConstructorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ConstructorDeclarationSyntax, ConstructorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ConstructorDeclarationSyntax original, ConstructorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ConstructorDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ConstructorDeclarationSyntax, ConstructorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ConstructorDeclarationSyntax original, ConstructorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && modified.SemicolonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.SemicolonToken != null)
    			matchingSet.Originals.DisableMatching(original.SemicolonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ConstructorDeclarationSyntax original, ConstructorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class DestructorDeclarationServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(DestructorDeclarationSyntax, DestructorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(DestructorDeclarationSyntax, DestructorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(DestructorDeclarationSyntax, DestructorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(DestructorDeclarationSyntax, DestructorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(DestructorDeclarationSyntax original, DestructorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(DestructorDeclarationSyntax, DestructorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(DestructorDeclarationSyntax, DestructorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(DestructorDeclarationSyntax original, DestructorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DestructorDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(DestructorDeclarationSyntax, DestructorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(DestructorDeclarationSyntax original, DestructorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.TildeToken,
    		    Modified = modified.TildeToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && modified.SemicolonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.SemicolonToken != null)
    			matchingSet.Originals.DisableMatching(original.SemicolonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(DestructorDeclarationSyntax original, DestructorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class PropertyDeclarationServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(PropertyDeclarationSyntax, PropertyDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(PropertyDeclarationSyntax, PropertyDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(PropertyDeclarationSyntax, PropertyDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(PropertyDeclarationSyntax, PropertyDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(PropertyDeclarationSyntax original, PropertyDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(PropertyDeclarationSyntax, PropertyDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(PropertyDeclarationSyntax, PropertyDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(PropertyDeclarationSyntax original, PropertyDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="PropertyDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(PropertyDeclarationSyntax, PropertyDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(PropertyDeclarationSyntax original, PropertyDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && modified.SemicolonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.SemicolonToken != null)
    			matchingSet.Originals.DisableMatching(original.SemicolonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(PropertyDeclarationSyntax original, PropertyDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class EventDeclarationServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(EventDeclarationSyntax, EventDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(EventDeclarationSyntax, EventDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(EventDeclarationSyntax, EventDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(EventDeclarationSyntax, EventDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(EventDeclarationSyntax original, EventDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(EventDeclarationSyntax, EventDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(EventDeclarationSyntax, EventDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(EventDeclarationSyntax original, EventDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EventDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(EventDeclarationSyntax, EventDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(EventDeclarationSyntax original, EventDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EventKeyword,
    		    Modified = modified.EventKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(EventDeclarationSyntax original, EventDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class IndexerDeclarationServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(IndexerDeclarationSyntax, IndexerDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(IndexerDeclarationSyntax, IndexerDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(IndexerDeclarationSyntax, IndexerDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(IndexerDeclarationSyntax, IndexerDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(IndexerDeclarationSyntax original, IndexerDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(IndexerDeclarationSyntax, IndexerDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(IndexerDeclarationSyntax, IndexerDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(IndexerDeclarationSyntax original, IndexerDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="IndexerDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(IndexerDeclarationSyntax, IndexerDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(IndexerDeclarationSyntax original, IndexerDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ThisKeyword,
    		    Modified = modified.ThisKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && modified.SemicolonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.SemicolonToken != null)
    			matchingSet.Originals.DisableMatching(original.SemicolonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(IndexerDeclarationSyntax original, IndexerDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ConstructorConstraintServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ConstructorConstraintSyntax, ConstructorConstraintSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ConstructorConstraintSyntax, ConstructorConstraintSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ConstructorConstraintSyntax, ConstructorConstraintSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ConstructorConstraintSyntax, ConstructorConstraintSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ConstructorConstraintSyntax original, ConstructorConstraintSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ConstructorConstraintSyntax, ConstructorConstraintSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ConstructorConstraintSyntax, ConstructorConstraintSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ConstructorConstraintSyntax original, ConstructorConstraintSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ConstructorConstraintSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ConstructorConstraintSyntax, ConstructorConstraintSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ConstructorConstraintSyntax original, ConstructorConstraintSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.NewKeyword,
    		    Modified = modified.NewKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ConstructorConstraintSyntax original, ConstructorConstraintSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ClassOrStructConstraintServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ClassOrStructConstraintSyntax original, ClassOrStructConstraintSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ClassOrStructConstraintSyntax original, ClassOrStructConstraintSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ClassOrStructConstraintSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ClassOrStructConstraintSyntax original, ClassOrStructConstraintSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ClassOrStructKeyword,
    		    Modified = modified.ClassOrStructKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ClassOrStructConstraintSyntax original, ClassOrStructConstraintSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ParameterListServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ParameterListSyntax, ParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ParameterListSyntax, ParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ParameterListSyntax, ParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ParameterListSyntax, ParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ParameterListSyntax original, ParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ParameterListSyntax, ParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ParameterListSyntax, ParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ParameterListSyntax original, ParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ParameterListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ParameterListSyntax, ParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ParameterListSyntax original, ParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ParameterListSyntax original, ParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class BracketedParameterListServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(BracketedParameterListSyntax, BracketedParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(BracketedParameterListSyntax, BracketedParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(BracketedParameterListSyntax, BracketedParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(BracketedParameterListSyntax, BracketedParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(BracketedParameterListSyntax original, BracketedParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(BracketedParameterListSyntax, BracketedParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(BracketedParameterListSyntax, BracketedParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(BracketedParameterListSyntax original, BracketedParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BracketedParameterListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(BracketedParameterListSyntax, BracketedParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(BracketedParameterListSyntax original, BracketedParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBracketToken,
    		    Modified = modified.OpenBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBracketToken,
    		    Modified = modified.CloseBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(BracketedParameterListSyntax original, BracketedParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class DocumentationCommentTriviaServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(DocumentationCommentTriviaSyntax original, DocumentationCommentTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(DocumentationCommentTriviaSyntax original, DocumentationCommentTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DocumentationCommentTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(DocumentationCommentTriviaSyntax original, DocumentationCommentTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfComment,
    		    Modified = modified.EndOfComment
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(DocumentationCommentTriviaSyntax original, DocumentationCommentTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class EndIfDirectiveTriviaServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(EndIfDirectiveTriviaSyntax original, EndIfDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(EndIfDirectiveTriviaSyntax original, EndIfDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EndIfDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(EndIfDirectiveTriviaSyntax original, EndIfDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndIfKeyword,
    		    Modified = modified.EndIfKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(EndIfDirectiveTriviaSyntax original, EndIfDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class RegionDirectiveTriviaServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(RegionDirectiveTriviaSyntax original, RegionDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(RegionDirectiveTriviaSyntax original, RegionDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="RegionDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(RegionDirectiveTriviaSyntax original, RegionDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.RegionKeyword,
    		    Modified = modified.RegionKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(RegionDirectiveTriviaSyntax original, RegionDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class EndRegionDirectiveTriviaServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(EndRegionDirectiveTriviaSyntax original, EndRegionDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(EndRegionDirectiveTriviaSyntax original, EndRegionDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EndRegionDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(EndRegionDirectiveTriviaSyntax original, EndRegionDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndRegionKeyword,
    		    Modified = modified.EndRegionKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(EndRegionDirectiveTriviaSyntax original, EndRegionDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ErrorDirectiveTriviaServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ErrorDirectiveTriviaSyntax original, ErrorDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ErrorDirectiveTriviaSyntax original, ErrorDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ErrorDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ErrorDirectiveTriviaSyntax original, ErrorDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ErrorKeyword,
    		    Modified = modified.ErrorKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ErrorDirectiveTriviaSyntax original, ErrorDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class WarningDirectiveTriviaServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(WarningDirectiveTriviaSyntax original, WarningDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(WarningDirectiveTriviaSyntax original, WarningDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="WarningDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(WarningDirectiveTriviaSyntax original, WarningDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.WarningKeyword,
    		    Modified = modified.WarningKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(WarningDirectiveTriviaSyntax original, WarningDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class BadDirectiveTriviaServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(BadDirectiveTriviaSyntax original, BadDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(BadDirectiveTriviaSyntax original, BadDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BadDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(BadDirectiveTriviaSyntax original, BadDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(BadDirectiveTriviaSyntax original, BadDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class DefineDirectiveTriviaServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(DefineDirectiveTriviaSyntax original, DefineDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(DefineDirectiveTriviaSyntax original, DefineDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DefineDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(DefineDirectiveTriviaSyntax original, DefineDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.DefineKeyword,
    		    Modified = modified.DefineKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Name,
    		    Modified = modified.Name
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(DefineDirectiveTriviaSyntax original, DefineDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class UndefDirectiveTriviaServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(UndefDirectiveTriviaSyntax original, UndefDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(UndefDirectiveTriviaSyntax original, UndefDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="UndefDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(UndefDirectiveTriviaSyntax original, UndefDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.UndefKeyword,
    		    Modified = modified.UndefKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Name,
    		    Modified = modified.Name
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(UndefDirectiveTriviaSyntax original, UndefDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class LineDirectiveTriviaServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(LineDirectiveTriviaSyntax original, LineDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(LineDirectiveTriviaSyntax original, LineDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LineDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(LineDirectiveTriviaSyntax original, LineDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LineKeyword,
    		    Modified = modified.LineKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Line,
    		    Modified = modified.Line
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.File,
    		    Modified = modified.File
    		};
    		if(original.File != null && modified.File != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.File != null)
    			matchingSet.Originals.DisableMatching(original.File);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.File);
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(LineDirectiveTriviaSyntax original, LineDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class PragmaWarningDirectiveTriviaServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(PragmaWarningDirectiveTriviaSyntax original, PragmaWarningDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(PragmaWarningDirectiveTriviaSyntax original, PragmaWarningDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="PragmaWarningDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(PragmaWarningDirectiveTriviaSyntax original, PragmaWarningDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.PragmaKeyword,
    		    Modified = modified.PragmaKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.WarningKeyword,
    		    Modified = modified.WarningKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.DisableOrRestoreKeyword,
    		    Modified = modified.DisableOrRestoreKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(PragmaWarningDirectiveTriviaSyntax original, PragmaWarningDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class PragmaChecksumDirectiveTriviaServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(PragmaChecksumDirectiveTriviaSyntax original, PragmaChecksumDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(PragmaChecksumDirectiveTriviaSyntax original, PragmaChecksumDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="PragmaChecksumDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(PragmaChecksumDirectiveTriviaSyntax original, PragmaChecksumDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.PragmaKeyword,
    		    Modified = modified.PragmaKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ChecksumKeyword,
    		    Modified = modified.ChecksumKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.File,
    		    Modified = modified.File
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Guid,
    		    Modified = modified.Guid
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Bytes,
    		    Modified = modified.Bytes
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(PragmaChecksumDirectiveTriviaSyntax original, PragmaChecksumDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ReferenceDirectiveTriviaServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ReferenceDirectiveTriviaSyntax original, ReferenceDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ReferenceDirectiveTriviaSyntax original, ReferenceDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ReferenceDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ReferenceDirectiveTriviaSyntax original, ReferenceDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ReferenceKeyword,
    		    Modified = modified.ReferenceKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.File,
    		    Modified = modified.File
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ReferenceDirectiveTriviaSyntax original, ReferenceDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class LoadDirectiveTriviaServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(LoadDirectiveTriviaSyntax original, LoadDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(LoadDirectiveTriviaSyntax original, LoadDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LoadDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(LoadDirectiveTriviaSyntax original, LoadDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LoadKeyword,
    		    Modified = modified.LoadKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.File,
    		    Modified = modified.File
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(LoadDirectiveTriviaSyntax original, LoadDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ShebangDirectiveTriviaServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ShebangDirectiveTriviaSyntax original, ShebangDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ShebangDirectiveTriviaSyntax original, ShebangDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ShebangDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ShebangDirectiveTriviaSyntax original, ShebangDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ExclamationToken,
    		    Modified = modified.ExclamationToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ShebangDirectiveTriviaSyntax original, ShebangDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ElseDirectiveTriviaServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ElseDirectiveTriviaSyntax original, ElseDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ElseDirectiveTriviaSyntax original, ElseDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ElseDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ElseDirectiveTriviaSyntax original, ElseDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ElseKeyword,
    		    Modified = modified.ElseKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ElseDirectiveTriviaSyntax original, ElseDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class IfDirectiveTriviaServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(IfDirectiveTriviaSyntax original, IfDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(IfDirectiveTriviaSyntax original, IfDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="IfDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(IfDirectiveTriviaSyntax original, IfDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.IfKeyword,
    		    Modified = modified.IfKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(IfDirectiveTriviaSyntax original, IfDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ElifDirectiveTriviaServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ElifDirectiveTriviaSyntax original, ElifDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ElifDirectiveTriviaSyntax original, ElifDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ElifDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ElifDirectiveTriviaSyntax original, ElifDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ElifKeyword,
    		    Modified = modified.ElifKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ElifDirectiveTriviaSyntax original, ElifDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class QualifiedCrefServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(QualifiedCrefSyntax, QualifiedCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(QualifiedCrefSyntax, QualifiedCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(QualifiedCrefSyntax, QualifiedCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(QualifiedCrefSyntax, QualifiedCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(QualifiedCrefSyntax original, QualifiedCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(QualifiedCrefSyntax, QualifiedCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(QualifiedCrefSyntax, QualifiedCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(QualifiedCrefSyntax original, QualifiedCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="QualifiedCrefSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(QualifiedCrefSyntax, QualifiedCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(QualifiedCrefSyntax original, QualifiedCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.DotToken,
    		    Modified = modified.DotToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(QualifiedCrefSyntax original, QualifiedCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class IndexerMemberCrefServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(IndexerMemberCrefSyntax, IndexerMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(IndexerMemberCrefSyntax, IndexerMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(IndexerMemberCrefSyntax, IndexerMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(IndexerMemberCrefSyntax, IndexerMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(IndexerMemberCrefSyntax original, IndexerMemberCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(IndexerMemberCrefSyntax, IndexerMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(IndexerMemberCrefSyntax, IndexerMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(IndexerMemberCrefSyntax original, IndexerMemberCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="IndexerMemberCrefSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(IndexerMemberCrefSyntax, IndexerMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(IndexerMemberCrefSyntax original, IndexerMemberCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ThisKeyword,
    		    Modified = modified.ThisKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(IndexerMemberCrefSyntax original, IndexerMemberCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class OperatorMemberCrefServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(OperatorMemberCrefSyntax, OperatorMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(OperatorMemberCrefSyntax, OperatorMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(OperatorMemberCrefSyntax, OperatorMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(OperatorMemberCrefSyntax, OperatorMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(OperatorMemberCrefSyntax original, OperatorMemberCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(OperatorMemberCrefSyntax, OperatorMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(OperatorMemberCrefSyntax, OperatorMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(OperatorMemberCrefSyntax original, OperatorMemberCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="OperatorMemberCrefSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(OperatorMemberCrefSyntax, OperatorMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(OperatorMemberCrefSyntax original, OperatorMemberCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorKeyword,
    		    Modified = modified.OperatorKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorToken,
    		    Modified = modified.OperatorToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(OperatorMemberCrefSyntax original, OperatorMemberCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ConversionOperatorMemberCrefServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ConversionOperatorMemberCrefSyntax original, ConversionOperatorMemberCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ConversionOperatorMemberCrefSyntax original, ConversionOperatorMemberCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ConversionOperatorMemberCrefSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ConversionOperatorMemberCrefSyntax original, ConversionOperatorMemberCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ImplicitOrExplicitKeyword,
    		    Modified = modified.ImplicitOrExplicitKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorKeyword,
    		    Modified = modified.OperatorKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ConversionOperatorMemberCrefSyntax original, ConversionOperatorMemberCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class CrefParameterListServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(CrefParameterListSyntax, CrefParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(CrefParameterListSyntax, CrefParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(CrefParameterListSyntax, CrefParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(CrefParameterListSyntax, CrefParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(CrefParameterListSyntax original, CrefParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(CrefParameterListSyntax, CrefParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(CrefParameterListSyntax, CrefParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(CrefParameterListSyntax original, CrefParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CrefParameterListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(CrefParameterListSyntax, CrefParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(CrefParameterListSyntax original, CrefParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(CrefParameterListSyntax original, CrefParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class CrefBracketedParameterListServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(CrefBracketedParameterListSyntax original, CrefBracketedParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(CrefBracketedParameterListSyntax original, CrefBracketedParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CrefBracketedParameterListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(CrefBracketedParameterListSyntax original, CrefBracketedParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBracketToken,
    		    Modified = modified.OpenBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBracketToken,
    		    Modified = modified.CloseBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(CrefBracketedParameterListSyntax original, CrefBracketedParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class XmlEmptyElementServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(XmlEmptyElementSyntax, XmlEmptyElementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(XmlEmptyElementSyntax, XmlEmptyElementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(XmlEmptyElementSyntax, XmlEmptyElementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(XmlEmptyElementSyntax, XmlEmptyElementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(XmlEmptyElementSyntax original, XmlEmptyElementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(XmlEmptyElementSyntax, XmlEmptyElementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(XmlEmptyElementSyntax, XmlEmptyElementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(XmlEmptyElementSyntax original, XmlEmptyElementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlEmptyElementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(XmlEmptyElementSyntax, XmlEmptyElementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(XmlEmptyElementSyntax original, XmlEmptyElementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LessThanToken,
    		    Modified = modified.LessThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SlashGreaterThanToken,
    		    Modified = modified.SlashGreaterThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(XmlEmptyElementSyntax original, XmlEmptyElementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class XmlCDataSectionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(XmlCDataSectionSyntax, XmlCDataSectionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(XmlCDataSectionSyntax, XmlCDataSectionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(XmlCDataSectionSyntax, XmlCDataSectionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(XmlCDataSectionSyntax, XmlCDataSectionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(XmlCDataSectionSyntax original, XmlCDataSectionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(XmlCDataSectionSyntax, XmlCDataSectionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(XmlCDataSectionSyntax, XmlCDataSectionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(XmlCDataSectionSyntax original, XmlCDataSectionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlCDataSectionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(XmlCDataSectionSyntax, XmlCDataSectionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(XmlCDataSectionSyntax original, XmlCDataSectionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.StartCDataToken,
    		    Modified = modified.StartCDataToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndCDataToken,
    		    Modified = modified.EndCDataToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(XmlCDataSectionSyntax original, XmlCDataSectionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class XmlProcessingInstructionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(XmlProcessingInstructionSyntax original, XmlProcessingInstructionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(XmlProcessingInstructionSyntax original, XmlProcessingInstructionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlProcessingInstructionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(XmlProcessingInstructionSyntax original, XmlProcessingInstructionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.StartProcessingInstructionToken,
    		    Modified = modified.StartProcessingInstructionToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndProcessingInstructionToken,
    		    Modified = modified.EndProcessingInstructionToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(XmlProcessingInstructionSyntax original, XmlProcessingInstructionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class XmlCommentServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(XmlCommentSyntax, XmlCommentSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(XmlCommentSyntax, XmlCommentSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(XmlCommentSyntax, XmlCommentSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(XmlCommentSyntax, XmlCommentSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(XmlCommentSyntax original, XmlCommentSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(XmlCommentSyntax, XmlCommentSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(XmlCommentSyntax, XmlCommentSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(XmlCommentSyntax original, XmlCommentSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlCommentSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(XmlCommentSyntax, XmlCommentSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(XmlCommentSyntax original, XmlCommentSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LessThanExclamationMinusMinusToken,
    		    Modified = modified.LessThanExclamationMinusMinusToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.MinusMinusGreaterThanToken,
    		    Modified = modified.MinusMinusGreaterThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(XmlCommentSyntax original, XmlCommentSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class XmlTextAttributeServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(XmlTextAttributeSyntax, XmlTextAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(XmlTextAttributeSyntax, XmlTextAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(XmlTextAttributeSyntax, XmlTextAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(XmlTextAttributeSyntax, XmlTextAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(XmlTextAttributeSyntax original, XmlTextAttributeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(XmlTextAttributeSyntax, XmlTextAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(XmlTextAttributeSyntax, XmlTextAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(XmlTextAttributeSyntax original, XmlTextAttributeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlTextAttributeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(XmlTextAttributeSyntax, XmlTextAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(XmlTextAttributeSyntax original, XmlTextAttributeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EqualsToken,
    		    Modified = modified.EqualsToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.StartQuoteToken,
    		    Modified = modified.StartQuoteToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndQuoteToken,
    		    Modified = modified.EndQuoteToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(XmlTextAttributeSyntax original, XmlTextAttributeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class XmlCrefAttributeServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(XmlCrefAttributeSyntax, XmlCrefAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(XmlCrefAttributeSyntax, XmlCrefAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(XmlCrefAttributeSyntax, XmlCrefAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(XmlCrefAttributeSyntax, XmlCrefAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(XmlCrefAttributeSyntax original, XmlCrefAttributeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(XmlCrefAttributeSyntax, XmlCrefAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(XmlCrefAttributeSyntax, XmlCrefAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(XmlCrefAttributeSyntax original, XmlCrefAttributeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlCrefAttributeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(XmlCrefAttributeSyntax, XmlCrefAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(XmlCrefAttributeSyntax original, XmlCrefAttributeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EqualsToken,
    		    Modified = modified.EqualsToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.StartQuoteToken,
    		    Modified = modified.StartQuoteToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndQuoteToken,
    		    Modified = modified.EndQuoteToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(XmlCrefAttributeSyntax original, XmlCrefAttributeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class XmlNameAttributeServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(XmlNameAttributeSyntax, XmlNameAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(XmlNameAttributeSyntax, XmlNameAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(XmlNameAttributeSyntax, XmlNameAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(XmlNameAttributeSyntax, XmlNameAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(XmlNameAttributeSyntax original, XmlNameAttributeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(XmlNameAttributeSyntax, XmlNameAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(XmlNameAttributeSyntax, XmlNameAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(XmlNameAttributeSyntax original, XmlNameAttributeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlNameAttributeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(XmlNameAttributeSyntax, XmlNameAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(XmlNameAttributeSyntax original, XmlNameAttributeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EqualsToken,
    		    Modified = modified.EqualsToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.StartQuoteToken,
    		    Modified = modified.StartQuoteToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndQuoteToken,
    		    Modified = modified.EndQuoteToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(XmlNameAttributeSyntax original, XmlNameAttributeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ParenthesizedExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ParenthesizedExpressionSyntax original, ParenthesizedExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ParenthesizedExpressionSyntax original, ParenthesizedExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ParenthesizedExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ParenthesizedExpressionSyntax original, ParenthesizedExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ParenthesizedExpressionSyntax original, ParenthesizedExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class TupleExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(TupleExpressionSyntax, TupleExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(TupleExpressionSyntax, TupleExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(TupleExpressionSyntax, TupleExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(TupleExpressionSyntax, TupleExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(TupleExpressionSyntax original, TupleExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(TupleExpressionSyntax, TupleExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(TupleExpressionSyntax, TupleExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(TupleExpressionSyntax original, TupleExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TupleExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(TupleExpressionSyntax, TupleExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(TupleExpressionSyntax original, TupleExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(TupleExpressionSyntax original, TupleExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class PrefixUnaryExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(PrefixUnaryExpressionSyntax original, PrefixUnaryExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(PrefixUnaryExpressionSyntax original, PrefixUnaryExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="PrefixUnaryExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(PrefixUnaryExpressionSyntax original, PrefixUnaryExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorToken,
    		    Modified = modified.OperatorToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(PrefixUnaryExpressionSyntax original, PrefixUnaryExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class AwaitExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(AwaitExpressionSyntax, AwaitExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(AwaitExpressionSyntax, AwaitExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(AwaitExpressionSyntax, AwaitExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(AwaitExpressionSyntax, AwaitExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(AwaitExpressionSyntax original, AwaitExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(AwaitExpressionSyntax, AwaitExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(AwaitExpressionSyntax, AwaitExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(AwaitExpressionSyntax original, AwaitExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AwaitExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(AwaitExpressionSyntax, AwaitExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(AwaitExpressionSyntax original, AwaitExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.AwaitKeyword,
    		    Modified = modified.AwaitKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(AwaitExpressionSyntax original, AwaitExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class PostfixUnaryExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(PostfixUnaryExpressionSyntax original, PostfixUnaryExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(PostfixUnaryExpressionSyntax original, PostfixUnaryExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="PostfixUnaryExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(PostfixUnaryExpressionSyntax original, PostfixUnaryExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorToken,
    		    Modified = modified.OperatorToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(PostfixUnaryExpressionSyntax original, PostfixUnaryExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class MemberAccessExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(MemberAccessExpressionSyntax, MemberAccessExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(MemberAccessExpressionSyntax, MemberAccessExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(MemberAccessExpressionSyntax, MemberAccessExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(MemberAccessExpressionSyntax, MemberAccessExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(MemberAccessExpressionSyntax original, MemberAccessExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(MemberAccessExpressionSyntax, MemberAccessExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(MemberAccessExpressionSyntax, MemberAccessExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(MemberAccessExpressionSyntax original, MemberAccessExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="MemberAccessExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(MemberAccessExpressionSyntax, MemberAccessExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(MemberAccessExpressionSyntax original, MemberAccessExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorToken,
    		    Modified = modified.OperatorToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(MemberAccessExpressionSyntax original, MemberAccessExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ConditionalAccessExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ConditionalAccessExpressionSyntax original, ConditionalAccessExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ConditionalAccessExpressionSyntax original, ConditionalAccessExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ConditionalAccessExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ConditionalAccessExpressionSyntax original, ConditionalAccessExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorToken,
    		    Modified = modified.OperatorToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ConditionalAccessExpressionSyntax original, ConditionalAccessExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class MemberBindingExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(MemberBindingExpressionSyntax, MemberBindingExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(MemberBindingExpressionSyntax, MemberBindingExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(MemberBindingExpressionSyntax, MemberBindingExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(MemberBindingExpressionSyntax, MemberBindingExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(MemberBindingExpressionSyntax original, MemberBindingExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(MemberBindingExpressionSyntax, MemberBindingExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(MemberBindingExpressionSyntax, MemberBindingExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(MemberBindingExpressionSyntax original, MemberBindingExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="MemberBindingExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(MemberBindingExpressionSyntax, MemberBindingExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(MemberBindingExpressionSyntax original, MemberBindingExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorToken,
    		    Modified = modified.OperatorToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(MemberBindingExpressionSyntax original, MemberBindingExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class BinaryExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(BinaryExpressionSyntax, BinaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(BinaryExpressionSyntax, BinaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(BinaryExpressionSyntax, BinaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(BinaryExpressionSyntax, BinaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(BinaryExpressionSyntax original, BinaryExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(BinaryExpressionSyntax, BinaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(BinaryExpressionSyntax, BinaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(BinaryExpressionSyntax original, BinaryExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BinaryExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(BinaryExpressionSyntax, BinaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(BinaryExpressionSyntax original, BinaryExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorToken,
    		    Modified = modified.OperatorToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(BinaryExpressionSyntax original, BinaryExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class AssignmentExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(AssignmentExpressionSyntax, AssignmentExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(AssignmentExpressionSyntax, AssignmentExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(AssignmentExpressionSyntax, AssignmentExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(AssignmentExpressionSyntax, AssignmentExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(AssignmentExpressionSyntax original, AssignmentExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(AssignmentExpressionSyntax, AssignmentExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(AssignmentExpressionSyntax, AssignmentExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(AssignmentExpressionSyntax original, AssignmentExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AssignmentExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(AssignmentExpressionSyntax, AssignmentExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(AssignmentExpressionSyntax original, AssignmentExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorToken,
    		    Modified = modified.OperatorToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(AssignmentExpressionSyntax original, AssignmentExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ConditionalExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ConditionalExpressionSyntax, ConditionalExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ConditionalExpressionSyntax, ConditionalExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ConditionalExpressionSyntax, ConditionalExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ConditionalExpressionSyntax, ConditionalExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ConditionalExpressionSyntax original, ConditionalExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ConditionalExpressionSyntax, ConditionalExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ConditionalExpressionSyntax, ConditionalExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ConditionalExpressionSyntax original, ConditionalExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ConditionalExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ConditionalExpressionSyntax, ConditionalExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ConditionalExpressionSyntax original, ConditionalExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.QuestionToken,
    		    Modified = modified.QuestionToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ConditionalExpressionSyntax original, ConditionalExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class LiteralExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(LiteralExpressionSyntax, LiteralExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(LiteralExpressionSyntax, LiteralExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(LiteralExpressionSyntax, LiteralExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(LiteralExpressionSyntax, LiteralExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(LiteralExpressionSyntax original, LiteralExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(LiteralExpressionSyntax, LiteralExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(LiteralExpressionSyntax, LiteralExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(LiteralExpressionSyntax original, LiteralExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LiteralExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(LiteralExpressionSyntax, LiteralExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(LiteralExpressionSyntax original, LiteralExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Token,
    		    Modified = modified.Token
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(LiteralExpressionSyntax original, LiteralExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class MakeRefExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(MakeRefExpressionSyntax, MakeRefExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(MakeRefExpressionSyntax, MakeRefExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(MakeRefExpressionSyntax, MakeRefExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(MakeRefExpressionSyntax, MakeRefExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(MakeRefExpressionSyntax original, MakeRefExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(MakeRefExpressionSyntax, MakeRefExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(MakeRefExpressionSyntax, MakeRefExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(MakeRefExpressionSyntax original, MakeRefExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="MakeRefExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(MakeRefExpressionSyntax, MakeRefExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(MakeRefExpressionSyntax original, MakeRefExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(MakeRefExpressionSyntax original, MakeRefExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class RefTypeExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(RefTypeExpressionSyntax, RefTypeExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(RefTypeExpressionSyntax, RefTypeExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(RefTypeExpressionSyntax, RefTypeExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(RefTypeExpressionSyntax, RefTypeExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(RefTypeExpressionSyntax original, RefTypeExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(RefTypeExpressionSyntax, RefTypeExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(RefTypeExpressionSyntax, RefTypeExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(RefTypeExpressionSyntax original, RefTypeExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="RefTypeExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(RefTypeExpressionSyntax, RefTypeExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(RefTypeExpressionSyntax original, RefTypeExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(RefTypeExpressionSyntax original, RefTypeExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class RefValueExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(RefValueExpressionSyntax, RefValueExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(RefValueExpressionSyntax, RefValueExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(RefValueExpressionSyntax, RefValueExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(RefValueExpressionSyntax, RefValueExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(RefValueExpressionSyntax original, RefValueExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(RefValueExpressionSyntax, RefValueExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(RefValueExpressionSyntax, RefValueExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(RefValueExpressionSyntax original, RefValueExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="RefValueExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(RefValueExpressionSyntax, RefValueExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(RefValueExpressionSyntax original, RefValueExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Comma,
    		    Modified = modified.Comma
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(RefValueExpressionSyntax original, RefValueExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class CheckedExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(CheckedExpressionSyntax, CheckedExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(CheckedExpressionSyntax, CheckedExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(CheckedExpressionSyntax, CheckedExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(CheckedExpressionSyntax, CheckedExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(CheckedExpressionSyntax original, CheckedExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(CheckedExpressionSyntax, CheckedExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(CheckedExpressionSyntax, CheckedExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(CheckedExpressionSyntax original, CheckedExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CheckedExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(CheckedExpressionSyntax, CheckedExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(CheckedExpressionSyntax original, CheckedExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(CheckedExpressionSyntax original, CheckedExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class DefaultExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(DefaultExpressionSyntax, DefaultExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(DefaultExpressionSyntax, DefaultExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(DefaultExpressionSyntax, DefaultExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(DefaultExpressionSyntax, DefaultExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(DefaultExpressionSyntax original, DefaultExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(DefaultExpressionSyntax, DefaultExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(DefaultExpressionSyntax, DefaultExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(DefaultExpressionSyntax original, DefaultExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DefaultExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(DefaultExpressionSyntax, DefaultExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(DefaultExpressionSyntax original, DefaultExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(DefaultExpressionSyntax original, DefaultExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class TypeOfExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(TypeOfExpressionSyntax, TypeOfExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(TypeOfExpressionSyntax, TypeOfExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(TypeOfExpressionSyntax, TypeOfExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(TypeOfExpressionSyntax, TypeOfExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(TypeOfExpressionSyntax original, TypeOfExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(TypeOfExpressionSyntax, TypeOfExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(TypeOfExpressionSyntax, TypeOfExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(TypeOfExpressionSyntax original, TypeOfExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TypeOfExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(TypeOfExpressionSyntax, TypeOfExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(TypeOfExpressionSyntax original, TypeOfExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(TypeOfExpressionSyntax original, TypeOfExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class SizeOfExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(SizeOfExpressionSyntax, SizeOfExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(SizeOfExpressionSyntax, SizeOfExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(SizeOfExpressionSyntax, SizeOfExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(SizeOfExpressionSyntax, SizeOfExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(SizeOfExpressionSyntax original, SizeOfExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(SizeOfExpressionSyntax, SizeOfExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(SizeOfExpressionSyntax, SizeOfExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(SizeOfExpressionSyntax original, SizeOfExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="SizeOfExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(SizeOfExpressionSyntax, SizeOfExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(SizeOfExpressionSyntax original, SizeOfExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(SizeOfExpressionSyntax original, SizeOfExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class CastExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(CastExpressionSyntax, CastExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(CastExpressionSyntax, CastExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(CastExpressionSyntax, CastExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(CastExpressionSyntax, CastExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(CastExpressionSyntax original, CastExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(CastExpressionSyntax, CastExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(CastExpressionSyntax, CastExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(CastExpressionSyntax original, CastExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CastExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(CastExpressionSyntax, CastExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(CastExpressionSyntax original, CastExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(CastExpressionSyntax original, CastExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class RefExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(RefExpressionSyntax, RefExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(RefExpressionSyntax, RefExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(RefExpressionSyntax, RefExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(RefExpressionSyntax, RefExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(RefExpressionSyntax original, RefExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(RefExpressionSyntax, RefExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(RefExpressionSyntax, RefExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(RefExpressionSyntax original, RefExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="RefExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(RefExpressionSyntax, RefExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(RefExpressionSyntax original, RefExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.RefKeyword,
    		    Modified = modified.RefKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(RefExpressionSyntax original, RefExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class InitializerExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(InitializerExpressionSyntax, InitializerExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(InitializerExpressionSyntax, InitializerExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(InitializerExpressionSyntax, InitializerExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(InitializerExpressionSyntax, InitializerExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(InitializerExpressionSyntax original, InitializerExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(InitializerExpressionSyntax, InitializerExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(InitializerExpressionSyntax, InitializerExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(InitializerExpressionSyntax original, InitializerExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="InitializerExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(InitializerExpressionSyntax, InitializerExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(InitializerExpressionSyntax original, InitializerExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(InitializerExpressionSyntax original, InitializerExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ObjectCreationExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ObjectCreationExpressionSyntax original, ObjectCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ObjectCreationExpressionSyntax original, ObjectCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ObjectCreationExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ObjectCreationExpressionSyntax original, ObjectCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.NewKeyword,
    		    Modified = modified.NewKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ObjectCreationExpressionSyntax original, ObjectCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class AnonymousObjectCreationExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(AnonymousObjectCreationExpressionSyntax original, AnonymousObjectCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(AnonymousObjectCreationExpressionSyntax original, AnonymousObjectCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AnonymousObjectCreationExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(AnonymousObjectCreationExpressionSyntax original, AnonymousObjectCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.NewKeyword,
    		    Modified = modified.NewKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(AnonymousObjectCreationExpressionSyntax original, AnonymousObjectCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ArrayCreationExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ArrayCreationExpressionSyntax original, ArrayCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ArrayCreationExpressionSyntax original, ArrayCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ArrayCreationExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ArrayCreationExpressionSyntax original, ArrayCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.NewKeyword,
    		    Modified = modified.NewKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ArrayCreationExpressionSyntax original, ArrayCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ImplicitArrayCreationExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ImplicitArrayCreationExpressionSyntax original, ImplicitArrayCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ImplicitArrayCreationExpressionSyntax original, ImplicitArrayCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ImplicitArrayCreationExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ImplicitArrayCreationExpressionSyntax original, ImplicitArrayCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.NewKeyword,
    		    Modified = modified.NewKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBracketToken,
    		    Modified = modified.OpenBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBracketToken,
    		    Modified = modified.CloseBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ImplicitArrayCreationExpressionSyntax original, ImplicitArrayCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class StackAllocArrayCreationExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(StackAllocArrayCreationExpressionSyntax original, StackAllocArrayCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(StackAllocArrayCreationExpressionSyntax original, StackAllocArrayCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="StackAllocArrayCreationExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(StackAllocArrayCreationExpressionSyntax original, StackAllocArrayCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.StackAllocKeyword,
    		    Modified = modified.StackAllocKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(StackAllocArrayCreationExpressionSyntax original, StackAllocArrayCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class OmittedArraySizeExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(OmittedArraySizeExpressionSyntax original, OmittedArraySizeExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(OmittedArraySizeExpressionSyntax original, OmittedArraySizeExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="OmittedArraySizeExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(OmittedArraySizeExpressionSyntax original, OmittedArraySizeExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OmittedArraySizeExpressionToken,
    		    Modified = modified.OmittedArraySizeExpressionToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(OmittedArraySizeExpressionSyntax original, OmittedArraySizeExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class InterpolatedStringExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(InterpolatedStringExpressionSyntax original, InterpolatedStringExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(InterpolatedStringExpressionSyntax original, InterpolatedStringExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="InterpolatedStringExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(InterpolatedStringExpressionSyntax original, InterpolatedStringExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.StringStartToken,
    		    Modified = modified.StringStartToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.StringEndToken,
    		    Modified = modified.StringEndToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(InterpolatedStringExpressionSyntax original, InterpolatedStringExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class IsPatternExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(IsPatternExpressionSyntax, IsPatternExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(IsPatternExpressionSyntax, IsPatternExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(IsPatternExpressionSyntax, IsPatternExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(IsPatternExpressionSyntax, IsPatternExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(IsPatternExpressionSyntax original, IsPatternExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(IsPatternExpressionSyntax, IsPatternExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(IsPatternExpressionSyntax, IsPatternExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(IsPatternExpressionSyntax original, IsPatternExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="IsPatternExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(IsPatternExpressionSyntax, IsPatternExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(IsPatternExpressionSyntax original, IsPatternExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.IsKeyword,
    		    Modified = modified.IsKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(IsPatternExpressionSyntax original, IsPatternExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ThrowExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ThrowExpressionSyntax, ThrowExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ThrowExpressionSyntax, ThrowExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ThrowExpressionSyntax, ThrowExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ThrowExpressionSyntax, ThrowExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ThrowExpressionSyntax original, ThrowExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ThrowExpressionSyntax, ThrowExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ThrowExpressionSyntax, ThrowExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ThrowExpressionSyntax original, ThrowExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ThrowExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ThrowExpressionSyntax, ThrowExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ThrowExpressionSyntax original, ThrowExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ThrowKeyword,
    		    Modified = modified.ThrowKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ThrowExpressionSyntax original, ThrowExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class PredefinedTypeServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(PredefinedTypeSyntax, PredefinedTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(PredefinedTypeSyntax, PredefinedTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(PredefinedTypeSyntax, PredefinedTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(PredefinedTypeSyntax, PredefinedTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(PredefinedTypeSyntax original, PredefinedTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(PredefinedTypeSyntax, PredefinedTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(PredefinedTypeSyntax, PredefinedTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(PredefinedTypeSyntax original, PredefinedTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="PredefinedTypeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(PredefinedTypeSyntax, PredefinedTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(PredefinedTypeSyntax original, PredefinedTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(PredefinedTypeSyntax original, PredefinedTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class PointerTypeServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(PointerTypeSyntax, PointerTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(PointerTypeSyntax, PointerTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(PointerTypeSyntax, PointerTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(PointerTypeSyntax, PointerTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(PointerTypeSyntax original, PointerTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(PointerTypeSyntax, PointerTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(PointerTypeSyntax, PointerTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(PointerTypeSyntax original, PointerTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="PointerTypeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(PointerTypeSyntax, PointerTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(PointerTypeSyntax original, PointerTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.AsteriskToken,
    		    Modified = modified.AsteriskToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(PointerTypeSyntax original, PointerTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class NullableTypeServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(NullableTypeSyntax, NullableTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(NullableTypeSyntax, NullableTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(NullableTypeSyntax, NullableTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(NullableTypeSyntax, NullableTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(NullableTypeSyntax original, NullableTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(NullableTypeSyntax, NullableTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(NullableTypeSyntax, NullableTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(NullableTypeSyntax original, NullableTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="NullableTypeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(NullableTypeSyntax, NullableTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(NullableTypeSyntax original, NullableTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.QuestionToken,
    		    Modified = modified.QuestionToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(NullableTypeSyntax original, NullableTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class TupleTypeServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(TupleTypeSyntax, TupleTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(TupleTypeSyntax, TupleTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(TupleTypeSyntax, TupleTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(TupleTypeSyntax, TupleTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(TupleTypeSyntax original, TupleTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(TupleTypeSyntax, TupleTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(TupleTypeSyntax, TupleTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(TupleTypeSyntax original, TupleTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TupleTypeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(TupleTypeSyntax, TupleTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(TupleTypeSyntax original, TupleTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(TupleTypeSyntax original, TupleTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class OmittedTypeArgumentServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(OmittedTypeArgumentSyntax original, OmittedTypeArgumentSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(OmittedTypeArgumentSyntax original, OmittedTypeArgumentSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="OmittedTypeArgumentSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(OmittedTypeArgumentSyntax original, OmittedTypeArgumentSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OmittedTypeArgumentToken,
    		    Modified = modified.OmittedTypeArgumentToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(OmittedTypeArgumentSyntax original, OmittedTypeArgumentSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class RefTypeServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(RefTypeSyntax, RefTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(RefTypeSyntax, RefTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(RefTypeSyntax, RefTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(RefTypeSyntax, RefTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(RefTypeSyntax original, RefTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(RefTypeSyntax, RefTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(RefTypeSyntax, RefTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(RefTypeSyntax original, RefTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="RefTypeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(RefTypeSyntax, RefTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(RefTypeSyntax original, RefTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.RefKeyword,
    		    Modified = modified.RefKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ReadOnlyKeyword,
    		    Modified = modified.ReadOnlyKeyword
    		};
    		if(original.ReadOnlyKeyword != null && modified.ReadOnlyKeyword != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.ReadOnlyKeyword != null)
    			matchingSet.Originals.DisableMatching(original.ReadOnlyKeyword);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.ReadOnlyKeyword);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(RefTypeSyntax original, RefTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class QualifiedNameServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(QualifiedNameSyntax, QualifiedNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(QualifiedNameSyntax, QualifiedNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(QualifiedNameSyntax, QualifiedNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(QualifiedNameSyntax, QualifiedNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(QualifiedNameSyntax original, QualifiedNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(QualifiedNameSyntax, QualifiedNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(QualifiedNameSyntax, QualifiedNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(QualifiedNameSyntax original, QualifiedNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="QualifiedNameSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(QualifiedNameSyntax, QualifiedNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(QualifiedNameSyntax original, QualifiedNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.DotToken,
    		    Modified = modified.DotToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(QualifiedNameSyntax original, QualifiedNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class AliasQualifiedNameServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(AliasQualifiedNameSyntax, AliasQualifiedNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(AliasQualifiedNameSyntax, AliasQualifiedNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(AliasQualifiedNameSyntax, AliasQualifiedNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(AliasQualifiedNameSyntax, AliasQualifiedNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(AliasQualifiedNameSyntax original, AliasQualifiedNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(AliasQualifiedNameSyntax, AliasQualifiedNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(AliasQualifiedNameSyntax, AliasQualifiedNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(AliasQualifiedNameSyntax original, AliasQualifiedNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AliasQualifiedNameSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(AliasQualifiedNameSyntax, AliasQualifiedNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(AliasQualifiedNameSyntax original, AliasQualifiedNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonColonToken,
    		    Modified = modified.ColonColonToken
    		};
    		if(original.ColonColonToken != null && modified.ColonColonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.ColonColonToken != null)
    			matchingSet.Originals.DisableMatching(original.ColonColonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.ColonColonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(AliasQualifiedNameSyntax original, AliasQualifiedNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class IdentifierNameServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(IdentifierNameSyntax, IdentifierNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(IdentifierNameSyntax, IdentifierNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(IdentifierNameSyntax, IdentifierNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(IdentifierNameSyntax, IdentifierNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(IdentifierNameSyntax original, IdentifierNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(IdentifierNameSyntax, IdentifierNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(IdentifierNameSyntax, IdentifierNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(IdentifierNameSyntax original, IdentifierNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="IdentifierNameSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(IdentifierNameSyntax, IdentifierNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(IdentifierNameSyntax original, IdentifierNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(IdentifierNameSyntax original, IdentifierNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class GenericNameServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(GenericNameSyntax, GenericNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(GenericNameSyntax, GenericNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(GenericNameSyntax, GenericNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(GenericNameSyntax, GenericNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(GenericNameSyntax original, GenericNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(GenericNameSyntax, GenericNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(GenericNameSyntax, GenericNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(GenericNameSyntax original, GenericNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="GenericNameSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(GenericNameSyntax, GenericNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(GenericNameSyntax original, GenericNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(GenericNameSyntax original, GenericNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ThisExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ThisExpressionSyntax, ThisExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ThisExpressionSyntax, ThisExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ThisExpressionSyntax, ThisExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ThisExpressionSyntax, ThisExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ThisExpressionSyntax original, ThisExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ThisExpressionSyntax, ThisExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ThisExpressionSyntax, ThisExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ThisExpressionSyntax original, ThisExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ThisExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ThisExpressionSyntax, ThisExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ThisExpressionSyntax original, ThisExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Token,
    		    Modified = modified.Token
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ThisExpressionSyntax original, ThisExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class BaseExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(BaseExpressionSyntax, BaseExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(BaseExpressionSyntax, BaseExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(BaseExpressionSyntax, BaseExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(BaseExpressionSyntax, BaseExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(BaseExpressionSyntax original, BaseExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(BaseExpressionSyntax, BaseExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(BaseExpressionSyntax, BaseExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(BaseExpressionSyntax original, BaseExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BaseExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(BaseExpressionSyntax, BaseExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(BaseExpressionSyntax original, BaseExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Token,
    		    Modified = modified.Token
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(BaseExpressionSyntax original, BaseExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class AnonymousMethodExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(AnonymousMethodExpressionSyntax original, AnonymousMethodExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(AnonymousMethodExpressionSyntax original, AnonymousMethodExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AnonymousMethodExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(AnonymousMethodExpressionSyntax original, AnonymousMethodExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.AsyncKeyword,
    		    Modified = modified.AsyncKeyword
    		};
    		if(original.AsyncKeyword != null && modified.AsyncKeyword != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.AsyncKeyword != null)
    			matchingSet.Originals.DisableMatching(original.AsyncKeyword);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.AsyncKeyword);
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.DelegateKeyword,
    		    Modified = modified.DelegateKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(AnonymousMethodExpressionSyntax original, AnonymousMethodExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class SimpleLambdaExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(SimpleLambdaExpressionSyntax original, SimpleLambdaExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(SimpleLambdaExpressionSyntax original, SimpleLambdaExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="SimpleLambdaExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(SimpleLambdaExpressionSyntax original, SimpleLambdaExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.AsyncKeyword,
    		    Modified = modified.AsyncKeyword
    		};
    		if(original.AsyncKeyword != null && modified.AsyncKeyword != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.AsyncKeyword != null)
    			matchingSet.Originals.DisableMatching(original.AsyncKeyword);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.AsyncKeyword);
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ArrowToken,
    		    Modified = modified.ArrowToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(SimpleLambdaExpressionSyntax original, SimpleLambdaExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ParenthesizedLambdaExpressionServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ParenthesizedLambdaExpressionSyntax original, ParenthesizedLambdaExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ParenthesizedLambdaExpressionSyntax original, ParenthesizedLambdaExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ParenthesizedLambdaExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ParenthesizedLambdaExpressionSyntax original, ParenthesizedLambdaExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.AsyncKeyword,
    		    Modified = modified.AsyncKeyword
    		};
    		if(original.AsyncKeyword != null && modified.AsyncKeyword != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.AsyncKeyword != null)
    			matchingSet.Originals.DisableMatching(original.AsyncKeyword);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.AsyncKeyword);
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ArrowToken,
    		    Modified = modified.ArrowToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ParenthesizedLambdaExpressionSyntax original, ParenthesizedLambdaExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ArgumentListServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ArgumentListSyntax, ArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ArgumentListSyntax, ArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ArgumentListSyntax, ArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ArgumentListSyntax, ArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ArgumentListSyntax original, ArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ArgumentListSyntax, ArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ArgumentListSyntax, ArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ArgumentListSyntax original, ArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ArgumentListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ArgumentListSyntax, ArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ArgumentListSyntax original, ArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ArgumentListSyntax original, ArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class BracketedArgumentListServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(BracketedArgumentListSyntax, BracketedArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(BracketedArgumentListSyntax, BracketedArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(BracketedArgumentListSyntax, BracketedArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(BracketedArgumentListSyntax, BracketedArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(BracketedArgumentListSyntax original, BracketedArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(BracketedArgumentListSyntax, BracketedArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(BracketedArgumentListSyntax, BracketedArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(BracketedArgumentListSyntax original, BracketedArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BracketedArgumentListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(BracketedArgumentListSyntax, BracketedArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(BracketedArgumentListSyntax original, BracketedArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBracketToken,
    		    Modified = modified.OpenBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBracketToken,
    		    Modified = modified.CloseBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(BracketedArgumentListSyntax original, BracketedArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class FromClauseServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(FromClauseSyntax, FromClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(FromClauseSyntax, FromClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(FromClauseSyntax, FromClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(FromClauseSyntax, FromClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(FromClauseSyntax original, FromClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(FromClauseSyntax, FromClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(FromClauseSyntax, FromClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(FromClauseSyntax original, FromClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="FromClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(FromClauseSyntax, FromClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(FromClauseSyntax original, FromClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.FromKeyword,
    		    Modified = modified.FromKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.InKeyword,
    		    Modified = modified.InKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(FromClauseSyntax original, FromClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class LetClauseServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(LetClauseSyntax, LetClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(LetClauseSyntax, LetClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(LetClauseSyntax, LetClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(LetClauseSyntax, LetClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(LetClauseSyntax original, LetClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(LetClauseSyntax, LetClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(LetClauseSyntax, LetClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(LetClauseSyntax original, LetClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LetClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(LetClauseSyntax, LetClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(LetClauseSyntax original, LetClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LetKeyword,
    		    Modified = modified.LetKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EqualsToken,
    		    Modified = modified.EqualsToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(LetClauseSyntax original, LetClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class JoinClauseServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(JoinClauseSyntax, JoinClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(JoinClauseSyntax, JoinClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(JoinClauseSyntax, JoinClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(JoinClauseSyntax, JoinClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(JoinClauseSyntax original, JoinClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(JoinClauseSyntax, JoinClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(JoinClauseSyntax, JoinClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(JoinClauseSyntax original, JoinClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="JoinClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(JoinClauseSyntax, JoinClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(JoinClauseSyntax original, JoinClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.JoinKeyword,
    		    Modified = modified.JoinKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.InKeyword,
    		    Modified = modified.InKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OnKeyword,
    		    Modified = modified.OnKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EqualsKeyword,
    		    Modified = modified.EqualsKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(JoinClauseSyntax original, JoinClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class WhereClauseServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(WhereClauseSyntax, WhereClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(WhereClauseSyntax, WhereClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(WhereClauseSyntax, WhereClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(WhereClauseSyntax, WhereClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(WhereClauseSyntax original, WhereClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(WhereClauseSyntax, WhereClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(WhereClauseSyntax, WhereClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(WhereClauseSyntax original, WhereClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="WhereClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(WhereClauseSyntax, WhereClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(WhereClauseSyntax original, WhereClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.WhereKeyword,
    		    Modified = modified.WhereKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(WhereClauseSyntax original, WhereClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class OrderByClauseServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(OrderByClauseSyntax, OrderByClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(OrderByClauseSyntax, OrderByClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(OrderByClauseSyntax, OrderByClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(OrderByClauseSyntax, OrderByClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(OrderByClauseSyntax original, OrderByClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(OrderByClauseSyntax, OrderByClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(OrderByClauseSyntax, OrderByClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(OrderByClauseSyntax original, OrderByClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="OrderByClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(OrderByClauseSyntax, OrderByClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(OrderByClauseSyntax original, OrderByClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OrderByKeyword,
    		    Modified = modified.OrderByKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(OrderByClauseSyntax original, OrderByClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class SelectClauseServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(SelectClauseSyntax, SelectClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(SelectClauseSyntax, SelectClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(SelectClauseSyntax, SelectClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(SelectClauseSyntax, SelectClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(SelectClauseSyntax original, SelectClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(SelectClauseSyntax, SelectClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(SelectClauseSyntax, SelectClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(SelectClauseSyntax original, SelectClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="SelectClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(SelectClauseSyntax, SelectClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(SelectClauseSyntax original, SelectClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SelectKeyword,
    		    Modified = modified.SelectKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(SelectClauseSyntax original, SelectClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class GroupClauseServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(GroupClauseSyntax, GroupClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(GroupClauseSyntax, GroupClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(GroupClauseSyntax, GroupClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(GroupClauseSyntax, GroupClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(GroupClauseSyntax original, GroupClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(GroupClauseSyntax, GroupClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(GroupClauseSyntax, GroupClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(GroupClauseSyntax original, GroupClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="GroupClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(GroupClauseSyntax, GroupClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(GroupClauseSyntax original, GroupClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.GroupKeyword,
    		    Modified = modified.GroupKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ByKeyword,
    		    Modified = modified.ByKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(GroupClauseSyntax original, GroupClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class InterpolatedStringTextServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(InterpolatedStringTextSyntax, InterpolatedStringTextSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(InterpolatedStringTextSyntax, InterpolatedStringTextSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(InterpolatedStringTextSyntax, InterpolatedStringTextSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(InterpolatedStringTextSyntax, InterpolatedStringTextSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(InterpolatedStringTextSyntax original, InterpolatedStringTextSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(InterpolatedStringTextSyntax, InterpolatedStringTextSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(InterpolatedStringTextSyntax, InterpolatedStringTextSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(InterpolatedStringTextSyntax original, InterpolatedStringTextSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="InterpolatedStringTextSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(InterpolatedStringTextSyntax, InterpolatedStringTextSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(InterpolatedStringTextSyntax original, InterpolatedStringTextSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.TextToken,
    		    Modified = modified.TextToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(InterpolatedStringTextSyntax original, InterpolatedStringTextSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class InterpolationServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(InterpolationSyntax, InterpolationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(InterpolationSyntax, InterpolationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(InterpolationSyntax, InterpolationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(InterpolationSyntax, InterpolationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(InterpolationSyntax original, InterpolationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(InterpolationSyntax, InterpolationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(InterpolationSyntax, InterpolationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(InterpolationSyntax original, InterpolationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="InterpolationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(InterpolationSyntax, InterpolationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(InterpolationSyntax original, InterpolationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(InterpolationSyntax original, InterpolationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class BlockServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(BlockSyntax, BlockSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(BlockSyntax, BlockSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(BlockSyntax, BlockSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(BlockSyntax, BlockSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(BlockSyntax original, BlockSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(BlockSyntax, BlockSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(BlockSyntax, BlockSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(BlockSyntax original, BlockSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BlockSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(BlockSyntax, BlockSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(BlockSyntax original, BlockSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(BlockSyntax original, BlockSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class LocalFunctionStatementServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(LocalFunctionStatementSyntax, LocalFunctionStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(LocalFunctionStatementSyntax, LocalFunctionStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(LocalFunctionStatementSyntax, LocalFunctionStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(LocalFunctionStatementSyntax, LocalFunctionStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(LocalFunctionStatementSyntax original, LocalFunctionStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(LocalFunctionStatementSyntax, LocalFunctionStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(LocalFunctionStatementSyntax, LocalFunctionStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(LocalFunctionStatementSyntax original, LocalFunctionStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LocalFunctionStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(LocalFunctionStatementSyntax, LocalFunctionStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(LocalFunctionStatementSyntax original, LocalFunctionStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && modified.SemicolonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.SemicolonToken != null)
    			matchingSet.Originals.DisableMatching(original.SemicolonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(LocalFunctionStatementSyntax original, LocalFunctionStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class LocalDeclarationStatementServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(LocalDeclarationStatementSyntax original, LocalDeclarationStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(LocalDeclarationStatementSyntax original, LocalDeclarationStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LocalDeclarationStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(LocalDeclarationStatementSyntax original, LocalDeclarationStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(LocalDeclarationStatementSyntax original, LocalDeclarationStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ExpressionStatementServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ExpressionStatementSyntax, ExpressionStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ExpressionStatementSyntax, ExpressionStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ExpressionStatementSyntax, ExpressionStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ExpressionStatementSyntax, ExpressionStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ExpressionStatementSyntax original, ExpressionStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ExpressionStatementSyntax, ExpressionStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ExpressionStatementSyntax, ExpressionStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ExpressionStatementSyntax original, ExpressionStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ExpressionStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ExpressionStatementSyntax, ExpressionStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ExpressionStatementSyntax original, ExpressionStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ExpressionStatementSyntax original, ExpressionStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class EmptyStatementServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(EmptyStatementSyntax, EmptyStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(EmptyStatementSyntax, EmptyStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(EmptyStatementSyntax, EmptyStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(EmptyStatementSyntax, EmptyStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(EmptyStatementSyntax original, EmptyStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(EmptyStatementSyntax, EmptyStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(EmptyStatementSyntax, EmptyStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(EmptyStatementSyntax original, EmptyStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EmptyStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(EmptyStatementSyntax, EmptyStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(EmptyStatementSyntax original, EmptyStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(EmptyStatementSyntax original, EmptyStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class LabeledStatementServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(LabeledStatementSyntax, LabeledStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(LabeledStatementSyntax, LabeledStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(LabeledStatementSyntax, LabeledStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(LabeledStatementSyntax, LabeledStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(LabeledStatementSyntax original, LabeledStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(LabeledStatementSyntax, LabeledStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(LabeledStatementSyntax, LabeledStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(LabeledStatementSyntax original, LabeledStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LabeledStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(LabeledStatementSyntax, LabeledStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(LabeledStatementSyntax original, LabeledStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(LabeledStatementSyntax original, LabeledStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class GotoStatementServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(GotoStatementSyntax, GotoStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(GotoStatementSyntax, GotoStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(GotoStatementSyntax, GotoStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(GotoStatementSyntax, GotoStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(GotoStatementSyntax original, GotoStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(GotoStatementSyntax, GotoStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(GotoStatementSyntax, GotoStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(GotoStatementSyntax original, GotoStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="GotoStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(GotoStatementSyntax, GotoStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(GotoStatementSyntax original, GotoStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.GotoKeyword,
    		    Modified = modified.GotoKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CaseOrDefaultKeyword,
    		    Modified = modified.CaseOrDefaultKeyword
    		};
    		if(original.CaseOrDefaultKeyword != null && modified.CaseOrDefaultKeyword != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.CaseOrDefaultKeyword != null)
    			matchingSet.Originals.DisableMatching(original.CaseOrDefaultKeyword);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.CaseOrDefaultKeyword);
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(GotoStatementSyntax original, GotoStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class BreakStatementServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(BreakStatementSyntax, BreakStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(BreakStatementSyntax, BreakStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(BreakStatementSyntax, BreakStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(BreakStatementSyntax, BreakStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(BreakStatementSyntax original, BreakStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(BreakStatementSyntax, BreakStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(BreakStatementSyntax, BreakStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(BreakStatementSyntax original, BreakStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BreakStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(BreakStatementSyntax, BreakStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(BreakStatementSyntax original, BreakStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.BreakKeyword,
    		    Modified = modified.BreakKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(BreakStatementSyntax original, BreakStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ContinueStatementServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ContinueStatementSyntax, ContinueStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ContinueStatementSyntax, ContinueStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ContinueStatementSyntax, ContinueStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ContinueStatementSyntax, ContinueStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ContinueStatementSyntax original, ContinueStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ContinueStatementSyntax, ContinueStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ContinueStatementSyntax, ContinueStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ContinueStatementSyntax original, ContinueStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ContinueStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ContinueStatementSyntax, ContinueStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ContinueStatementSyntax original, ContinueStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ContinueKeyword,
    		    Modified = modified.ContinueKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ContinueStatementSyntax original, ContinueStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ReturnStatementServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ReturnStatementSyntax, ReturnStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ReturnStatementSyntax, ReturnStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ReturnStatementSyntax, ReturnStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ReturnStatementSyntax, ReturnStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ReturnStatementSyntax original, ReturnStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ReturnStatementSyntax, ReturnStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ReturnStatementSyntax, ReturnStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ReturnStatementSyntax original, ReturnStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ReturnStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ReturnStatementSyntax, ReturnStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ReturnStatementSyntax original, ReturnStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ReturnKeyword,
    		    Modified = modified.ReturnKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ReturnStatementSyntax original, ReturnStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ThrowStatementServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ThrowStatementSyntax, ThrowStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ThrowStatementSyntax, ThrowStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ThrowStatementSyntax, ThrowStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ThrowStatementSyntax, ThrowStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ThrowStatementSyntax original, ThrowStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ThrowStatementSyntax, ThrowStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ThrowStatementSyntax, ThrowStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ThrowStatementSyntax original, ThrowStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ThrowStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ThrowStatementSyntax, ThrowStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ThrowStatementSyntax original, ThrowStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ThrowKeyword,
    		    Modified = modified.ThrowKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ThrowStatementSyntax original, ThrowStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class YieldStatementServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(YieldStatementSyntax, YieldStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(YieldStatementSyntax, YieldStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(YieldStatementSyntax, YieldStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(YieldStatementSyntax, YieldStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(YieldStatementSyntax original, YieldStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(YieldStatementSyntax, YieldStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(YieldStatementSyntax, YieldStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(YieldStatementSyntax original, YieldStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="YieldStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(YieldStatementSyntax, YieldStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(YieldStatementSyntax original, YieldStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.YieldKeyword,
    		    Modified = modified.YieldKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ReturnOrBreakKeyword,
    		    Modified = modified.ReturnOrBreakKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(YieldStatementSyntax original, YieldStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class WhileStatementServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(WhileStatementSyntax, WhileStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(WhileStatementSyntax, WhileStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(WhileStatementSyntax, WhileStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(WhileStatementSyntax, WhileStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(WhileStatementSyntax original, WhileStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(WhileStatementSyntax, WhileStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(WhileStatementSyntax, WhileStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(WhileStatementSyntax original, WhileStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="WhileStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(WhileStatementSyntax, WhileStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(WhileStatementSyntax original, WhileStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.WhileKeyword,
    		    Modified = modified.WhileKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(WhileStatementSyntax original, WhileStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class DoStatementServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(DoStatementSyntax, DoStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(DoStatementSyntax, DoStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(DoStatementSyntax, DoStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(DoStatementSyntax, DoStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(DoStatementSyntax original, DoStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(DoStatementSyntax, DoStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(DoStatementSyntax, DoStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(DoStatementSyntax original, DoStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DoStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(DoStatementSyntax, DoStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(DoStatementSyntax original, DoStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.DoKeyword,
    		    Modified = modified.DoKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.WhileKeyword,
    		    Modified = modified.WhileKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(DoStatementSyntax original, DoStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ForStatementServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ForStatementSyntax, ForStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ForStatementSyntax, ForStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ForStatementSyntax, ForStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ForStatementSyntax, ForStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ForStatementSyntax original, ForStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ForStatementSyntax, ForStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ForStatementSyntax, ForStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ForStatementSyntax original, ForStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ForStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ForStatementSyntax, ForStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ForStatementSyntax original, ForStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ForKeyword,
    		    Modified = modified.ForKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.FirstSemicolonToken,
    		    Modified = modified.FirstSemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SecondSemicolonToken,
    		    Modified = modified.SecondSemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ForStatementSyntax original, ForStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class UsingStatementServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(UsingStatementSyntax, UsingStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(UsingStatementSyntax, UsingStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(UsingStatementSyntax, UsingStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(UsingStatementSyntax, UsingStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(UsingStatementSyntax original, UsingStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(UsingStatementSyntax, UsingStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(UsingStatementSyntax, UsingStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(UsingStatementSyntax original, UsingStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="UsingStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(UsingStatementSyntax, UsingStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(UsingStatementSyntax original, UsingStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.UsingKeyword,
    		    Modified = modified.UsingKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(UsingStatementSyntax original, UsingStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class FixedStatementServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(FixedStatementSyntax, FixedStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(FixedStatementSyntax, FixedStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(FixedStatementSyntax, FixedStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(FixedStatementSyntax, FixedStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(FixedStatementSyntax original, FixedStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(FixedStatementSyntax, FixedStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(FixedStatementSyntax, FixedStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(FixedStatementSyntax original, FixedStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="FixedStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(FixedStatementSyntax, FixedStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(FixedStatementSyntax original, FixedStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.FixedKeyword,
    		    Modified = modified.FixedKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(FixedStatementSyntax original, FixedStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class CheckedStatementServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(CheckedStatementSyntax, CheckedStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(CheckedStatementSyntax, CheckedStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(CheckedStatementSyntax, CheckedStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(CheckedStatementSyntax, CheckedStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(CheckedStatementSyntax original, CheckedStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(CheckedStatementSyntax, CheckedStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(CheckedStatementSyntax, CheckedStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(CheckedStatementSyntax original, CheckedStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CheckedStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(CheckedStatementSyntax, CheckedStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(CheckedStatementSyntax original, CheckedStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(CheckedStatementSyntax original, CheckedStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class UnsafeStatementServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(UnsafeStatementSyntax, UnsafeStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(UnsafeStatementSyntax, UnsafeStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(UnsafeStatementSyntax, UnsafeStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(UnsafeStatementSyntax, UnsafeStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(UnsafeStatementSyntax original, UnsafeStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(UnsafeStatementSyntax, UnsafeStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(UnsafeStatementSyntax, UnsafeStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(UnsafeStatementSyntax original, UnsafeStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="UnsafeStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(UnsafeStatementSyntax, UnsafeStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(UnsafeStatementSyntax original, UnsafeStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.UnsafeKeyword,
    		    Modified = modified.UnsafeKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(UnsafeStatementSyntax original, UnsafeStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class LockStatementServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(LockStatementSyntax, LockStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(LockStatementSyntax, LockStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(LockStatementSyntax, LockStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(LockStatementSyntax, LockStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(LockStatementSyntax original, LockStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(LockStatementSyntax, LockStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(LockStatementSyntax, LockStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(LockStatementSyntax original, LockStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LockStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(LockStatementSyntax, LockStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(LockStatementSyntax original, LockStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LockKeyword,
    		    Modified = modified.LockKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(LockStatementSyntax original, LockStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class IfStatementServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(IfStatementSyntax, IfStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(IfStatementSyntax, IfStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(IfStatementSyntax, IfStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(IfStatementSyntax, IfStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(IfStatementSyntax original, IfStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(IfStatementSyntax, IfStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(IfStatementSyntax, IfStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(IfStatementSyntax original, IfStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="IfStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(IfStatementSyntax, IfStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(IfStatementSyntax original, IfStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.IfKeyword,
    		    Modified = modified.IfKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(IfStatementSyntax original, IfStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class SwitchStatementServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(SwitchStatementSyntax, SwitchStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(SwitchStatementSyntax, SwitchStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(SwitchStatementSyntax, SwitchStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(SwitchStatementSyntax, SwitchStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(SwitchStatementSyntax original, SwitchStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(SwitchStatementSyntax, SwitchStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(SwitchStatementSyntax, SwitchStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(SwitchStatementSyntax original, SwitchStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="SwitchStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(SwitchStatementSyntax, SwitchStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(SwitchStatementSyntax original, SwitchStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SwitchKeyword,
    		    Modified = modified.SwitchKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(SwitchStatementSyntax original, SwitchStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class TryStatementServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(TryStatementSyntax, TryStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(TryStatementSyntax, TryStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(TryStatementSyntax, TryStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(TryStatementSyntax, TryStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(TryStatementSyntax original, TryStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(TryStatementSyntax, TryStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(TryStatementSyntax, TryStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(TryStatementSyntax original, TryStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TryStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(TryStatementSyntax, TryStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(TryStatementSyntax original, TryStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.TryKeyword,
    		    Modified = modified.TryKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(TryStatementSyntax original, TryStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ForEachStatementServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ForEachStatementSyntax, ForEachStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ForEachStatementSyntax, ForEachStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ForEachStatementSyntax, ForEachStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ForEachStatementSyntax, ForEachStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ForEachStatementSyntax original, ForEachStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ForEachStatementSyntax, ForEachStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ForEachStatementSyntax, ForEachStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ForEachStatementSyntax original, ForEachStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ForEachStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ForEachStatementSyntax, ForEachStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ForEachStatementSyntax original, ForEachStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ForEachKeyword,
    		    Modified = modified.ForEachKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.InKeyword,
    		    Modified = modified.InKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ForEachStatementSyntax original, ForEachStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ForEachVariableStatementServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ForEachVariableStatementSyntax, ForEachVariableStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ForEachVariableStatementSyntax, ForEachVariableStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ForEachVariableStatementSyntax, ForEachVariableStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ForEachVariableStatementSyntax, ForEachVariableStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ForEachVariableStatementSyntax original, ForEachVariableStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ForEachVariableStatementSyntax, ForEachVariableStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ForEachVariableStatementSyntax, ForEachVariableStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ForEachVariableStatementSyntax original, ForEachVariableStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ForEachVariableStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ForEachVariableStatementSyntax, ForEachVariableStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ForEachVariableStatementSyntax original, ForEachVariableStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ForEachKeyword,
    		    Modified = modified.ForEachKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.InKeyword,
    		    Modified = modified.InKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ForEachVariableStatementSyntax original, ForEachVariableStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class SingleVariableDesignationServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(SingleVariableDesignationSyntax, SingleVariableDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(SingleVariableDesignationSyntax, SingleVariableDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(SingleVariableDesignationSyntax, SingleVariableDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(SingleVariableDesignationSyntax, SingleVariableDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(SingleVariableDesignationSyntax original, SingleVariableDesignationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(SingleVariableDesignationSyntax, SingleVariableDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(SingleVariableDesignationSyntax, SingleVariableDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(SingleVariableDesignationSyntax original, SingleVariableDesignationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="SingleVariableDesignationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(SingleVariableDesignationSyntax, SingleVariableDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(SingleVariableDesignationSyntax original, SingleVariableDesignationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(SingleVariableDesignationSyntax original, SingleVariableDesignationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class DiscardDesignationServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(DiscardDesignationSyntax, DiscardDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(DiscardDesignationSyntax, DiscardDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(DiscardDesignationSyntax, DiscardDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(DiscardDesignationSyntax, DiscardDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(DiscardDesignationSyntax original, DiscardDesignationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(DiscardDesignationSyntax, DiscardDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(DiscardDesignationSyntax, DiscardDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(DiscardDesignationSyntax original, DiscardDesignationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DiscardDesignationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(DiscardDesignationSyntax, DiscardDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(DiscardDesignationSyntax original, DiscardDesignationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.UnderscoreToken,
    		    Modified = modified.UnderscoreToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(DiscardDesignationSyntax original, DiscardDesignationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ParenthesizedVariableDesignationServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(ParenthesizedVariableDesignationSyntax original, ParenthesizedVariableDesignationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(ParenthesizedVariableDesignationSyntax original, ParenthesizedVariableDesignationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ParenthesizedVariableDesignationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(ParenthesizedVariableDesignationSyntax original, ParenthesizedVariableDesignationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(ParenthesizedVariableDesignationSyntax original, ParenthesizedVariableDesignationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class CasePatternSwitchLabelServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(CasePatternSwitchLabelSyntax original, CasePatternSwitchLabelSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(CasePatternSwitchLabelSyntax original, CasePatternSwitchLabelSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CasePatternSwitchLabelSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(CasePatternSwitchLabelSyntax original, CasePatternSwitchLabelSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(CasePatternSwitchLabelSyntax original, CasePatternSwitchLabelSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class CaseSwitchLabelServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(CaseSwitchLabelSyntax, CaseSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(CaseSwitchLabelSyntax, CaseSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(CaseSwitchLabelSyntax, CaseSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(CaseSwitchLabelSyntax, CaseSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(CaseSwitchLabelSyntax original, CaseSwitchLabelSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(CaseSwitchLabelSyntax, CaseSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(CaseSwitchLabelSyntax, CaseSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(CaseSwitchLabelSyntax original, CaseSwitchLabelSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CaseSwitchLabelSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(CaseSwitchLabelSyntax, CaseSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(CaseSwitchLabelSyntax original, CaseSwitchLabelSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(CaseSwitchLabelSyntax original, CaseSwitchLabelSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class DefaultSwitchLabelServiceProvider
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="PairwisePartners(DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PairwisePartnersCore(DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="PairwisePartners(DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PairwisePartnersBefore(DefaultSwitchLabelSyntax original, DefaultSwitchLabelSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PairwisePartnersCore(DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="PairwisePartners(DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PairwisePartnersAfter(DefaultSwitchLabelSyntax original, DefaultSwitchLabelSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DefaultSwitchLabelSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="PairwisePartners(DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartnersCore(DefaultSwitchLabelSyntax original, DefaultSwitchLabelSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PairwisePartners(DefaultSwitchLabelSyntax original, DefaultSwitchLabelSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PairwisePartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PairwisePartnersCore(original, modified, context);
    		PairwisePartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
}
// Generated helper templates
// Generated items
