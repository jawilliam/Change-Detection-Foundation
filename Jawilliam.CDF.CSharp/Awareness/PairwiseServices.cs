
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;
using Jawilliam.CDF.Approach.Flad;
using Jawilliam.CDF.Approach.Awareness;
using Jawilliam.CDF.Approach;
using Jawilliam.CDF.Approach.Services;
using Jawilliam.CDF.Approach.Criterions;

namespace Jawilliam.CDF.CSharp.Awareness
{
    partial class LanguageServiceProvider
    {
    	/// <summary>
        /// Handles the occurrence of two given versions that have been definitively matched.
        /// </summary>
        /// <param name="sender">The approach within which the event was generated.</param>
        /// <param name="matchInfo">The definitive match.</param>
        /// <remarks>This is the default implementation for <see cref="PartnersEventHandler(IApproach{SyntaxNodeOrToken?}, MatchInfo{SyntaxNodeOrToken?})"/>.</remarks>
        public virtual void PartnersEventHandler(MatchingContext<SyntaxNodeOrToken?> context, MatchInfo<SyntaxNodeOrToken?> matchInfo)
    	{
    		if (matchInfo.Original == null || matchInfo.Modified == null)
    			throw new ArgumentNullException("Original and Modified are expected to be non-null");
    
        	if (this.GetElementTypeServiceProvider(matchInfo.Original.Value.Kind()) is IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?> elementTypeServiceProvider)
        	{
        	   var matchingSet = context.Approach.MatchingSet();
               foreach (var pairwiseMatch in elementTypeServiceProvider.Partners(context, matchInfo.Original, matchInfo.Modified))
               {
                    matchingSet.PartnersIfAvailable(pairwiseMatch);
               }
        	}
    	}  
    }
    
    partial class NameEqualsServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, NameEqualsSyntax, NameEqualsSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NameEqualsSyntax, NameEqualsSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NameEqualsSyntax, NameEqualsSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, NameEqualsSyntax, NameEqualsSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NameEqualsSyntax, NameEqualsSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, NameEqualsSyntax original, NameEqualsSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, NameEqualsSyntax, NameEqualsSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NameEqualsSyntax, NameEqualsSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, NameEqualsSyntax original, NameEqualsSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="NameEqualsSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NameEqualsSyntax, NameEqualsSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, NameEqualsSyntax original, NameEqualsSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EqualsToken,
    		    Modified = modified.EqualsToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, NameEqualsSyntax original, NameEqualsSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NameEqualsSyntax, NameEqualsSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NameEqualsSyntax, NameEqualsSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, NameEqualsSyntax, NameEqualsSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NameEqualsSyntax, NameEqualsSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, NameEqualsSyntax, NameEqualsSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NameEqualsSyntax, NameEqualsSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="NameEqualsSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NameEqualsSyntax, NameEqualsSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as NameEqualsSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as NameEqualsSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class TypeParameterListServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, TypeParameterListSyntax, TypeParameterListSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterListSyntax, TypeParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterListSyntax, TypeParameterListSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TypeParameterListSyntax, TypeParameterListSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterListSyntax, TypeParameterListSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, TypeParameterListSyntax original, TypeParameterListSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TypeParameterListSyntax, TypeParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterListSyntax, TypeParameterListSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, TypeParameterListSyntax original, TypeParameterListSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TypeParameterListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterListSyntax, TypeParameterListSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, TypeParameterListSyntax original, TypeParameterListSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LessThanToken,
    		    Modified = modified.LessThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.GreaterThanToken,
    		    Modified = modified.GreaterThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, TypeParameterListSyntax original, TypeParameterListSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterListSyntax, TypeParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterListSyntax, TypeParameterListSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TypeParameterListSyntax, TypeParameterListSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterListSyntax, TypeParameterListSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TypeParameterListSyntax, TypeParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterListSyntax, TypeParameterListSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TypeParameterListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterListSyntax, TypeParameterListSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as TypeParameterListSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as TypeParameterListSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class TypeParameterServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, TypeParameterSyntax, TypeParameterSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterSyntax, TypeParameterSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterSyntax, TypeParameterSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TypeParameterSyntax, TypeParameterSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterSyntax, TypeParameterSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, TypeParameterSyntax original, TypeParameterSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TypeParameterSyntax, TypeParameterSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterSyntax, TypeParameterSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, TypeParameterSyntax original, TypeParameterSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TypeParameterSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterSyntax, TypeParameterSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, TypeParameterSyntax original, TypeParameterSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.VarianceKeyword,
    		    Modified = modified.VarianceKeyword
    		};
    		if(original.VarianceKeyword != null && original.VarianceKeyword.Kind() != SyntaxKind.None && 
    		   modified.VarianceKeyword != null && modified.VarianceKeyword.Kind() != SyntaxKind.None)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else
    		{
    			if(original.VarianceKeyword != null && original.VarianceKeyword.Kind() != SyntaxKind.None)
    				matchingSet.Originals.DisableMatching(original.VarianceKeyword);
    			
    			if(modified.VarianceKeyword != null && modified.VarianceKeyword.Kind() != SyntaxKind.None)
    				matchingSet.Modifieds.DisableMatching(modified.VarianceKeyword);
    		}
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, TypeParameterSyntax original, TypeParameterSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterSyntax, TypeParameterSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterSyntax, TypeParameterSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TypeParameterSyntax, TypeParameterSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterSyntax, TypeParameterSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TypeParameterSyntax, TypeParameterSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterSyntax, TypeParameterSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TypeParameterSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterSyntax, TypeParameterSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as TypeParameterSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as TypeParameterSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class BaseListServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, BaseListSyntax, BaseListSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BaseListSyntax, BaseListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BaseListSyntax, BaseListSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BaseListSyntax, BaseListSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BaseListSyntax, BaseListSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, BaseListSyntax original, BaseListSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BaseListSyntax, BaseListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BaseListSyntax, BaseListSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, BaseListSyntax original, BaseListSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BaseListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BaseListSyntax, BaseListSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, BaseListSyntax original, BaseListSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, BaseListSyntax original, BaseListSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BaseListSyntax, BaseListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BaseListSyntax, BaseListSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BaseListSyntax, BaseListSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BaseListSyntax, BaseListSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BaseListSyntax, BaseListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BaseListSyntax, BaseListSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BaseListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BaseListSyntax, BaseListSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as BaseListSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as BaseListSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class TypeParameterConstraintClauseServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, TypeParameterConstraintClauseSyntax original, TypeParameterConstraintClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, TypeParameterConstraintClauseSyntax original, TypeParameterConstraintClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TypeParameterConstraintClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, TypeParameterConstraintClauseSyntax original, TypeParameterConstraintClauseSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.WhereKeyword,
    		    Modified = modified.WhereKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, TypeParameterConstraintClauseSyntax original, TypeParameterConstraintClauseSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TypeParameterConstraintClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as TypeParameterConstraintClauseSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as TypeParameterConstraintClauseSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ExplicitInterfaceSpecifierServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ExplicitInterfaceSpecifierSyntax original, ExplicitInterfaceSpecifierSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ExplicitInterfaceSpecifierSyntax original, ExplicitInterfaceSpecifierSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ExplicitInterfaceSpecifierSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ExplicitInterfaceSpecifierSyntax original, ExplicitInterfaceSpecifierSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.DotToken,
    		    Modified = modified.DotToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ExplicitInterfaceSpecifierSyntax original, ExplicitInterfaceSpecifierSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ExplicitInterfaceSpecifierSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ExplicitInterfaceSpecifierSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ExplicitInterfaceSpecifierSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ConstructorInitializerServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ConstructorInitializerSyntax, ConstructorInitializerSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorInitializerSyntax, ConstructorInitializerSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorInitializerSyntax, ConstructorInitializerSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ConstructorInitializerSyntax, ConstructorInitializerSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorInitializerSyntax, ConstructorInitializerSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ConstructorInitializerSyntax original, ConstructorInitializerSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ConstructorInitializerSyntax, ConstructorInitializerSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorInitializerSyntax, ConstructorInitializerSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ConstructorInitializerSyntax original, ConstructorInitializerSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ConstructorInitializerSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorInitializerSyntax, ConstructorInitializerSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ConstructorInitializerSyntax original, ConstructorInitializerSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ThisOrBaseKeyword,
    		    Modified = modified.ThisOrBaseKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ConstructorInitializerSyntax original, ConstructorInitializerSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorInitializerSyntax, ConstructorInitializerSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorInitializerSyntax, ConstructorInitializerSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ConstructorInitializerSyntax, ConstructorInitializerSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorInitializerSyntax, ConstructorInitializerSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ConstructorInitializerSyntax, ConstructorInitializerSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorInitializerSyntax, ConstructorInitializerSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ConstructorInitializerSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorInitializerSyntax, ConstructorInitializerSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ConstructorInitializerSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ConstructorInitializerSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ArrowExpressionClauseServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ArrowExpressionClauseSyntax original, ArrowExpressionClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ArrowExpressionClauseSyntax original, ArrowExpressionClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ArrowExpressionClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ArrowExpressionClauseSyntax original, ArrowExpressionClauseSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ArrowToken,
    		    Modified = modified.ArrowToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ArrowExpressionClauseSyntax original, ArrowExpressionClauseSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ArrowExpressionClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ArrowExpressionClauseSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ArrowExpressionClauseSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class AccessorListServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, AccessorListSyntax, AccessorListSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AccessorListSyntax, AccessorListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AccessorListSyntax, AccessorListSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AccessorListSyntax, AccessorListSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AccessorListSyntax, AccessorListSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, AccessorListSyntax original, AccessorListSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AccessorListSyntax, AccessorListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AccessorListSyntax, AccessorListSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, AccessorListSyntax original, AccessorListSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AccessorListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AccessorListSyntax, AccessorListSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, AccessorListSyntax original, AccessorListSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, AccessorListSyntax original, AccessorListSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AccessorListSyntax, AccessorListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AccessorListSyntax, AccessorListSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AccessorListSyntax, AccessorListSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AccessorListSyntax, AccessorListSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AccessorListSyntax, AccessorListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AccessorListSyntax, AccessorListSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AccessorListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AccessorListSyntax, AccessorListSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as AccessorListSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as AccessorListSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class AccessorDeclarationServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, AccessorDeclarationSyntax, AccessorDeclarationSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AccessorDeclarationSyntax, AccessorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AccessorDeclarationSyntax, AccessorDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AccessorDeclarationSyntax, AccessorDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AccessorDeclarationSyntax, AccessorDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, AccessorDeclarationSyntax original, AccessorDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AccessorDeclarationSyntax, AccessorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AccessorDeclarationSyntax, AccessorDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, AccessorDeclarationSyntax original, AccessorDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AccessorDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AccessorDeclarationSyntax, AccessorDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, AccessorDeclarationSyntax original, AccessorDeclarationSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && original.SemicolonToken.Kind() != SyntaxKind.None && 
    		   modified.SemicolonToken != null && modified.SemicolonToken.Kind() != SyntaxKind.None)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else
    		{
    			if(original.SemicolonToken != null && original.SemicolonToken.Kind() != SyntaxKind.None)
    				matchingSet.Originals.DisableMatching(original.SemicolonToken);
    			
    			if(modified.SemicolonToken != null && modified.SemicolonToken.Kind() != SyntaxKind.None)
    				matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    		}
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, AccessorDeclarationSyntax original, AccessorDeclarationSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AccessorDeclarationSyntax, AccessorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AccessorDeclarationSyntax, AccessorDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AccessorDeclarationSyntax, AccessorDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AccessorDeclarationSyntax, AccessorDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AccessorDeclarationSyntax, AccessorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AccessorDeclarationSyntax, AccessorDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AccessorDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AccessorDeclarationSyntax, AccessorDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as AccessorDeclarationSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as AccessorDeclarationSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ParameterServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ParameterSyntax, ParameterSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParameterSyntax, ParameterSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParameterSyntax, ParameterSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ParameterSyntax, ParameterSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParameterSyntax, ParameterSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ParameterSyntax original, ParameterSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ParameterSyntax, ParameterSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParameterSyntax, ParameterSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ParameterSyntax original, ParameterSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ParameterSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParameterSyntax, ParameterSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ParameterSyntax original, ParameterSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ParameterSyntax original, ParameterSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParameterSyntax, ParameterSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParameterSyntax, ParameterSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ParameterSyntax, ParameterSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParameterSyntax, ParameterSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ParameterSyntax, ParameterSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParameterSyntax, ParameterSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ParameterSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParameterSyntax, ParameterSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ParameterSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ParameterSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class CrefParameterServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, CrefParameterSyntax, CrefParameterSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefParameterSyntax, CrefParameterSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefParameterSyntax, CrefParameterSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CrefParameterSyntax, CrefParameterSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefParameterSyntax, CrefParameterSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, CrefParameterSyntax original, CrefParameterSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CrefParameterSyntax, CrefParameterSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefParameterSyntax, CrefParameterSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, CrefParameterSyntax original, CrefParameterSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CrefParameterSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefParameterSyntax, CrefParameterSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, CrefParameterSyntax original, CrefParameterSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.RefKindKeyword,
    		    Modified = modified.RefKindKeyword
    		};
    		if(original.RefKindKeyword != null && original.RefKindKeyword.Kind() != SyntaxKind.None && 
    		   modified.RefKindKeyword != null && modified.RefKindKeyword.Kind() != SyntaxKind.None)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else
    		{
    			if(original.RefKindKeyword != null && original.RefKindKeyword.Kind() != SyntaxKind.None)
    				matchingSet.Originals.DisableMatching(original.RefKindKeyword);
    			
    			if(modified.RefKindKeyword != null && modified.RefKindKeyword.Kind() != SyntaxKind.None)
    				matchingSet.Modifieds.DisableMatching(modified.RefKindKeyword);
    		}
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, CrefParameterSyntax original, CrefParameterSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefParameterSyntax, CrefParameterSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefParameterSyntax, CrefParameterSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CrefParameterSyntax, CrefParameterSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefParameterSyntax, CrefParameterSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CrefParameterSyntax, CrefParameterSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefParameterSyntax, CrefParameterSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CrefParameterSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefParameterSyntax, CrefParameterSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as CrefParameterSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as CrefParameterSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class XmlElementStartTagServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, XmlElementStartTagSyntax, XmlElementStartTagSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementStartTagSyntax, XmlElementStartTagSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementStartTagSyntax, XmlElementStartTagSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlElementStartTagSyntax, XmlElementStartTagSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementStartTagSyntax, XmlElementStartTagSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, XmlElementStartTagSyntax original, XmlElementStartTagSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlElementStartTagSyntax, XmlElementStartTagSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementStartTagSyntax, XmlElementStartTagSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, XmlElementStartTagSyntax original, XmlElementStartTagSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlElementStartTagSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementStartTagSyntax, XmlElementStartTagSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, XmlElementStartTagSyntax original, XmlElementStartTagSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LessThanToken,
    		    Modified = modified.LessThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.GreaterThanToken,
    		    Modified = modified.GreaterThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, XmlElementStartTagSyntax original, XmlElementStartTagSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementStartTagSyntax, XmlElementStartTagSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementStartTagSyntax, XmlElementStartTagSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlElementStartTagSyntax, XmlElementStartTagSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementStartTagSyntax, XmlElementStartTagSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlElementStartTagSyntax, XmlElementStartTagSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementStartTagSyntax, XmlElementStartTagSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlElementStartTagSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementStartTagSyntax, XmlElementStartTagSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as XmlElementStartTagSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as XmlElementStartTagSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class XmlElementEndTagServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, XmlElementEndTagSyntax, XmlElementEndTagSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementEndTagSyntax, XmlElementEndTagSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementEndTagSyntax, XmlElementEndTagSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlElementEndTagSyntax, XmlElementEndTagSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementEndTagSyntax, XmlElementEndTagSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, XmlElementEndTagSyntax original, XmlElementEndTagSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlElementEndTagSyntax, XmlElementEndTagSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementEndTagSyntax, XmlElementEndTagSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, XmlElementEndTagSyntax original, XmlElementEndTagSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlElementEndTagSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementEndTagSyntax, XmlElementEndTagSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, XmlElementEndTagSyntax original, XmlElementEndTagSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LessThanSlashToken,
    		    Modified = modified.LessThanSlashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.GreaterThanToken,
    		    Modified = modified.GreaterThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, XmlElementEndTagSyntax original, XmlElementEndTagSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementEndTagSyntax, XmlElementEndTagSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementEndTagSyntax, XmlElementEndTagSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlElementEndTagSyntax, XmlElementEndTagSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementEndTagSyntax, XmlElementEndTagSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlElementEndTagSyntax, XmlElementEndTagSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementEndTagSyntax, XmlElementEndTagSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlElementEndTagSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementEndTagSyntax, XmlElementEndTagSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as XmlElementEndTagSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as XmlElementEndTagSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class XmlNameServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, XmlNameSyntax, XmlNameSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlNameSyntax, XmlNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlNameSyntax, XmlNameSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlNameSyntax, XmlNameSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlNameSyntax, XmlNameSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, XmlNameSyntax original, XmlNameSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlNameSyntax, XmlNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlNameSyntax, XmlNameSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, XmlNameSyntax original, XmlNameSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlNameSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlNameSyntax, XmlNameSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, XmlNameSyntax original, XmlNameSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LocalName,
    		    Modified = modified.LocalName
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, XmlNameSyntax original, XmlNameSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlNameSyntax, XmlNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlNameSyntax, XmlNameSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlNameSyntax, XmlNameSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlNameSyntax, XmlNameSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlNameSyntax, XmlNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlNameSyntax, XmlNameSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlNameSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlNameSyntax, XmlNameSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as XmlNameSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as XmlNameSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class XmlPrefixServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, XmlPrefixSyntax, XmlPrefixSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlPrefixSyntax, XmlPrefixSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlPrefixSyntax, XmlPrefixSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlPrefixSyntax, XmlPrefixSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlPrefixSyntax, XmlPrefixSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, XmlPrefixSyntax original, XmlPrefixSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlPrefixSyntax, XmlPrefixSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlPrefixSyntax, XmlPrefixSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, XmlPrefixSyntax original, XmlPrefixSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlPrefixSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlPrefixSyntax, XmlPrefixSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, XmlPrefixSyntax original, XmlPrefixSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Prefix,
    		    Modified = modified.Prefix
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, XmlPrefixSyntax original, XmlPrefixSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlPrefixSyntax, XmlPrefixSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlPrefixSyntax, XmlPrefixSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlPrefixSyntax, XmlPrefixSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlPrefixSyntax, XmlPrefixSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlPrefixSyntax, XmlPrefixSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlPrefixSyntax, XmlPrefixSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlPrefixSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlPrefixSyntax, XmlPrefixSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as XmlPrefixSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as XmlPrefixSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class TypeArgumentListServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, TypeArgumentListSyntax, TypeArgumentListSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeArgumentListSyntax, TypeArgumentListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeArgumentListSyntax, TypeArgumentListSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TypeArgumentListSyntax, TypeArgumentListSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeArgumentListSyntax, TypeArgumentListSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, TypeArgumentListSyntax original, TypeArgumentListSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TypeArgumentListSyntax, TypeArgumentListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeArgumentListSyntax, TypeArgumentListSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, TypeArgumentListSyntax original, TypeArgumentListSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TypeArgumentListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeArgumentListSyntax, TypeArgumentListSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, TypeArgumentListSyntax original, TypeArgumentListSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LessThanToken,
    		    Modified = modified.LessThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.GreaterThanToken,
    		    Modified = modified.GreaterThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, TypeArgumentListSyntax original, TypeArgumentListSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeArgumentListSyntax, TypeArgumentListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeArgumentListSyntax, TypeArgumentListSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TypeArgumentListSyntax, TypeArgumentListSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeArgumentListSyntax, TypeArgumentListSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TypeArgumentListSyntax, TypeArgumentListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeArgumentListSyntax, TypeArgumentListSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TypeArgumentListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeArgumentListSyntax, TypeArgumentListSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as TypeArgumentListSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as TypeArgumentListSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ArrayRankSpecifierServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ArrayRankSpecifierSyntax original, ArrayRankSpecifierSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ArrayRankSpecifierSyntax original, ArrayRankSpecifierSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ArrayRankSpecifierSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ArrayRankSpecifierSyntax original, ArrayRankSpecifierSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBracketToken,
    		    Modified = modified.OpenBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBracketToken,
    		    Modified = modified.CloseBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ArrayRankSpecifierSyntax original, ArrayRankSpecifierSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ArrayRankSpecifierSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ArrayRankSpecifierSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ArrayRankSpecifierSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class TupleElementServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, TupleElementSyntax, TupleElementSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleElementSyntax, TupleElementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleElementSyntax, TupleElementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TupleElementSyntax, TupleElementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleElementSyntax, TupleElementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, TupleElementSyntax original, TupleElementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TupleElementSyntax, TupleElementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleElementSyntax, TupleElementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, TupleElementSyntax original, TupleElementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TupleElementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleElementSyntax, TupleElementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, TupleElementSyntax original, TupleElementSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
    		if(original.Identifier != null && original.Identifier.Kind() != SyntaxKind.None && 
    		   modified.Identifier != null && modified.Identifier.Kind() != SyntaxKind.None)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else
    		{
    			if(original.Identifier != null && original.Identifier.Kind() != SyntaxKind.None)
    				matchingSet.Originals.DisableMatching(original.Identifier);
    			
    			if(modified.Identifier != null && modified.Identifier.Kind() != SyntaxKind.None)
    				matchingSet.Modifieds.DisableMatching(modified.Identifier);
    		}
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, TupleElementSyntax original, TupleElementSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleElementSyntax, TupleElementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleElementSyntax, TupleElementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TupleElementSyntax, TupleElementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleElementSyntax, TupleElementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TupleElementSyntax, TupleElementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleElementSyntax, TupleElementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TupleElementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleElementSyntax, TupleElementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as TupleElementSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as TupleElementSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ArgumentServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ArgumentSyntax, ArgumentSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArgumentSyntax, ArgumentSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArgumentSyntax, ArgumentSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ArgumentSyntax, ArgumentSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArgumentSyntax, ArgumentSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ArgumentSyntax original, ArgumentSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ArgumentSyntax, ArgumentSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArgumentSyntax, ArgumentSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ArgumentSyntax original, ArgumentSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ArgumentSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArgumentSyntax, ArgumentSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ArgumentSyntax original, ArgumentSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.RefKindKeyword,
    		    Modified = modified.RefKindKeyword
    		};
    		if(original.RefKindKeyword != null && original.RefKindKeyword.Kind() != SyntaxKind.None && 
    		   modified.RefKindKeyword != null && modified.RefKindKeyword.Kind() != SyntaxKind.None)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else
    		{
    			if(original.RefKindKeyword != null && original.RefKindKeyword.Kind() != SyntaxKind.None)
    				matchingSet.Originals.DisableMatching(original.RefKindKeyword);
    			
    			if(modified.RefKindKeyword != null && modified.RefKindKeyword.Kind() != SyntaxKind.None)
    				matchingSet.Modifieds.DisableMatching(modified.RefKindKeyword);
    		}
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ArgumentSyntax original, ArgumentSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArgumentSyntax, ArgumentSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArgumentSyntax, ArgumentSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ArgumentSyntax, ArgumentSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArgumentSyntax, ArgumentSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ArgumentSyntax, ArgumentSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArgumentSyntax, ArgumentSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ArgumentSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArgumentSyntax, ArgumentSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ArgumentSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ArgumentSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class NameColonServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, NameColonSyntax, NameColonSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NameColonSyntax, NameColonSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NameColonSyntax, NameColonSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, NameColonSyntax, NameColonSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NameColonSyntax, NameColonSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, NameColonSyntax original, NameColonSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, NameColonSyntax, NameColonSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NameColonSyntax, NameColonSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, NameColonSyntax original, NameColonSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="NameColonSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NameColonSyntax, NameColonSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, NameColonSyntax original, NameColonSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, NameColonSyntax original, NameColonSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NameColonSyntax, NameColonSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NameColonSyntax, NameColonSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, NameColonSyntax, NameColonSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NameColonSyntax, NameColonSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, NameColonSyntax, NameColonSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NameColonSyntax, NameColonSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="NameColonSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NameColonSyntax, NameColonSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as NameColonSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as NameColonSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class JoinIntoClauseServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, JoinIntoClauseSyntax, JoinIntoClauseSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, JoinIntoClauseSyntax, JoinIntoClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, JoinIntoClauseSyntax, JoinIntoClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, JoinIntoClauseSyntax, JoinIntoClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, JoinIntoClauseSyntax, JoinIntoClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, JoinIntoClauseSyntax original, JoinIntoClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, JoinIntoClauseSyntax, JoinIntoClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, JoinIntoClauseSyntax, JoinIntoClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, JoinIntoClauseSyntax original, JoinIntoClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="JoinIntoClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, JoinIntoClauseSyntax, JoinIntoClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, JoinIntoClauseSyntax original, JoinIntoClauseSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.IntoKeyword,
    		    Modified = modified.IntoKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, JoinIntoClauseSyntax original, JoinIntoClauseSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, JoinIntoClauseSyntax, JoinIntoClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, JoinIntoClauseSyntax, JoinIntoClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, JoinIntoClauseSyntax, JoinIntoClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, JoinIntoClauseSyntax, JoinIntoClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, JoinIntoClauseSyntax, JoinIntoClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, JoinIntoClauseSyntax, JoinIntoClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="JoinIntoClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, JoinIntoClauseSyntax, JoinIntoClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as JoinIntoClauseSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as JoinIntoClauseSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class OrderingServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, OrderingSyntax, OrderingSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OrderingSyntax, OrderingSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OrderingSyntax, OrderingSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, OrderingSyntax, OrderingSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OrderingSyntax, OrderingSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, OrderingSyntax original, OrderingSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, OrderingSyntax, OrderingSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OrderingSyntax, OrderingSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, OrderingSyntax original, OrderingSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="OrderingSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OrderingSyntax, OrderingSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, OrderingSyntax original, OrderingSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.AscendingOrDescendingKeyword,
    		    Modified = modified.AscendingOrDescendingKeyword
    		};
    		if(original.AscendingOrDescendingKeyword != null && original.AscendingOrDescendingKeyword.Kind() != SyntaxKind.None && 
    		   modified.AscendingOrDescendingKeyword != null && modified.AscendingOrDescendingKeyword.Kind() != SyntaxKind.None)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else
    		{
    			if(original.AscendingOrDescendingKeyword != null && original.AscendingOrDescendingKeyword.Kind() != SyntaxKind.None)
    				matchingSet.Originals.DisableMatching(original.AscendingOrDescendingKeyword);
    			
    			if(modified.AscendingOrDescendingKeyword != null && modified.AscendingOrDescendingKeyword.Kind() != SyntaxKind.None)
    				matchingSet.Modifieds.DisableMatching(modified.AscendingOrDescendingKeyword);
    		}
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, OrderingSyntax original, OrderingSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OrderingSyntax, OrderingSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OrderingSyntax, OrderingSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, OrderingSyntax, OrderingSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OrderingSyntax, OrderingSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, OrderingSyntax, OrderingSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OrderingSyntax, OrderingSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="OrderingSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OrderingSyntax, OrderingSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as OrderingSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as OrderingSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class QueryContinuationServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, QueryContinuationSyntax, QueryContinuationSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QueryContinuationSyntax, QueryContinuationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QueryContinuationSyntax, QueryContinuationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, QueryContinuationSyntax, QueryContinuationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QueryContinuationSyntax, QueryContinuationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, QueryContinuationSyntax original, QueryContinuationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, QueryContinuationSyntax, QueryContinuationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QueryContinuationSyntax, QueryContinuationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, QueryContinuationSyntax original, QueryContinuationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="QueryContinuationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QueryContinuationSyntax, QueryContinuationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, QueryContinuationSyntax original, QueryContinuationSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.IntoKeyword,
    		    Modified = modified.IntoKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, QueryContinuationSyntax original, QueryContinuationSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QueryContinuationSyntax, QueryContinuationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QueryContinuationSyntax, QueryContinuationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, QueryContinuationSyntax, QueryContinuationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QueryContinuationSyntax, QueryContinuationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, QueryContinuationSyntax, QueryContinuationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QueryContinuationSyntax, QueryContinuationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="QueryContinuationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QueryContinuationSyntax, QueryContinuationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as QueryContinuationSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as QueryContinuationSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class WhenClauseServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, WhenClauseSyntax, WhenClauseSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhenClauseSyntax, WhenClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhenClauseSyntax, WhenClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, WhenClauseSyntax, WhenClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhenClauseSyntax, WhenClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, WhenClauseSyntax original, WhenClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, WhenClauseSyntax, WhenClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhenClauseSyntax, WhenClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, WhenClauseSyntax original, WhenClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="WhenClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhenClauseSyntax, WhenClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, WhenClauseSyntax original, WhenClauseSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.WhenKeyword,
    		    Modified = modified.WhenKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, WhenClauseSyntax original, WhenClauseSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhenClauseSyntax, WhenClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhenClauseSyntax, WhenClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, WhenClauseSyntax, WhenClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhenClauseSyntax, WhenClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, WhenClauseSyntax, WhenClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhenClauseSyntax, WhenClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="WhenClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhenClauseSyntax, WhenClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as WhenClauseSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as WhenClauseSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class InterpolationAlignmentClauseServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, InterpolationAlignmentClauseSyntax original, InterpolationAlignmentClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, InterpolationAlignmentClauseSyntax original, InterpolationAlignmentClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="InterpolationAlignmentClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, InterpolationAlignmentClauseSyntax original, InterpolationAlignmentClauseSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CommaToken,
    		    Modified = modified.CommaToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, InterpolationAlignmentClauseSyntax original, InterpolationAlignmentClauseSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="InterpolationAlignmentClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as InterpolationAlignmentClauseSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as InterpolationAlignmentClauseSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class InterpolationFormatClauseServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, InterpolationFormatClauseSyntax original, InterpolationFormatClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, InterpolationFormatClauseSyntax original, InterpolationFormatClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="InterpolationFormatClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, InterpolationFormatClauseSyntax original, InterpolationFormatClauseSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.FormatStringToken,
    		    Modified = modified.FormatStringToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, InterpolationFormatClauseSyntax original, InterpolationFormatClauseSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="InterpolationFormatClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as InterpolationFormatClauseSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as InterpolationFormatClauseSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class VariableDeclaratorServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, VariableDeclaratorSyntax, VariableDeclaratorSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, VariableDeclaratorSyntax, VariableDeclaratorSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, VariableDeclaratorSyntax, VariableDeclaratorSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, VariableDeclaratorSyntax, VariableDeclaratorSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, VariableDeclaratorSyntax, VariableDeclaratorSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, VariableDeclaratorSyntax original, VariableDeclaratorSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, VariableDeclaratorSyntax, VariableDeclaratorSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, VariableDeclaratorSyntax, VariableDeclaratorSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, VariableDeclaratorSyntax original, VariableDeclaratorSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="VariableDeclaratorSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, VariableDeclaratorSyntax, VariableDeclaratorSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, VariableDeclaratorSyntax original, VariableDeclaratorSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, VariableDeclaratorSyntax original, VariableDeclaratorSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, VariableDeclaratorSyntax, VariableDeclaratorSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, VariableDeclaratorSyntax, VariableDeclaratorSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, VariableDeclaratorSyntax, VariableDeclaratorSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, VariableDeclaratorSyntax, VariableDeclaratorSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, VariableDeclaratorSyntax, VariableDeclaratorSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, VariableDeclaratorSyntax, VariableDeclaratorSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="VariableDeclaratorSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, VariableDeclaratorSyntax, VariableDeclaratorSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as VariableDeclaratorSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as VariableDeclaratorSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class EqualsValueClauseServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, EqualsValueClauseSyntax, EqualsValueClauseSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EqualsValueClauseSyntax, EqualsValueClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EqualsValueClauseSyntax, EqualsValueClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EqualsValueClauseSyntax, EqualsValueClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EqualsValueClauseSyntax, EqualsValueClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, EqualsValueClauseSyntax original, EqualsValueClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EqualsValueClauseSyntax, EqualsValueClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EqualsValueClauseSyntax, EqualsValueClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, EqualsValueClauseSyntax original, EqualsValueClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EqualsValueClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EqualsValueClauseSyntax, EqualsValueClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, EqualsValueClauseSyntax original, EqualsValueClauseSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EqualsToken,
    		    Modified = modified.EqualsToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, EqualsValueClauseSyntax original, EqualsValueClauseSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EqualsValueClauseSyntax, EqualsValueClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EqualsValueClauseSyntax, EqualsValueClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EqualsValueClauseSyntax, EqualsValueClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EqualsValueClauseSyntax, EqualsValueClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EqualsValueClauseSyntax, EqualsValueClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EqualsValueClauseSyntax, EqualsValueClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EqualsValueClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EqualsValueClauseSyntax, EqualsValueClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as EqualsValueClauseSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as EqualsValueClauseSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ElseClauseServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ElseClauseSyntax, ElseClauseSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElseClauseSyntax, ElseClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElseClauseSyntax, ElseClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ElseClauseSyntax, ElseClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElseClauseSyntax, ElseClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ElseClauseSyntax original, ElseClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ElseClauseSyntax, ElseClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElseClauseSyntax, ElseClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ElseClauseSyntax original, ElseClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ElseClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElseClauseSyntax, ElseClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ElseClauseSyntax original, ElseClauseSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ElseKeyword,
    		    Modified = modified.ElseKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ElseClauseSyntax original, ElseClauseSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElseClauseSyntax, ElseClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElseClauseSyntax, ElseClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ElseClauseSyntax, ElseClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElseClauseSyntax, ElseClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ElseClauseSyntax, ElseClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElseClauseSyntax, ElseClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ElseClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElseClauseSyntax, ElseClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ElseClauseSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ElseClauseSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class CatchClauseServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, CatchClauseSyntax, CatchClauseSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchClauseSyntax, CatchClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchClauseSyntax, CatchClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CatchClauseSyntax, CatchClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchClauseSyntax, CatchClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, CatchClauseSyntax original, CatchClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CatchClauseSyntax, CatchClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchClauseSyntax, CatchClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, CatchClauseSyntax original, CatchClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CatchClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchClauseSyntax, CatchClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, CatchClauseSyntax original, CatchClauseSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CatchKeyword,
    		    Modified = modified.CatchKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, CatchClauseSyntax original, CatchClauseSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchClauseSyntax, CatchClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchClauseSyntax, CatchClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CatchClauseSyntax, CatchClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchClauseSyntax, CatchClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CatchClauseSyntax, CatchClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchClauseSyntax, CatchClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CatchClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchClauseSyntax, CatchClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as CatchClauseSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as CatchClauseSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class CatchDeclarationServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, CatchDeclarationSyntax, CatchDeclarationSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchDeclarationSyntax, CatchDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchDeclarationSyntax, CatchDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CatchDeclarationSyntax, CatchDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchDeclarationSyntax, CatchDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, CatchDeclarationSyntax original, CatchDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CatchDeclarationSyntax, CatchDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchDeclarationSyntax, CatchDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, CatchDeclarationSyntax original, CatchDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CatchDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchDeclarationSyntax, CatchDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, CatchDeclarationSyntax original, CatchDeclarationSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
    		if(original.Identifier != null && original.Identifier.Kind() != SyntaxKind.None && 
    		   modified.Identifier != null && modified.Identifier.Kind() != SyntaxKind.None)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else
    		{
    			if(original.Identifier != null && original.Identifier.Kind() != SyntaxKind.None)
    				matchingSet.Originals.DisableMatching(original.Identifier);
    			
    			if(modified.Identifier != null && modified.Identifier.Kind() != SyntaxKind.None)
    				matchingSet.Modifieds.DisableMatching(modified.Identifier);
    		}
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, CatchDeclarationSyntax original, CatchDeclarationSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchDeclarationSyntax, CatchDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchDeclarationSyntax, CatchDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CatchDeclarationSyntax, CatchDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchDeclarationSyntax, CatchDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CatchDeclarationSyntax, CatchDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchDeclarationSyntax, CatchDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CatchDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchDeclarationSyntax, CatchDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as CatchDeclarationSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as CatchDeclarationSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class CatchFilterClauseServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, CatchFilterClauseSyntax, CatchFilterClauseSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchFilterClauseSyntax, CatchFilterClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchFilterClauseSyntax, CatchFilterClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CatchFilterClauseSyntax, CatchFilterClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchFilterClauseSyntax, CatchFilterClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, CatchFilterClauseSyntax original, CatchFilterClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CatchFilterClauseSyntax, CatchFilterClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchFilterClauseSyntax, CatchFilterClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, CatchFilterClauseSyntax original, CatchFilterClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CatchFilterClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchFilterClauseSyntax, CatchFilterClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, CatchFilterClauseSyntax original, CatchFilterClauseSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.WhenKeyword,
    		    Modified = modified.WhenKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, CatchFilterClauseSyntax original, CatchFilterClauseSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchFilterClauseSyntax, CatchFilterClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchFilterClauseSyntax, CatchFilterClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CatchFilterClauseSyntax, CatchFilterClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchFilterClauseSyntax, CatchFilterClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CatchFilterClauseSyntax, CatchFilterClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchFilterClauseSyntax, CatchFilterClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CatchFilterClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CatchFilterClauseSyntax, CatchFilterClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as CatchFilterClauseSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as CatchFilterClauseSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class FinallyClauseServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, FinallyClauseSyntax, FinallyClauseSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FinallyClauseSyntax, FinallyClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FinallyClauseSyntax, FinallyClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, FinallyClauseSyntax, FinallyClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FinallyClauseSyntax, FinallyClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, FinallyClauseSyntax original, FinallyClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, FinallyClauseSyntax, FinallyClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FinallyClauseSyntax, FinallyClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, FinallyClauseSyntax original, FinallyClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="FinallyClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FinallyClauseSyntax, FinallyClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, FinallyClauseSyntax original, FinallyClauseSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.FinallyKeyword,
    		    Modified = modified.FinallyKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, FinallyClauseSyntax original, FinallyClauseSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FinallyClauseSyntax, FinallyClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FinallyClauseSyntax, FinallyClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, FinallyClauseSyntax, FinallyClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FinallyClauseSyntax, FinallyClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, FinallyClauseSyntax, FinallyClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FinallyClauseSyntax, FinallyClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="FinallyClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FinallyClauseSyntax, FinallyClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as FinallyClauseSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as FinallyClauseSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class CompilationUnitServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, CompilationUnitSyntax, CompilationUnitSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CompilationUnitSyntax, CompilationUnitSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CompilationUnitSyntax, CompilationUnitSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CompilationUnitSyntax, CompilationUnitSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CompilationUnitSyntax, CompilationUnitSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, CompilationUnitSyntax original, CompilationUnitSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CompilationUnitSyntax, CompilationUnitSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CompilationUnitSyntax, CompilationUnitSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, CompilationUnitSyntax original, CompilationUnitSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CompilationUnitSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CompilationUnitSyntax, CompilationUnitSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, CompilationUnitSyntax original, CompilationUnitSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfFileToken,
    		    Modified = modified.EndOfFileToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, CompilationUnitSyntax original, CompilationUnitSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CompilationUnitSyntax, CompilationUnitSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CompilationUnitSyntax, CompilationUnitSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CompilationUnitSyntax, CompilationUnitSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CompilationUnitSyntax, CompilationUnitSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CompilationUnitSyntax, CompilationUnitSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CompilationUnitSyntax, CompilationUnitSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CompilationUnitSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CompilationUnitSyntax, CompilationUnitSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as CompilationUnitSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as CompilationUnitSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ExternAliasDirectiveServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ExternAliasDirectiveSyntax original, ExternAliasDirectiveSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ExternAliasDirectiveSyntax original, ExternAliasDirectiveSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ExternAliasDirectiveSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ExternAliasDirectiveSyntax original, ExternAliasDirectiveSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ExternKeyword,
    		    Modified = modified.ExternKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.AliasKeyword,
    		    Modified = modified.AliasKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ExternAliasDirectiveSyntax original, ExternAliasDirectiveSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ExternAliasDirectiveSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ExternAliasDirectiveSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ExternAliasDirectiveSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class UsingDirectiveServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, UsingDirectiveSyntax, UsingDirectiveSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UsingDirectiveSyntax, UsingDirectiveSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UsingDirectiveSyntax, UsingDirectiveSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, UsingDirectiveSyntax, UsingDirectiveSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UsingDirectiveSyntax, UsingDirectiveSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, UsingDirectiveSyntax original, UsingDirectiveSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, UsingDirectiveSyntax, UsingDirectiveSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UsingDirectiveSyntax, UsingDirectiveSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, UsingDirectiveSyntax original, UsingDirectiveSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="UsingDirectiveSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UsingDirectiveSyntax, UsingDirectiveSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, UsingDirectiveSyntax original, UsingDirectiveSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.UsingKeyword,
    		    Modified = modified.UsingKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.StaticKeyword,
    		    Modified = modified.StaticKeyword
    		};
    		if(original.StaticKeyword != null && original.StaticKeyword.Kind() != SyntaxKind.None && 
    		   modified.StaticKeyword != null && modified.StaticKeyword.Kind() != SyntaxKind.None)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else
    		{
    			if(original.StaticKeyword != null && original.StaticKeyword.Kind() != SyntaxKind.None)
    				matchingSet.Originals.DisableMatching(original.StaticKeyword);
    			
    			if(modified.StaticKeyword != null && modified.StaticKeyword.Kind() != SyntaxKind.None)
    				matchingSet.Modifieds.DisableMatching(modified.StaticKeyword);
    		}
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, UsingDirectiveSyntax original, UsingDirectiveSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UsingDirectiveSyntax, UsingDirectiveSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UsingDirectiveSyntax, UsingDirectiveSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, UsingDirectiveSyntax, UsingDirectiveSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UsingDirectiveSyntax, UsingDirectiveSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, UsingDirectiveSyntax, UsingDirectiveSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UsingDirectiveSyntax, UsingDirectiveSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="UsingDirectiveSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UsingDirectiveSyntax, UsingDirectiveSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as UsingDirectiveSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as UsingDirectiveSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class AttributeListServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, AttributeListSyntax, AttributeListSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeListSyntax, AttributeListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeListSyntax, AttributeListSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AttributeListSyntax, AttributeListSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeListSyntax, AttributeListSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, AttributeListSyntax original, AttributeListSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AttributeListSyntax, AttributeListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeListSyntax, AttributeListSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, AttributeListSyntax original, AttributeListSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AttributeListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeListSyntax, AttributeListSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, AttributeListSyntax original, AttributeListSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBracketToken,
    		    Modified = modified.OpenBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBracketToken,
    		    Modified = modified.CloseBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, AttributeListSyntax original, AttributeListSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeListSyntax, AttributeListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeListSyntax, AttributeListSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AttributeListSyntax, AttributeListSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeListSyntax, AttributeListSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AttributeListSyntax, AttributeListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeListSyntax, AttributeListSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AttributeListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeListSyntax, AttributeListSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as AttributeListSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as AttributeListSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class AttributeTargetSpecifierServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, AttributeTargetSpecifierSyntax original, AttributeTargetSpecifierSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, AttributeTargetSpecifierSyntax original, AttributeTargetSpecifierSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AttributeTargetSpecifierSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, AttributeTargetSpecifierSyntax original, AttributeTargetSpecifierSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, AttributeTargetSpecifierSyntax original, AttributeTargetSpecifierSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AttributeTargetSpecifierSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as AttributeTargetSpecifierSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as AttributeTargetSpecifierSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class AttributeArgumentListServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, AttributeArgumentListSyntax, AttributeArgumentListSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeArgumentListSyntax, AttributeArgumentListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeArgumentListSyntax, AttributeArgumentListSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AttributeArgumentListSyntax, AttributeArgumentListSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeArgumentListSyntax, AttributeArgumentListSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, AttributeArgumentListSyntax original, AttributeArgumentListSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AttributeArgumentListSyntax, AttributeArgumentListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeArgumentListSyntax, AttributeArgumentListSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, AttributeArgumentListSyntax original, AttributeArgumentListSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AttributeArgumentListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeArgumentListSyntax, AttributeArgumentListSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, AttributeArgumentListSyntax original, AttributeArgumentListSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, AttributeArgumentListSyntax original, AttributeArgumentListSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeArgumentListSyntax, AttributeArgumentListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeArgumentListSyntax, AttributeArgumentListSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AttributeArgumentListSyntax, AttributeArgumentListSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeArgumentListSyntax, AttributeArgumentListSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AttributeArgumentListSyntax, AttributeArgumentListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeArgumentListSyntax, AttributeArgumentListSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AttributeArgumentListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AttributeArgumentListSyntax, AttributeArgumentListSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as AttributeArgumentListSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as AttributeArgumentListSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class DelegateDeclarationServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, DelegateDeclarationSyntax, DelegateDeclarationSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DelegateDeclarationSyntax, DelegateDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DelegateDeclarationSyntax, DelegateDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DelegateDeclarationSyntax, DelegateDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DelegateDeclarationSyntax, DelegateDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, DelegateDeclarationSyntax original, DelegateDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DelegateDeclarationSyntax, DelegateDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DelegateDeclarationSyntax, DelegateDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, DelegateDeclarationSyntax original, DelegateDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DelegateDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DelegateDeclarationSyntax, DelegateDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, DelegateDeclarationSyntax original, DelegateDeclarationSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.DelegateKeyword,
    		    Modified = modified.DelegateKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, DelegateDeclarationSyntax original, DelegateDeclarationSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DelegateDeclarationSyntax, DelegateDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DelegateDeclarationSyntax, DelegateDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DelegateDeclarationSyntax, DelegateDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DelegateDeclarationSyntax, DelegateDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DelegateDeclarationSyntax, DelegateDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DelegateDeclarationSyntax, DelegateDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DelegateDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DelegateDeclarationSyntax, DelegateDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as DelegateDeclarationSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as DelegateDeclarationSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class EnumMemberDeclarationServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, EnumMemberDeclarationSyntax original, EnumMemberDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, EnumMemberDeclarationSyntax original, EnumMemberDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EnumMemberDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, EnumMemberDeclarationSyntax original, EnumMemberDeclarationSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, EnumMemberDeclarationSyntax original, EnumMemberDeclarationSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EnumMemberDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as EnumMemberDeclarationSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as EnumMemberDeclarationSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class NamespaceDeclarationServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, NamespaceDeclarationSyntax, NamespaceDeclarationSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NamespaceDeclarationSyntax, NamespaceDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NamespaceDeclarationSyntax, NamespaceDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, NamespaceDeclarationSyntax, NamespaceDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NamespaceDeclarationSyntax, NamespaceDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, NamespaceDeclarationSyntax original, NamespaceDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, NamespaceDeclarationSyntax, NamespaceDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NamespaceDeclarationSyntax, NamespaceDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, NamespaceDeclarationSyntax original, NamespaceDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="NamespaceDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NamespaceDeclarationSyntax, NamespaceDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, NamespaceDeclarationSyntax original, NamespaceDeclarationSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.NamespaceKeyword,
    		    Modified = modified.NamespaceKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && original.SemicolonToken.Kind() != SyntaxKind.None && 
    		   modified.SemicolonToken != null && modified.SemicolonToken.Kind() != SyntaxKind.None)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else
    		{
    			if(original.SemicolonToken != null && original.SemicolonToken.Kind() != SyntaxKind.None)
    				matchingSet.Originals.DisableMatching(original.SemicolonToken);
    			
    			if(modified.SemicolonToken != null && modified.SemicolonToken.Kind() != SyntaxKind.None)
    				matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    		}
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, NamespaceDeclarationSyntax original, NamespaceDeclarationSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NamespaceDeclarationSyntax, NamespaceDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NamespaceDeclarationSyntax, NamespaceDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, NamespaceDeclarationSyntax, NamespaceDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NamespaceDeclarationSyntax, NamespaceDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, NamespaceDeclarationSyntax, NamespaceDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NamespaceDeclarationSyntax, NamespaceDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="NamespaceDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NamespaceDeclarationSyntax, NamespaceDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as NamespaceDeclarationSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as NamespaceDeclarationSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class EnumDeclarationServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, EnumDeclarationSyntax, EnumDeclarationSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EnumDeclarationSyntax, EnumDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EnumDeclarationSyntax, EnumDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EnumDeclarationSyntax, EnumDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EnumDeclarationSyntax, EnumDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, EnumDeclarationSyntax original, EnumDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EnumDeclarationSyntax, EnumDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EnumDeclarationSyntax, EnumDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, EnumDeclarationSyntax original, EnumDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EnumDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EnumDeclarationSyntax, EnumDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, EnumDeclarationSyntax original, EnumDeclarationSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EnumKeyword,
    		    Modified = modified.EnumKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && original.SemicolonToken.Kind() != SyntaxKind.None && 
    		   modified.SemicolonToken != null && modified.SemicolonToken.Kind() != SyntaxKind.None)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else
    		{
    			if(original.SemicolonToken != null && original.SemicolonToken.Kind() != SyntaxKind.None)
    				matchingSet.Originals.DisableMatching(original.SemicolonToken);
    			
    			if(modified.SemicolonToken != null && modified.SemicolonToken.Kind() != SyntaxKind.None)
    				matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    		}
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, EnumDeclarationSyntax original, EnumDeclarationSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EnumDeclarationSyntax, EnumDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EnumDeclarationSyntax, EnumDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EnumDeclarationSyntax, EnumDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EnumDeclarationSyntax, EnumDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EnumDeclarationSyntax, EnumDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EnumDeclarationSyntax, EnumDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EnumDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EnumDeclarationSyntax, EnumDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as EnumDeclarationSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as EnumDeclarationSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ClassDeclarationServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ClassDeclarationSyntax, ClassDeclarationSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ClassDeclarationSyntax, ClassDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ClassDeclarationSyntax, ClassDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ClassDeclarationSyntax, ClassDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ClassDeclarationSyntax, ClassDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ClassDeclarationSyntax original, ClassDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ClassDeclarationSyntax, ClassDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ClassDeclarationSyntax, ClassDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ClassDeclarationSyntax original, ClassDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ClassDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ClassDeclarationSyntax, ClassDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ClassDeclarationSyntax original, ClassDeclarationSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && original.SemicolonToken.Kind() != SyntaxKind.None && 
    		   modified.SemicolonToken != null && modified.SemicolonToken.Kind() != SyntaxKind.None)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else
    		{
    			if(original.SemicolonToken != null && original.SemicolonToken.Kind() != SyntaxKind.None)
    				matchingSet.Originals.DisableMatching(original.SemicolonToken);
    			
    			if(modified.SemicolonToken != null && modified.SemicolonToken.Kind() != SyntaxKind.None)
    				matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    		}
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ClassDeclarationSyntax original, ClassDeclarationSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ClassDeclarationSyntax, ClassDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ClassDeclarationSyntax, ClassDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ClassDeclarationSyntax, ClassDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ClassDeclarationSyntax, ClassDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ClassDeclarationSyntax, ClassDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ClassDeclarationSyntax, ClassDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ClassDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ClassDeclarationSyntax, ClassDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ClassDeclarationSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ClassDeclarationSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class StructDeclarationServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, StructDeclarationSyntax, StructDeclarationSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, StructDeclarationSyntax, StructDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, StructDeclarationSyntax, StructDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, StructDeclarationSyntax, StructDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, StructDeclarationSyntax, StructDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, StructDeclarationSyntax original, StructDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, StructDeclarationSyntax, StructDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, StructDeclarationSyntax, StructDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, StructDeclarationSyntax original, StructDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="StructDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, StructDeclarationSyntax, StructDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, StructDeclarationSyntax original, StructDeclarationSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && original.SemicolonToken.Kind() != SyntaxKind.None && 
    		   modified.SemicolonToken != null && modified.SemicolonToken.Kind() != SyntaxKind.None)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else
    		{
    			if(original.SemicolonToken != null && original.SemicolonToken.Kind() != SyntaxKind.None)
    				matchingSet.Originals.DisableMatching(original.SemicolonToken);
    			
    			if(modified.SemicolonToken != null && modified.SemicolonToken.Kind() != SyntaxKind.None)
    				matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    		}
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, StructDeclarationSyntax original, StructDeclarationSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, StructDeclarationSyntax, StructDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, StructDeclarationSyntax, StructDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, StructDeclarationSyntax, StructDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, StructDeclarationSyntax, StructDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, StructDeclarationSyntax, StructDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, StructDeclarationSyntax, StructDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="StructDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, StructDeclarationSyntax, StructDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as StructDeclarationSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as StructDeclarationSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class InterfaceDeclarationServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, InterfaceDeclarationSyntax, InterfaceDeclarationSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterfaceDeclarationSyntax, InterfaceDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterfaceDeclarationSyntax, InterfaceDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, InterfaceDeclarationSyntax, InterfaceDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterfaceDeclarationSyntax, InterfaceDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, InterfaceDeclarationSyntax original, InterfaceDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, InterfaceDeclarationSyntax, InterfaceDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterfaceDeclarationSyntax, InterfaceDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, InterfaceDeclarationSyntax original, InterfaceDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="InterfaceDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterfaceDeclarationSyntax, InterfaceDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, InterfaceDeclarationSyntax original, InterfaceDeclarationSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && original.SemicolonToken.Kind() != SyntaxKind.None && 
    		   modified.SemicolonToken != null && modified.SemicolonToken.Kind() != SyntaxKind.None)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else
    		{
    			if(original.SemicolonToken != null && original.SemicolonToken.Kind() != SyntaxKind.None)
    				matchingSet.Originals.DisableMatching(original.SemicolonToken);
    			
    			if(modified.SemicolonToken != null && modified.SemicolonToken.Kind() != SyntaxKind.None)
    				matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    		}
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, InterfaceDeclarationSyntax original, InterfaceDeclarationSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterfaceDeclarationSyntax, InterfaceDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterfaceDeclarationSyntax, InterfaceDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, InterfaceDeclarationSyntax, InterfaceDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterfaceDeclarationSyntax, InterfaceDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, InterfaceDeclarationSyntax, InterfaceDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterfaceDeclarationSyntax, InterfaceDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="InterfaceDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterfaceDeclarationSyntax, InterfaceDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as InterfaceDeclarationSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as InterfaceDeclarationSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class FieldDeclarationServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, FieldDeclarationSyntax, FieldDeclarationSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FieldDeclarationSyntax, FieldDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FieldDeclarationSyntax, FieldDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, FieldDeclarationSyntax, FieldDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FieldDeclarationSyntax, FieldDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, FieldDeclarationSyntax original, FieldDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, FieldDeclarationSyntax, FieldDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FieldDeclarationSyntax, FieldDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, FieldDeclarationSyntax original, FieldDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="FieldDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FieldDeclarationSyntax, FieldDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, FieldDeclarationSyntax original, FieldDeclarationSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, FieldDeclarationSyntax original, FieldDeclarationSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FieldDeclarationSyntax, FieldDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FieldDeclarationSyntax, FieldDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, FieldDeclarationSyntax, FieldDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FieldDeclarationSyntax, FieldDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, FieldDeclarationSyntax, FieldDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FieldDeclarationSyntax, FieldDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="FieldDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FieldDeclarationSyntax, FieldDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as FieldDeclarationSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as FieldDeclarationSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class EventFieldDeclarationServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, EventFieldDeclarationSyntax, EventFieldDeclarationSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EventFieldDeclarationSyntax, EventFieldDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EventFieldDeclarationSyntax, EventFieldDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EventFieldDeclarationSyntax, EventFieldDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EventFieldDeclarationSyntax, EventFieldDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, EventFieldDeclarationSyntax original, EventFieldDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EventFieldDeclarationSyntax, EventFieldDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EventFieldDeclarationSyntax, EventFieldDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, EventFieldDeclarationSyntax original, EventFieldDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EventFieldDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EventFieldDeclarationSyntax, EventFieldDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, EventFieldDeclarationSyntax original, EventFieldDeclarationSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EventKeyword,
    		    Modified = modified.EventKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, EventFieldDeclarationSyntax original, EventFieldDeclarationSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EventFieldDeclarationSyntax, EventFieldDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EventFieldDeclarationSyntax, EventFieldDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EventFieldDeclarationSyntax, EventFieldDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EventFieldDeclarationSyntax, EventFieldDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EventFieldDeclarationSyntax, EventFieldDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EventFieldDeclarationSyntax, EventFieldDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EventFieldDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EventFieldDeclarationSyntax, EventFieldDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as EventFieldDeclarationSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as EventFieldDeclarationSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class MethodDeclarationServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, MethodDeclarationSyntax, MethodDeclarationSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MethodDeclarationSyntax, MethodDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MethodDeclarationSyntax, MethodDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, MethodDeclarationSyntax, MethodDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MethodDeclarationSyntax, MethodDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, MethodDeclarationSyntax original, MethodDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, MethodDeclarationSyntax, MethodDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MethodDeclarationSyntax, MethodDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, MethodDeclarationSyntax original, MethodDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="MethodDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MethodDeclarationSyntax, MethodDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, MethodDeclarationSyntax original, MethodDeclarationSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && original.SemicolonToken.Kind() != SyntaxKind.None && 
    		   modified.SemicolonToken != null && modified.SemicolonToken.Kind() != SyntaxKind.None)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else
    		{
    			if(original.SemicolonToken != null && original.SemicolonToken.Kind() != SyntaxKind.None)
    				matchingSet.Originals.DisableMatching(original.SemicolonToken);
    			
    			if(modified.SemicolonToken != null && modified.SemicolonToken.Kind() != SyntaxKind.None)
    				matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    		}
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, MethodDeclarationSyntax original, MethodDeclarationSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MethodDeclarationSyntax, MethodDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MethodDeclarationSyntax, MethodDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, MethodDeclarationSyntax, MethodDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MethodDeclarationSyntax, MethodDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, MethodDeclarationSyntax, MethodDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MethodDeclarationSyntax, MethodDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="MethodDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MethodDeclarationSyntax, MethodDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as MethodDeclarationSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as MethodDeclarationSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class OperatorDeclarationServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, OperatorDeclarationSyntax, OperatorDeclarationSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OperatorDeclarationSyntax, OperatorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OperatorDeclarationSyntax, OperatorDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, OperatorDeclarationSyntax, OperatorDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OperatorDeclarationSyntax, OperatorDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, OperatorDeclarationSyntax original, OperatorDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, OperatorDeclarationSyntax, OperatorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OperatorDeclarationSyntax, OperatorDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, OperatorDeclarationSyntax original, OperatorDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="OperatorDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OperatorDeclarationSyntax, OperatorDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, OperatorDeclarationSyntax original, OperatorDeclarationSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorKeyword,
    		    Modified = modified.OperatorKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorToken,
    		    Modified = modified.OperatorToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && original.SemicolonToken.Kind() != SyntaxKind.None && 
    		   modified.SemicolonToken != null && modified.SemicolonToken.Kind() != SyntaxKind.None)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else
    		{
    			if(original.SemicolonToken != null && original.SemicolonToken.Kind() != SyntaxKind.None)
    				matchingSet.Originals.DisableMatching(original.SemicolonToken);
    			
    			if(modified.SemicolonToken != null && modified.SemicolonToken.Kind() != SyntaxKind.None)
    				matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    		}
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, OperatorDeclarationSyntax original, OperatorDeclarationSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OperatorDeclarationSyntax, OperatorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OperatorDeclarationSyntax, OperatorDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, OperatorDeclarationSyntax, OperatorDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OperatorDeclarationSyntax, OperatorDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, OperatorDeclarationSyntax, OperatorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OperatorDeclarationSyntax, OperatorDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="OperatorDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OperatorDeclarationSyntax, OperatorDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as OperatorDeclarationSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as OperatorDeclarationSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ConversionOperatorDeclarationServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ConversionOperatorDeclarationSyntax original, ConversionOperatorDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ConversionOperatorDeclarationSyntax original, ConversionOperatorDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ConversionOperatorDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ConversionOperatorDeclarationSyntax original, ConversionOperatorDeclarationSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ImplicitOrExplicitKeyword,
    		    Modified = modified.ImplicitOrExplicitKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorKeyword,
    		    Modified = modified.OperatorKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && original.SemicolonToken.Kind() != SyntaxKind.None && 
    		   modified.SemicolonToken != null && modified.SemicolonToken.Kind() != SyntaxKind.None)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else
    		{
    			if(original.SemicolonToken != null && original.SemicolonToken.Kind() != SyntaxKind.None)
    				matchingSet.Originals.DisableMatching(original.SemicolonToken);
    			
    			if(modified.SemicolonToken != null && modified.SemicolonToken.Kind() != SyntaxKind.None)
    				matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    		}
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ConversionOperatorDeclarationSyntax original, ConversionOperatorDeclarationSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ConversionOperatorDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ConversionOperatorDeclarationSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ConversionOperatorDeclarationSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ConstructorDeclarationServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ConstructorDeclarationSyntax, ConstructorDeclarationSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorDeclarationSyntax, ConstructorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorDeclarationSyntax, ConstructorDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ConstructorDeclarationSyntax, ConstructorDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorDeclarationSyntax, ConstructorDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ConstructorDeclarationSyntax original, ConstructorDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ConstructorDeclarationSyntax, ConstructorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorDeclarationSyntax, ConstructorDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ConstructorDeclarationSyntax original, ConstructorDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ConstructorDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorDeclarationSyntax, ConstructorDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ConstructorDeclarationSyntax original, ConstructorDeclarationSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && original.SemicolonToken.Kind() != SyntaxKind.None && 
    		   modified.SemicolonToken != null && modified.SemicolonToken.Kind() != SyntaxKind.None)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else
    		{
    			if(original.SemicolonToken != null && original.SemicolonToken.Kind() != SyntaxKind.None)
    				matchingSet.Originals.DisableMatching(original.SemicolonToken);
    			
    			if(modified.SemicolonToken != null && modified.SemicolonToken.Kind() != SyntaxKind.None)
    				matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    		}
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ConstructorDeclarationSyntax original, ConstructorDeclarationSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorDeclarationSyntax, ConstructorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorDeclarationSyntax, ConstructorDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ConstructorDeclarationSyntax, ConstructorDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorDeclarationSyntax, ConstructorDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ConstructorDeclarationSyntax, ConstructorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorDeclarationSyntax, ConstructorDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ConstructorDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorDeclarationSyntax, ConstructorDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ConstructorDeclarationSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ConstructorDeclarationSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class DestructorDeclarationServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, DestructorDeclarationSyntax, DestructorDeclarationSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DestructorDeclarationSyntax, DestructorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DestructorDeclarationSyntax, DestructorDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DestructorDeclarationSyntax, DestructorDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DestructorDeclarationSyntax, DestructorDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, DestructorDeclarationSyntax original, DestructorDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DestructorDeclarationSyntax, DestructorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DestructorDeclarationSyntax, DestructorDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, DestructorDeclarationSyntax original, DestructorDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DestructorDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DestructorDeclarationSyntax, DestructorDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, DestructorDeclarationSyntax original, DestructorDeclarationSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.TildeToken,
    		    Modified = modified.TildeToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && original.SemicolonToken.Kind() != SyntaxKind.None && 
    		   modified.SemicolonToken != null && modified.SemicolonToken.Kind() != SyntaxKind.None)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else
    		{
    			if(original.SemicolonToken != null && original.SemicolonToken.Kind() != SyntaxKind.None)
    				matchingSet.Originals.DisableMatching(original.SemicolonToken);
    			
    			if(modified.SemicolonToken != null && modified.SemicolonToken.Kind() != SyntaxKind.None)
    				matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    		}
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, DestructorDeclarationSyntax original, DestructorDeclarationSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DestructorDeclarationSyntax, DestructorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DestructorDeclarationSyntax, DestructorDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DestructorDeclarationSyntax, DestructorDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DestructorDeclarationSyntax, DestructorDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DestructorDeclarationSyntax, DestructorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DestructorDeclarationSyntax, DestructorDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DestructorDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DestructorDeclarationSyntax, DestructorDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as DestructorDeclarationSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as DestructorDeclarationSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class PropertyDeclarationServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, PropertyDeclarationSyntax, PropertyDeclarationSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PropertyDeclarationSyntax, PropertyDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PropertyDeclarationSyntax, PropertyDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, PropertyDeclarationSyntax, PropertyDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PropertyDeclarationSyntax, PropertyDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, PropertyDeclarationSyntax original, PropertyDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, PropertyDeclarationSyntax, PropertyDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PropertyDeclarationSyntax, PropertyDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, PropertyDeclarationSyntax original, PropertyDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="PropertyDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PropertyDeclarationSyntax, PropertyDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, PropertyDeclarationSyntax original, PropertyDeclarationSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && original.SemicolonToken.Kind() != SyntaxKind.None && 
    		   modified.SemicolonToken != null && modified.SemicolonToken.Kind() != SyntaxKind.None)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else
    		{
    			if(original.SemicolonToken != null && original.SemicolonToken.Kind() != SyntaxKind.None)
    				matchingSet.Originals.DisableMatching(original.SemicolonToken);
    			
    			if(modified.SemicolonToken != null && modified.SemicolonToken.Kind() != SyntaxKind.None)
    				matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    		}
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, PropertyDeclarationSyntax original, PropertyDeclarationSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PropertyDeclarationSyntax, PropertyDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PropertyDeclarationSyntax, PropertyDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, PropertyDeclarationSyntax, PropertyDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PropertyDeclarationSyntax, PropertyDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, PropertyDeclarationSyntax, PropertyDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PropertyDeclarationSyntax, PropertyDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="PropertyDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PropertyDeclarationSyntax, PropertyDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as PropertyDeclarationSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as PropertyDeclarationSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class EventDeclarationServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, EventDeclarationSyntax, EventDeclarationSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EventDeclarationSyntax, EventDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EventDeclarationSyntax, EventDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EventDeclarationSyntax, EventDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EventDeclarationSyntax, EventDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, EventDeclarationSyntax original, EventDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EventDeclarationSyntax, EventDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EventDeclarationSyntax, EventDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, EventDeclarationSyntax original, EventDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EventDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EventDeclarationSyntax, EventDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, EventDeclarationSyntax original, EventDeclarationSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EventKeyword,
    		    Modified = modified.EventKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, EventDeclarationSyntax original, EventDeclarationSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EventDeclarationSyntax, EventDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EventDeclarationSyntax, EventDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EventDeclarationSyntax, EventDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EventDeclarationSyntax, EventDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EventDeclarationSyntax, EventDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EventDeclarationSyntax, EventDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EventDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EventDeclarationSyntax, EventDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as EventDeclarationSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as EventDeclarationSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class IndexerDeclarationServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, IndexerDeclarationSyntax, IndexerDeclarationSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IndexerDeclarationSyntax, IndexerDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IndexerDeclarationSyntax, IndexerDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, IndexerDeclarationSyntax, IndexerDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IndexerDeclarationSyntax, IndexerDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, IndexerDeclarationSyntax original, IndexerDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, IndexerDeclarationSyntax, IndexerDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IndexerDeclarationSyntax, IndexerDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, IndexerDeclarationSyntax original, IndexerDeclarationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="IndexerDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IndexerDeclarationSyntax, IndexerDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, IndexerDeclarationSyntax original, IndexerDeclarationSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ThisKeyword,
    		    Modified = modified.ThisKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && original.SemicolonToken.Kind() != SyntaxKind.None && 
    		   modified.SemicolonToken != null && modified.SemicolonToken.Kind() != SyntaxKind.None)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else
    		{
    			if(original.SemicolonToken != null && original.SemicolonToken.Kind() != SyntaxKind.None)
    				matchingSet.Originals.DisableMatching(original.SemicolonToken);
    			
    			if(modified.SemicolonToken != null && modified.SemicolonToken.Kind() != SyntaxKind.None)
    				matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    		}
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, IndexerDeclarationSyntax original, IndexerDeclarationSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IndexerDeclarationSyntax, IndexerDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IndexerDeclarationSyntax, IndexerDeclarationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, IndexerDeclarationSyntax, IndexerDeclarationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IndexerDeclarationSyntax, IndexerDeclarationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, IndexerDeclarationSyntax, IndexerDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IndexerDeclarationSyntax, IndexerDeclarationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="IndexerDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IndexerDeclarationSyntax, IndexerDeclarationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as IndexerDeclarationSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as IndexerDeclarationSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ConstructorConstraintServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ConstructorConstraintSyntax, ConstructorConstraintSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorConstraintSyntax, ConstructorConstraintSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorConstraintSyntax, ConstructorConstraintSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ConstructorConstraintSyntax, ConstructorConstraintSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorConstraintSyntax, ConstructorConstraintSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ConstructorConstraintSyntax original, ConstructorConstraintSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ConstructorConstraintSyntax, ConstructorConstraintSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorConstraintSyntax, ConstructorConstraintSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ConstructorConstraintSyntax original, ConstructorConstraintSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ConstructorConstraintSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorConstraintSyntax, ConstructorConstraintSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ConstructorConstraintSyntax original, ConstructorConstraintSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.NewKeyword,
    		    Modified = modified.NewKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ConstructorConstraintSyntax original, ConstructorConstraintSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorConstraintSyntax, ConstructorConstraintSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorConstraintSyntax, ConstructorConstraintSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ConstructorConstraintSyntax, ConstructorConstraintSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorConstraintSyntax, ConstructorConstraintSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ConstructorConstraintSyntax, ConstructorConstraintSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorConstraintSyntax, ConstructorConstraintSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ConstructorConstraintSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConstructorConstraintSyntax, ConstructorConstraintSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ConstructorConstraintSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ConstructorConstraintSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ClassOrStructConstraintServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ClassOrStructConstraintSyntax original, ClassOrStructConstraintSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ClassOrStructConstraintSyntax original, ClassOrStructConstraintSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ClassOrStructConstraintSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ClassOrStructConstraintSyntax original, ClassOrStructConstraintSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ClassOrStructKeyword,
    		    Modified = modified.ClassOrStructKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ClassOrStructConstraintSyntax original, ClassOrStructConstraintSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ClassOrStructConstraintSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ClassOrStructConstraintSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ClassOrStructConstraintSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ParameterListServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ParameterListSyntax, ParameterListSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParameterListSyntax, ParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParameterListSyntax, ParameterListSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ParameterListSyntax, ParameterListSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParameterListSyntax, ParameterListSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ParameterListSyntax original, ParameterListSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ParameterListSyntax, ParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParameterListSyntax, ParameterListSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ParameterListSyntax original, ParameterListSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ParameterListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParameterListSyntax, ParameterListSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ParameterListSyntax original, ParameterListSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ParameterListSyntax original, ParameterListSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParameterListSyntax, ParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParameterListSyntax, ParameterListSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ParameterListSyntax, ParameterListSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParameterListSyntax, ParameterListSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ParameterListSyntax, ParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParameterListSyntax, ParameterListSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ParameterListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParameterListSyntax, ParameterListSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ParameterListSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ParameterListSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class BracketedParameterListServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, BracketedParameterListSyntax, BracketedParameterListSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BracketedParameterListSyntax, BracketedParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BracketedParameterListSyntax, BracketedParameterListSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BracketedParameterListSyntax, BracketedParameterListSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BracketedParameterListSyntax, BracketedParameterListSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, BracketedParameterListSyntax original, BracketedParameterListSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BracketedParameterListSyntax, BracketedParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BracketedParameterListSyntax, BracketedParameterListSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, BracketedParameterListSyntax original, BracketedParameterListSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BracketedParameterListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BracketedParameterListSyntax, BracketedParameterListSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, BracketedParameterListSyntax original, BracketedParameterListSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBracketToken,
    		    Modified = modified.OpenBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBracketToken,
    		    Modified = modified.CloseBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, BracketedParameterListSyntax original, BracketedParameterListSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BracketedParameterListSyntax, BracketedParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BracketedParameterListSyntax, BracketedParameterListSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BracketedParameterListSyntax, BracketedParameterListSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BracketedParameterListSyntax, BracketedParameterListSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BracketedParameterListSyntax, BracketedParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BracketedParameterListSyntax, BracketedParameterListSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BracketedParameterListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BracketedParameterListSyntax, BracketedParameterListSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as BracketedParameterListSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as BracketedParameterListSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class DocumentationCommentTriviaServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, DocumentationCommentTriviaSyntax original, DocumentationCommentTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, DocumentationCommentTriviaSyntax original, DocumentationCommentTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DocumentationCommentTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, DocumentationCommentTriviaSyntax original, DocumentationCommentTriviaSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfComment,
    		    Modified = modified.EndOfComment
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, DocumentationCommentTriviaSyntax original, DocumentationCommentTriviaSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DocumentationCommentTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as DocumentationCommentTriviaSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as DocumentationCommentTriviaSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class EndIfDirectiveTriviaServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, EndIfDirectiveTriviaSyntax original, EndIfDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, EndIfDirectiveTriviaSyntax original, EndIfDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EndIfDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, EndIfDirectiveTriviaSyntax original, EndIfDirectiveTriviaSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndIfKeyword,
    		    Modified = modified.EndIfKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, EndIfDirectiveTriviaSyntax original, EndIfDirectiveTriviaSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EndIfDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as EndIfDirectiveTriviaSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as EndIfDirectiveTriviaSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class RegionDirectiveTriviaServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, RegionDirectiveTriviaSyntax original, RegionDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, RegionDirectiveTriviaSyntax original, RegionDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="RegionDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, RegionDirectiveTriviaSyntax original, RegionDirectiveTriviaSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.RegionKeyword,
    		    Modified = modified.RegionKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, RegionDirectiveTriviaSyntax original, RegionDirectiveTriviaSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="RegionDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as RegionDirectiveTriviaSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as RegionDirectiveTriviaSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class EndRegionDirectiveTriviaServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, EndRegionDirectiveTriviaSyntax original, EndRegionDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, EndRegionDirectiveTriviaSyntax original, EndRegionDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EndRegionDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, EndRegionDirectiveTriviaSyntax original, EndRegionDirectiveTriviaSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndRegionKeyword,
    		    Modified = modified.EndRegionKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, EndRegionDirectiveTriviaSyntax original, EndRegionDirectiveTriviaSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EndRegionDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as EndRegionDirectiveTriviaSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as EndRegionDirectiveTriviaSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ErrorDirectiveTriviaServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ErrorDirectiveTriviaSyntax original, ErrorDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ErrorDirectiveTriviaSyntax original, ErrorDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ErrorDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ErrorDirectiveTriviaSyntax original, ErrorDirectiveTriviaSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ErrorKeyword,
    		    Modified = modified.ErrorKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ErrorDirectiveTriviaSyntax original, ErrorDirectiveTriviaSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ErrorDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ErrorDirectiveTriviaSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ErrorDirectiveTriviaSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class WarningDirectiveTriviaServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, WarningDirectiveTriviaSyntax original, WarningDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, WarningDirectiveTriviaSyntax original, WarningDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="WarningDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, WarningDirectiveTriviaSyntax original, WarningDirectiveTriviaSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.WarningKeyword,
    		    Modified = modified.WarningKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, WarningDirectiveTriviaSyntax original, WarningDirectiveTriviaSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="WarningDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as WarningDirectiveTriviaSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as WarningDirectiveTriviaSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class BadDirectiveTriviaServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, BadDirectiveTriviaSyntax original, BadDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, BadDirectiveTriviaSyntax original, BadDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BadDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, BadDirectiveTriviaSyntax original, BadDirectiveTriviaSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, BadDirectiveTriviaSyntax original, BadDirectiveTriviaSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BadDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as BadDirectiveTriviaSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as BadDirectiveTriviaSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class DefineDirectiveTriviaServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, DefineDirectiveTriviaSyntax original, DefineDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, DefineDirectiveTriviaSyntax original, DefineDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DefineDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, DefineDirectiveTriviaSyntax original, DefineDirectiveTriviaSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.DefineKeyword,
    		    Modified = modified.DefineKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Name,
    		    Modified = modified.Name
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, DefineDirectiveTriviaSyntax original, DefineDirectiveTriviaSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DefineDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as DefineDirectiveTriviaSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as DefineDirectiveTriviaSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class UndefDirectiveTriviaServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, UndefDirectiveTriviaSyntax original, UndefDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, UndefDirectiveTriviaSyntax original, UndefDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="UndefDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, UndefDirectiveTriviaSyntax original, UndefDirectiveTriviaSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.UndefKeyword,
    		    Modified = modified.UndefKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Name,
    		    Modified = modified.Name
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, UndefDirectiveTriviaSyntax original, UndefDirectiveTriviaSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="UndefDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as UndefDirectiveTriviaSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as UndefDirectiveTriviaSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class LineDirectiveTriviaServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, LineDirectiveTriviaSyntax original, LineDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, LineDirectiveTriviaSyntax original, LineDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LineDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, LineDirectiveTriviaSyntax original, LineDirectiveTriviaSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LineKeyword,
    		    Modified = modified.LineKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Line,
    		    Modified = modified.Line
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.File,
    		    Modified = modified.File
    		};
    		if(original.File != null && original.File.Kind() != SyntaxKind.None && 
    		   modified.File != null && modified.File.Kind() != SyntaxKind.None)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else
    		{
    			if(original.File != null && original.File.Kind() != SyntaxKind.None)
    				matchingSet.Originals.DisableMatching(original.File);
    			
    			if(modified.File != null && modified.File.Kind() != SyntaxKind.None)
    				matchingSet.Modifieds.DisableMatching(modified.File);
    		}
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, LineDirectiveTriviaSyntax original, LineDirectiveTriviaSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LineDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as LineDirectiveTriviaSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as LineDirectiveTriviaSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class PragmaWarningDirectiveTriviaServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, PragmaWarningDirectiveTriviaSyntax original, PragmaWarningDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, PragmaWarningDirectiveTriviaSyntax original, PragmaWarningDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="PragmaWarningDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, PragmaWarningDirectiveTriviaSyntax original, PragmaWarningDirectiveTriviaSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.PragmaKeyword,
    		    Modified = modified.PragmaKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.WarningKeyword,
    		    Modified = modified.WarningKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.DisableOrRestoreKeyword,
    		    Modified = modified.DisableOrRestoreKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, PragmaWarningDirectiveTriviaSyntax original, PragmaWarningDirectiveTriviaSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="PragmaWarningDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as PragmaWarningDirectiveTriviaSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as PragmaWarningDirectiveTriviaSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class PragmaChecksumDirectiveTriviaServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, PragmaChecksumDirectiveTriviaSyntax original, PragmaChecksumDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, PragmaChecksumDirectiveTriviaSyntax original, PragmaChecksumDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="PragmaChecksumDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, PragmaChecksumDirectiveTriviaSyntax original, PragmaChecksumDirectiveTriviaSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.PragmaKeyword,
    		    Modified = modified.PragmaKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ChecksumKeyword,
    		    Modified = modified.ChecksumKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.File,
    		    Modified = modified.File
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Guid,
    		    Modified = modified.Guid
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Bytes,
    		    Modified = modified.Bytes
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, PragmaChecksumDirectiveTriviaSyntax original, PragmaChecksumDirectiveTriviaSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="PragmaChecksumDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as PragmaChecksumDirectiveTriviaSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as PragmaChecksumDirectiveTriviaSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ReferenceDirectiveTriviaServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ReferenceDirectiveTriviaSyntax original, ReferenceDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ReferenceDirectiveTriviaSyntax original, ReferenceDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ReferenceDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ReferenceDirectiveTriviaSyntax original, ReferenceDirectiveTriviaSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ReferenceKeyword,
    		    Modified = modified.ReferenceKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.File,
    		    Modified = modified.File
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ReferenceDirectiveTriviaSyntax original, ReferenceDirectiveTriviaSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ReferenceDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ReferenceDirectiveTriviaSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ReferenceDirectiveTriviaSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class LoadDirectiveTriviaServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, LoadDirectiveTriviaSyntax original, LoadDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, LoadDirectiveTriviaSyntax original, LoadDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LoadDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, LoadDirectiveTriviaSyntax original, LoadDirectiveTriviaSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LoadKeyword,
    		    Modified = modified.LoadKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.File,
    		    Modified = modified.File
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, LoadDirectiveTriviaSyntax original, LoadDirectiveTriviaSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LoadDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as LoadDirectiveTriviaSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as LoadDirectiveTriviaSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ShebangDirectiveTriviaServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ShebangDirectiveTriviaSyntax original, ShebangDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ShebangDirectiveTriviaSyntax original, ShebangDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ShebangDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ShebangDirectiveTriviaSyntax original, ShebangDirectiveTriviaSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ExclamationToken,
    		    Modified = modified.ExclamationToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ShebangDirectiveTriviaSyntax original, ShebangDirectiveTriviaSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ShebangDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ShebangDirectiveTriviaSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ShebangDirectiveTriviaSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ElseDirectiveTriviaServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ElseDirectiveTriviaSyntax original, ElseDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ElseDirectiveTriviaSyntax original, ElseDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ElseDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ElseDirectiveTriviaSyntax original, ElseDirectiveTriviaSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ElseKeyword,
    		    Modified = modified.ElseKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ElseDirectiveTriviaSyntax original, ElseDirectiveTriviaSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ElseDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ElseDirectiveTriviaSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ElseDirectiveTriviaSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class IfDirectiveTriviaServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, IfDirectiveTriviaSyntax original, IfDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, IfDirectiveTriviaSyntax original, IfDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="IfDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, IfDirectiveTriviaSyntax original, IfDirectiveTriviaSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.IfKeyword,
    		    Modified = modified.IfKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, IfDirectiveTriviaSyntax original, IfDirectiveTriviaSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="IfDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as IfDirectiveTriviaSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as IfDirectiveTriviaSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ElifDirectiveTriviaServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ElifDirectiveTriviaSyntax original, ElifDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ElifDirectiveTriviaSyntax original, ElifDirectiveTriviaSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ElifDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ElifDirectiveTriviaSyntax original, ElifDirectiveTriviaSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ElifKeyword,
    		    Modified = modified.ElifKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ElifDirectiveTriviaSyntax original, ElifDirectiveTriviaSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ElifDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ElifDirectiveTriviaSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ElifDirectiveTriviaSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class QualifiedCrefServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, QualifiedCrefSyntax, QualifiedCrefSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QualifiedCrefSyntax, QualifiedCrefSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QualifiedCrefSyntax, QualifiedCrefSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, QualifiedCrefSyntax, QualifiedCrefSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QualifiedCrefSyntax, QualifiedCrefSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, QualifiedCrefSyntax original, QualifiedCrefSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, QualifiedCrefSyntax, QualifiedCrefSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QualifiedCrefSyntax, QualifiedCrefSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, QualifiedCrefSyntax original, QualifiedCrefSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="QualifiedCrefSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QualifiedCrefSyntax, QualifiedCrefSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, QualifiedCrefSyntax original, QualifiedCrefSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.DotToken,
    		    Modified = modified.DotToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, QualifiedCrefSyntax original, QualifiedCrefSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QualifiedCrefSyntax, QualifiedCrefSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QualifiedCrefSyntax, QualifiedCrefSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, QualifiedCrefSyntax, QualifiedCrefSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QualifiedCrefSyntax, QualifiedCrefSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, QualifiedCrefSyntax, QualifiedCrefSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QualifiedCrefSyntax, QualifiedCrefSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="QualifiedCrefSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QualifiedCrefSyntax, QualifiedCrefSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as QualifiedCrefSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as QualifiedCrefSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class IndexerMemberCrefServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, IndexerMemberCrefSyntax, IndexerMemberCrefSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IndexerMemberCrefSyntax, IndexerMemberCrefSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IndexerMemberCrefSyntax, IndexerMemberCrefSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, IndexerMemberCrefSyntax, IndexerMemberCrefSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IndexerMemberCrefSyntax, IndexerMemberCrefSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, IndexerMemberCrefSyntax original, IndexerMemberCrefSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, IndexerMemberCrefSyntax, IndexerMemberCrefSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IndexerMemberCrefSyntax, IndexerMemberCrefSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, IndexerMemberCrefSyntax original, IndexerMemberCrefSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="IndexerMemberCrefSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IndexerMemberCrefSyntax, IndexerMemberCrefSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, IndexerMemberCrefSyntax original, IndexerMemberCrefSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ThisKeyword,
    		    Modified = modified.ThisKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, IndexerMemberCrefSyntax original, IndexerMemberCrefSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IndexerMemberCrefSyntax, IndexerMemberCrefSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IndexerMemberCrefSyntax, IndexerMemberCrefSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, IndexerMemberCrefSyntax, IndexerMemberCrefSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IndexerMemberCrefSyntax, IndexerMemberCrefSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, IndexerMemberCrefSyntax, IndexerMemberCrefSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IndexerMemberCrefSyntax, IndexerMemberCrefSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="IndexerMemberCrefSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IndexerMemberCrefSyntax, IndexerMemberCrefSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as IndexerMemberCrefSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as IndexerMemberCrefSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class OperatorMemberCrefServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, OperatorMemberCrefSyntax, OperatorMemberCrefSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OperatorMemberCrefSyntax, OperatorMemberCrefSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OperatorMemberCrefSyntax, OperatorMemberCrefSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, OperatorMemberCrefSyntax, OperatorMemberCrefSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OperatorMemberCrefSyntax, OperatorMemberCrefSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, OperatorMemberCrefSyntax original, OperatorMemberCrefSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, OperatorMemberCrefSyntax, OperatorMemberCrefSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OperatorMemberCrefSyntax, OperatorMemberCrefSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, OperatorMemberCrefSyntax original, OperatorMemberCrefSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="OperatorMemberCrefSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OperatorMemberCrefSyntax, OperatorMemberCrefSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, OperatorMemberCrefSyntax original, OperatorMemberCrefSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorKeyword,
    		    Modified = modified.OperatorKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorToken,
    		    Modified = modified.OperatorToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, OperatorMemberCrefSyntax original, OperatorMemberCrefSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OperatorMemberCrefSyntax, OperatorMemberCrefSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OperatorMemberCrefSyntax, OperatorMemberCrefSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, OperatorMemberCrefSyntax, OperatorMemberCrefSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OperatorMemberCrefSyntax, OperatorMemberCrefSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, OperatorMemberCrefSyntax, OperatorMemberCrefSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OperatorMemberCrefSyntax, OperatorMemberCrefSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="OperatorMemberCrefSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OperatorMemberCrefSyntax, OperatorMemberCrefSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as OperatorMemberCrefSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as OperatorMemberCrefSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ConversionOperatorMemberCrefServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ConversionOperatorMemberCrefSyntax original, ConversionOperatorMemberCrefSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ConversionOperatorMemberCrefSyntax original, ConversionOperatorMemberCrefSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ConversionOperatorMemberCrefSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ConversionOperatorMemberCrefSyntax original, ConversionOperatorMemberCrefSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ImplicitOrExplicitKeyword,
    		    Modified = modified.ImplicitOrExplicitKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorKeyword,
    		    Modified = modified.OperatorKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ConversionOperatorMemberCrefSyntax original, ConversionOperatorMemberCrefSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ConversionOperatorMemberCrefSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ConversionOperatorMemberCrefSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ConversionOperatorMemberCrefSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class CrefParameterListServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, CrefParameterListSyntax, CrefParameterListSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefParameterListSyntax, CrefParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefParameterListSyntax, CrefParameterListSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CrefParameterListSyntax, CrefParameterListSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefParameterListSyntax, CrefParameterListSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, CrefParameterListSyntax original, CrefParameterListSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CrefParameterListSyntax, CrefParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefParameterListSyntax, CrefParameterListSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, CrefParameterListSyntax original, CrefParameterListSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CrefParameterListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefParameterListSyntax, CrefParameterListSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, CrefParameterListSyntax original, CrefParameterListSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, CrefParameterListSyntax original, CrefParameterListSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefParameterListSyntax, CrefParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefParameterListSyntax, CrefParameterListSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CrefParameterListSyntax, CrefParameterListSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefParameterListSyntax, CrefParameterListSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CrefParameterListSyntax, CrefParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefParameterListSyntax, CrefParameterListSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CrefParameterListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefParameterListSyntax, CrefParameterListSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as CrefParameterListSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as CrefParameterListSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class CrefBracketedParameterListServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, CrefBracketedParameterListSyntax original, CrefBracketedParameterListSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, CrefBracketedParameterListSyntax original, CrefBracketedParameterListSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CrefBracketedParameterListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, CrefBracketedParameterListSyntax original, CrefBracketedParameterListSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBracketToken,
    		    Modified = modified.OpenBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBracketToken,
    		    Modified = modified.CloseBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, CrefBracketedParameterListSyntax original, CrefBracketedParameterListSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CrefBracketedParameterListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as CrefBracketedParameterListSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as CrefBracketedParameterListSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class XmlElementServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, XmlElementSyntax, XmlElementSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementSyntax, XmlElementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementSyntax, XmlElementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlElementSyntax, XmlElementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementSyntax, XmlElementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, XmlElementSyntax original, XmlElementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlElementSyntax, XmlElementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementSyntax, XmlElementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, XmlElementSyntax original, XmlElementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlElementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementSyntax, XmlElementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, XmlElementSyntax original, XmlElementSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.StartTag,
    		    Modified = modified.StartTag
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndTag,
    		    Modified = modified.EndTag
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, XmlElementSyntax original, XmlElementSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementSyntax, XmlElementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementSyntax, XmlElementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlElementSyntax, XmlElementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementSyntax, XmlElementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlElementSyntax, XmlElementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementSyntax, XmlElementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlElementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlElementSyntax, XmlElementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as XmlElementSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as XmlElementSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class XmlEmptyElementServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, XmlEmptyElementSyntax, XmlEmptyElementSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlEmptyElementSyntax, XmlEmptyElementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlEmptyElementSyntax, XmlEmptyElementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlEmptyElementSyntax, XmlEmptyElementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlEmptyElementSyntax, XmlEmptyElementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, XmlEmptyElementSyntax original, XmlEmptyElementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlEmptyElementSyntax, XmlEmptyElementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlEmptyElementSyntax, XmlEmptyElementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, XmlEmptyElementSyntax original, XmlEmptyElementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlEmptyElementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlEmptyElementSyntax, XmlEmptyElementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, XmlEmptyElementSyntax original, XmlEmptyElementSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LessThanToken,
    		    Modified = modified.LessThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SlashGreaterThanToken,
    		    Modified = modified.SlashGreaterThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, XmlEmptyElementSyntax original, XmlEmptyElementSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlEmptyElementSyntax, XmlEmptyElementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlEmptyElementSyntax, XmlEmptyElementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlEmptyElementSyntax, XmlEmptyElementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlEmptyElementSyntax, XmlEmptyElementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlEmptyElementSyntax, XmlEmptyElementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlEmptyElementSyntax, XmlEmptyElementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlEmptyElementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlEmptyElementSyntax, XmlEmptyElementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as XmlEmptyElementSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as XmlEmptyElementSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class XmlCDataSectionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, XmlCDataSectionSyntax, XmlCDataSectionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCDataSectionSyntax, XmlCDataSectionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCDataSectionSyntax, XmlCDataSectionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlCDataSectionSyntax, XmlCDataSectionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCDataSectionSyntax, XmlCDataSectionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, XmlCDataSectionSyntax original, XmlCDataSectionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlCDataSectionSyntax, XmlCDataSectionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCDataSectionSyntax, XmlCDataSectionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, XmlCDataSectionSyntax original, XmlCDataSectionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlCDataSectionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCDataSectionSyntax, XmlCDataSectionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, XmlCDataSectionSyntax original, XmlCDataSectionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.StartCDataToken,
    		    Modified = modified.StartCDataToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndCDataToken,
    		    Modified = modified.EndCDataToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, XmlCDataSectionSyntax original, XmlCDataSectionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCDataSectionSyntax, XmlCDataSectionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCDataSectionSyntax, XmlCDataSectionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlCDataSectionSyntax, XmlCDataSectionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCDataSectionSyntax, XmlCDataSectionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlCDataSectionSyntax, XmlCDataSectionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCDataSectionSyntax, XmlCDataSectionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlCDataSectionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCDataSectionSyntax, XmlCDataSectionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as XmlCDataSectionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as XmlCDataSectionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class XmlProcessingInstructionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, XmlProcessingInstructionSyntax original, XmlProcessingInstructionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, XmlProcessingInstructionSyntax original, XmlProcessingInstructionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlProcessingInstructionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, XmlProcessingInstructionSyntax original, XmlProcessingInstructionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.StartProcessingInstructionToken,
    		    Modified = modified.StartProcessingInstructionToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndProcessingInstructionToken,
    		    Modified = modified.EndProcessingInstructionToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, XmlProcessingInstructionSyntax original, XmlProcessingInstructionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlProcessingInstructionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as XmlProcessingInstructionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as XmlProcessingInstructionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class XmlCommentServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, XmlCommentSyntax, XmlCommentSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCommentSyntax, XmlCommentSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCommentSyntax, XmlCommentSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlCommentSyntax, XmlCommentSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCommentSyntax, XmlCommentSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, XmlCommentSyntax original, XmlCommentSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlCommentSyntax, XmlCommentSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCommentSyntax, XmlCommentSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, XmlCommentSyntax original, XmlCommentSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlCommentSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCommentSyntax, XmlCommentSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, XmlCommentSyntax original, XmlCommentSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LessThanExclamationMinusMinusToken,
    		    Modified = modified.LessThanExclamationMinusMinusToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.MinusMinusGreaterThanToken,
    		    Modified = modified.MinusMinusGreaterThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, XmlCommentSyntax original, XmlCommentSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCommentSyntax, XmlCommentSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCommentSyntax, XmlCommentSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlCommentSyntax, XmlCommentSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCommentSyntax, XmlCommentSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlCommentSyntax, XmlCommentSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCommentSyntax, XmlCommentSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlCommentSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCommentSyntax, XmlCommentSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as XmlCommentSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as XmlCommentSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class XmlTextAttributeServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, XmlTextAttributeSyntax, XmlTextAttributeSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlTextAttributeSyntax, XmlTextAttributeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlTextAttributeSyntax, XmlTextAttributeSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlTextAttributeSyntax, XmlTextAttributeSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlTextAttributeSyntax, XmlTextAttributeSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, XmlTextAttributeSyntax original, XmlTextAttributeSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlTextAttributeSyntax, XmlTextAttributeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlTextAttributeSyntax, XmlTextAttributeSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, XmlTextAttributeSyntax original, XmlTextAttributeSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlTextAttributeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlTextAttributeSyntax, XmlTextAttributeSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, XmlTextAttributeSyntax original, XmlTextAttributeSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EqualsToken,
    		    Modified = modified.EqualsToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.StartQuoteToken,
    		    Modified = modified.StartQuoteToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndQuoteToken,
    		    Modified = modified.EndQuoteToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, XmlTextAttributeSyntax original, XmlTextAttributeSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlTextAttributeSyntax, XmlTextAttributeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlTextAttributeSyntax, XmlTextAttributeSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlTextAttributeSyntax, XmlTextAttributeSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlTextAttributeSyntax, XmlTextAttributeSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlTextAttributeSyntax, XmlTextAttributeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlTextAttributeSyntax, XmlTextAttributeSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlTextAttributeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlTextAttributeSyntax, XmlTextAttributeSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as XmlTextAttributeSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as XmlTextAttributeSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class XmlCrefAttributeServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, XmlCrefAttributeSyntax, XmlCrefAttributeSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCrefAttributeSyntax, XmlCrefAttributeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCrefAttributeSyntax, XmlCrefAttributeSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlCrefAttributeSyntax, XmlCrefAttributeSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCrefAttributeSyntax, XmlCrefAttributeSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, XmlCrefAttributeSyntax original, XmlCrefAttributeSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlCrefAttributeSyntax, XmlCrefAttributeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCrefAttributeSyntax, XmlCrefAttributeSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, XmlCrefAttributeSyntax original, XmlCrefAttributeSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlCrefAttributeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCrefAttributeSyntax, XmlCrefAttributeSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, XmlCrefAttributeSyntax original, XmlCrefAttributeSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EqualsToken,
    		    Modified = modified.EqualsToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.StartQuoteToken,
    		    Modified = modified.StartQuoteToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndQuoteToken,
    		    Modified = modified.EndQuoteToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, XmlCrefAttributeSyntax original, XmlCrefAttributeSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCrefAttributeSyntax, XmlCrefAttributeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCrefAttributeSyntax, XmlCrefAttributeSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlCrefAttributeSyntax, XmlCrefAttributeSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCrefAttributeSyntax, XmlCrefAttributeSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlCrefAttributeSyntax, XmlCrefAttributeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCrefAttributeSyntax, XmlCrefAttributeSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlCrefAttributeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlCrefAttributeSyntax, XmlCrefAttributeSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as XmlCrefAttributeSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as XmlCrefAttributeSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class XmlNameAttributeServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, XmlNameAttributeSyntax, XmlNameAttributeSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlNameAttributeSyntax, XmlNameAttributeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlNameAttributeSyntax, XmlNameAttributeSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlNameAttributeSyntax, XmlNameAttributeSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlNameAttributeSyntax, XmlNameAttributeSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, XmlNameAttributeSyntax original, XmlNameAttributeSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlNameAttributeSyntax, XmlNameAttributeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlNameAttributeSyntax, XmlNameAttributeSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, XmlNameAttributeSyntax original, XmlNameAttributeSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlNameAttributeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlNameAttributeSyntax, XmlNameAttributeSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, XmlNameAttributeSyntax original, XmlNameAttributeSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EqualsToken,
    		    Modified = modified.EqualsToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.StartQuoteToken,
    		    Modified = modified.StartQuoteToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndQuoteToken,
    		    Modified = modified.EndQuoteToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, XmlNameAttributeSyntax original, XmlNameAttributeSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlNameAttributeSyntax, XmlNameAttributeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlNameAttributeSyntax, XmlNameAttributeSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlNameAttributeSyntax, XmlNameAttributeSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlNameAttributeSyntax, XmlNameAttributeSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, XmlNameAttributeSyntax, XmlNameAttributeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlNameAttributeSyntax, XmlNameAttributeSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlNameAttributeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, XmlNameAttributeSyntax, XmlNameAttributeSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as XmlNameAttributeSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as XmlNameAttributeSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ParenthesizedExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ParenthesizedExpressionSyntax original, ParenthesizedExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ParenthesizedExpressionSyntax original, ParenthesizedExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ParenthesizedExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ParenthesizedExpressionSyntax original, ParenthesizedExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ParenthesizedExpressionSyntax original, ParenthesizedExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ParenthesizedExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ParenthesizedExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ParenthesizedExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class TupleExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, TupleExpressionSyntax, TupleExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleExpressionSyntax, TupleExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleExpressionSyntax, TupleExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TupleExpressionSyntax, TupleExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleExpressionSyntax, TupleExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, TupleExpressionSyntax original, TupleExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TupleExpressionSyntax, TupleExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleExpressionSyntax, TupleExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, TupleExpressionSyntax original, TupleExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TupleExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleExpressionSyntax, TupleExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, TupleExpressionSyntax original, TupleExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, TupleExpressionSyntax original, TupleExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleExpressionSyntax, TupleExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleExpressionSyntax, TupleExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TupleExpressionSyntax, TupleExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleExpressionSyntax, TupleExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TupleExpressionSyntax, TupleExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleExpressionSyntax, TupleExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TupleExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleExpressionSyntax, TupleExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as TupleExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as TupleExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class PrefixUnaryExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, PrefixUnaryExpressionSyntax original, PrefixUnaryExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, PrefixUnaryExpressionSyntax original, PrefixUnaryExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="PrefixUnaryExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, PrefixUnaryExpressionSyntax original, PrefixUnaryExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorToken,
    		    Modified = modified.OperatorToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, PrefixUnaryExpressionSyntax original, PrefixUnaryExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="PrefixUnaryExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as PrefixUnaryExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as PrefixUnaryExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class AwaitExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, AwaitExpressionSyntax, AwaitExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AwaitExpressionSyntax, AwaitExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AwaitExpressionSyntax, AwaitExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AwaitExpressionSyntax, AwaitExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AwaitExpressionSyntax, AwaitExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, AwaitExpressionSyntax original, AwaitExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AwaitExpressionSyntax, AwaitExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AwaitExpressionSyntax, AwaitExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, AwaitExpressionSyntax original, AwaitExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AwaitExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AwaitExpressionSyntax, AwaitExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, AwaitExpressionSyntax original, AwaitExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.AwaitKeyword,
    		    Modified = modified.AwaitKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, AwaitExpressionSyntax original, AwaitExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AwaitExpressionSyntax, AwaitExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AwaitExpressionSyntax, AwaitExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AwaitExpressionSyntax, AwaitExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AwaitExpressionSyntax, AwaitExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AwaitExpressionSyntax, AwaitExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AwaitExpressionSyntax, AwaitExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AwaitExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AwaitExpressionSyntax, AwaitExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as AwaitExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as AwaitExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class PostfixUnaryExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, PostfixUnaryExpressionSyntax original, PostfixUnaryExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, PostfixUnaryExpressionSyntax original, PostfixUnaryExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="PostfixUnaryExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, PostfixUnaryExpressionSyntax original, PostfixUnaryExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorToken,
    		    Modified = modified.OperatorToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, PostfixUnaryExpressionSyntax original, PostfixUnaryExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="PostfixUnaryExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as PostfixUnaryExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as PostfixUnaryExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class MemberAccessExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, MemberAccessExpressionSyntax, MemberAccessExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MemberAccessExpressionSyntax, MemberAccessExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MemberAccessExpressionSyntax, MemberAccessExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, MemberAccessExpressionSyntax, MemberAccessExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MemberAccessExpressionSyntax, MemberAccessExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, MemberAccessExpressionSyntax original, MemberAccessExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, MemberAccessExpressionSyntax, MemberAccessExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MemberAccessExpressionSyntax, MemberAccessExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, MemberAccessExpressionSyntax original, MemberAccessExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="MemberAccessExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MemberAccessExpressionSyntax, MemberAccessExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, MemberAccessExpressionSyntax original, MemberAccessExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorToken,
    		    Modified = modified.OperatorToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, MemberAccessExpressionSyntax original, MemberAccessExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MemberAccessExpressionSyntax, MemberAccessExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MemberAccessExpressionSyntax, MemberAccessExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, MemberAccessExpressionSyntax, MemberAccessExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MemberAccessExpressionSyntax, MemberAccessExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, MemberAccessExpressionSyntax, MemberAccessExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MemberAccessExpressionSyntax, MemberAccessExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="MemberAccessExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MemberAccessExpressionSyntax, MemberAccessExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as MemberAccessExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as MemberAccessExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ConditionalAccessExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ConditionalAccessExpressionSyntax original, ConditionalAccessExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ConditionalAccessExpressionSyntax original, ConditionalAccessExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ConditionalAccessExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ConditionalAccessExpressionSyntax original, ConditionalAccessExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorToken,
    		    Modified = modified.OperatorToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ConditionalAccessExpressionSyntax original, ConditionalAccessExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ConditionalAccessExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ConditionalAccessExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ConditionalAccessExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class MemberBindingExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, MemberBindingExpressionSyntax, MemberBindingExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MemberBindingExpressionSyntax, MemberBindingExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MemberBindingExpressionSyntax, MemberBindingExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, MemberBindingExpressionSyntax, MemberBindingExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MemberBindingExpressionSyntax, MemberBindingExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, MemberBindingExpressionSyntax original, MemberBindingExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, MemberBindingExpressionSyntax, MemberBindingExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MemberBindingExpressionSyntax, MemberBindingExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, MemberBindingExpressionSyntax original, MemberBindingExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="MemberBindingExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MemberBindingExpressionSyntax, MemberBindingExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, MemberBindingExpressionSyntax original, MemberBindingExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorToken,
    		    Modified = modified.OperatorToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, MemberBindingExpressionSyntax original, MemberBindingExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MemberBindingExpressionSyntax, MemberBindingExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MemberBindingExpressionSyntax, MemberBindingExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, MemberBindingExpressionSyntax, MemberBindingExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MemberBindingExpressionSyntax, MemberBindingExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, MemberBindingExpressionSyntax, MemberBindingExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MemberBindingExpressionSyntax, MemberBindingExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="MemberBindingExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MemberBindingExpressionSyntax, MemberBindingExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as MemberBindingExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as MemberBindingExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class BinaryExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, BinaryExpressionSyntax, BinaryExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BinaryExpressionSyntax, BinaryExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BinaryExpressionSyntax, BinaryExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BinaryExpressionSyntax, BinaryExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BinaryExpressionSyntax, BinaryExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, BinaryExpressionSyntax original, BinaryExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BinaryExpressionSyntax, BinaryExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BinaryExpressionSyntax, BinaryExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, BinaryExpressionSyntax original, BinaryExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BinaryExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BinaryExpressionSyntax, BinaryExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, BinaryExpressionSyntax original, BinaryExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorToken,
    		    Modified = modified.OperatorToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, BinaryExpressionSyntax original, BinaryExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BinaryExpressionSyntax, BinaryExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BinaryExpressionSyntax, BinaryExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BinaryExpressionSyntax, BinaryExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BinaryExpressionSyntax, BinaryExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BinaryExpressionSyntax, BinaryExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BinaryExpressionSyntax, BinaryExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BinaryExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BinaryExpressionSyntax, BinaryExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as BinaryExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as BinaryExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class AssignmentExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, AssignmentExpressionSyntax, AssignmentExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AssignmentExpressionSyntax, AssignmentExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AssignmentExpressionSyntax, AssignmentExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AssignmentExpressionSyntax, AssignmentExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AssignmentExpressionSyntax, AssignmentExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, AssignmentExpressionSyntax original, AssignmentExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AssignmentExpressionSyntax, AssignmentExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AssignmentExpressionSyntax, AssignmentExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, AssignmentExpressionSyntax original, AssignmentExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AssignmentExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AssignmentExpressionSyntax, AssignmentExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, AssignmentExpressionSyntax original, AssignmentExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorToken,
    		    Modified = modified.OperatorToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, AssignmentExpressionSyntax original, AssignmentExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AssignmentExpressionSyntax, AssignmentExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AssignmentExpressionSyntax, AssignmentExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AssignmentExpressionSyntax, AssignmentExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AssignmentExpressionSyntax, AssignmentExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AssignmentExpressionSyntax, AssignmentExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AssignmentExpressionSyntax, AssignmentExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AssignmentExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AssignmentExpressionSyntax, AssignmentExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as AssignmentExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as AssignmentExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ConditionalExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ConditionalExpressionSyntax, ConditionalExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConditionalExpressionSyntax, ConditionalExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConditionalExpressionSyntax, ConditionalExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ConditionalExpressionSyntax, ConditionalExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConditionalExpressionSyntax, ConditionalExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ConditionalExpressionSyntax original, ConditionalExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ConditionalExpressionSyntax, ConditionalExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConditionalExpressionSyntax, ConditionalExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ConditionalExpressionSyntax original, ConditionalExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ConditionalExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConditionalExpressionSyntax, ConditionalExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ConditionalExpressionSyntax original, ConditionalExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.QuestionToken,
    		    Modified = modified.QuestionToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ConditionalExpressionSyntax original, ConditionalExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConditionalExpressionSyntax, ConditionalExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConditionalExpressionSyntax, ConditionalExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ConditionalExpressionSyntax, ConditionalExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConditionalExpressionSyntax, ConditionalExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ConditionalExpressionSyntax, ConditionalExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConditionalExpressionSyntax, ConditionalExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ConditionalExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ConditionalExpressionSyntax, ConditionalExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ConditionalExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ConditionalExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class LiteralExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, LiteralExpressionSyntax, LiteralExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LiteralExpressionSyntax, LiteralExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LiteralExpressionSyntax, LiteralExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LiteralExpressionSyntax, LiteralExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LiteralExpressionSyntax, LiteralExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, LiteralExpressionSyntax original, LiteralExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LiteralExpressionSyntax, LiteralExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LiteralExpressionSyntax, LiteralExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, LiteralExpressionSyntax original, LiteralExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LiteralExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LiteralExpressionSyntax, LiteralExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, LiteralExpressionSyntax original, LiteralExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Token,
    		    Modified = modified.Token
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, LiteralExpressionSyntax original, LiteralExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LiteralExpressionSyntax, LiteralExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LiteralExpressionSyntax, LiteralExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LiteralExpressionSyntax, LiteralExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LiteralExpressionSyntax, LiteralExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LiteralExpressionSyntax, LiteralExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LiteralExpressionSyntax, LiteralExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LiteralExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LiteralExpressionSyntax, LiteralExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as LiteralExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as LiteralExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class MakeRefExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, MakeRefExpressionSyntax, MakeRefExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MakeRefExpressionSyntax, MakeRefExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MakeRefExpressionSyntax, MakeRefExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, MakeRefExpressionSyntax, MakeRefExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MakeRefExpressionSyntax, MakeRefExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, MakeRefExpressionSyntax original, MakeRefExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, MakeRefExpressionSyntax, MakeRefExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MakeRefExpressionSyntax, MakeRefExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, MakeRefExpressionSyntax original, MakeRefExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="MakeRefExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MakeRefExpressionSyntax, MakeRefExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, MakeRefExpressionSyntax original, MakeRefExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, MakeRefExpressionSyntax original, MakeRefExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MakeRefExpressionSyntax, MakeRefExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MakeRefExpressionSyntax, MakeRefExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, MakeRefExpressionSyntax, MakeRefExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MakeRefExpressionSyntax, MakeRefExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, MakeRefExpressionSyntax, MakeRefExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MakeRefExpressionSyntax, MakeRefExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="MakeRefExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, MakeRefExpressionSyntax, MakeRefExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as MakeRefExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as MakeRefExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class RefTypeExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, RefTypeExpressionSyntax, RefTypeExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefTypeExpressionSyntax, RefTypeExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefTypeExpressionSyntax, RefTypeExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, RefTypeExpressionSyntax, RefTypeExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefTypeExpressionSyntax, RefTypeExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, RefTypeExpressionSyntax original, RefTypeExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, RefTypeExpressionSyntax, RefTypeExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefTypeExpressionSyntax, RefTypeExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, RefTypeExpressionSyntax original, RefTypeExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="RefTypeExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefTypeExpressionSyntax, RefTypeExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, RefTypeExpressionSyntax original, RefTypeExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, RefTypeExpressionSyntax original, RefTypeExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefTypeExpressionSyntax, RefTypeExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefTypeExpressionSyntax, RefTypeExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, RefTypeExpressionSyntax, RefTypeExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefTypeExpressionSyntax, RefTypeExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, RefTypeExpressionSyntax, RefTypeExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefTypeExpressionSyntax, RefTypeExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="RefTypeExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefTypeExpressionSyntax, RefTypeExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as RefTypeExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as RefTypeExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class RefValueExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, RefValueExpressionSyntax, RefValueExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefValueExpressionSyntax, RefValueExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefValueExpressionSyntax, RefValueExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, RefValueExpressionSyntax, RefValueExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefValueExpressionSyntax, RefValueExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, RefValueExpressionSyntax original, RefValueExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, RefValueExpressionSyntax, RefValueExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefValueExpressionSyntax, RefValueExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, RefValueExpressionSyntax original, RefValueExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="RefValueExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefValueExpressionSyntax, RefValueExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, RefValueExpressionSyntax original, RefValueExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Comma,
    		    Modified = modified.Comma
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, RefValueExpressionSyntax original, RefValueExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefValueExpressionSyntax, RefValueExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefValueExpressionSyntax, RefValueExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, RefValueExpressionSyntax, RefValueExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefValueExpressionSyntax, RefValueExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, RefValueExpressionSyntax, RefValueExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefValueExpressionSyntax, RefValueExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="RefValueExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefValueExpressionSyntax, RefValueExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as RefValueExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as RefValueExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class CheckedExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, CheckedExpressionSyntax, CheckedExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CheckedExpressionSyntax, CheckedExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CheckedExpressionSyntax, CheckedExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CheckedExpressionSyntax, CheckedExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CheckedExpressionSyntax, CheckedExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, CheckedExpressionSyntax original, CheckedExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CheckedExpressionSyntax, CheckedExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CheckedExpressionSyntax, CheckedExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, CheckedExpressionSyntax original, CheckedExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CheckedExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CheckedExpressionSyntax, CheckedExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, CheckedExpressionSyntax original, CheckedExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, CheckedExpressionSyntax original, CheckedExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CheckedExpressionSyntax, CheckedExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CheckedExpressionSyntax, CheckedExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CheckedExpressionSyntax, CheckedExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CheckedExpressionSyntax, CheckedExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CheckedExpressionSyntax, CheckedExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CheckedExpressionSyntax, CheckedExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CheckedExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CheckedExpressionSyntax, CheckedExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as CheckedExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as CheckedExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class DefaultExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, DefaultExpressionSyntax, DefaultExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefaultExpressionSyntax, DefaultExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefaultExpressionSyntax, DefaultExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DefaultExpressionSyntax, DefaultExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefaultExpressionSyntax, DefaultExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, DefaultExpressionSyntax original, DefaultExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DefaultExpressionSyntax, DefaultExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefaultExpressionSyntax, DefaultExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, DefaultExpressionSyntax original, DefaultExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DefaultExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefaultExpressionSyntax, DefaultExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, DefaultExpressionSyntax original, DefaultExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, DefaultExpressionSyntax original, DefaultExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefaultExpressionSyntax, DefaultExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefaultExpressionSyntax, DefaultExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DefaultExpressionSyntax, DefaultExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefaultExpressionSyntax, DefaultExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DefaultExpressionSyntax, DefaultExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefaultExpressionSyntax, DefaultExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DefaultExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefaultExpressionSyntax, DefaultExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as DefaultExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as DefaultExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class TypeOfExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, TypeOfExpressionSyntax, TypeOfExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeOfExpressionSyntax, TypeOfExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeOfExpressionSyntax, TypeOfExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TypeOfExpressionSyntax, TypeOfExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeOfExpressionSyntax, TypeOfExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, TypeOfExpressionSyntax original, TypeOfExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TypeOfExpressionSyntax, TypeOfExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeOfExpressionSyntax, TypeOfExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, TypeOfExpressionSyntax original, TypeOfExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TypeOfExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeOfExpressionSyntax, TypeOfExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, TypeOfExpressionSyntax original, TypeOfExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, TypeOfExpressionSyntax original, TypeOfExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeOfExpressionSyntax, TypeOfExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeOfExpressionSyntax, TypeOfExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TypeOfExpressionSyntax, TypeOfExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeOfExpressionSyntax, TypeOfExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TypeOfExpressionSyntax, TypeOfExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeOfExpressionSyntax, TypeOfExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TypeOfExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TypeOfExpressionSyntax, TypeOfExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as TypeOfExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as TypeOfExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class SizeOfExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, SizeOfExpressionSyntax, SizeOfExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SizeOfExpressionSyntax, SizeOfExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SizeOfExpressionSyntax, SizeOfExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, SizeOfExpressionSyntax, SizeOfExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SizeOfExpressionSyntax, SizeOfExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SizeOfExpressionSyntax original, SizeOfExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, SizeOfExpressionSyntax, SizeOfExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SizeOfExpressionSyntax, SizeOfExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SizeOfExpressionSyntax original, SizeOfExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="SizeOfExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SizeOfExpressionSyntax, SizeOfExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SizeOfExpressionSyntax original, SizeOfExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SizeOfExpressionSyntax original, SizeOfExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SizeOfExpressionSyntax, SizeOfExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SizeOfExpressionSyntax, SizeOfExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, SizeOfExpressionSyntax, SizeOfExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SizeOfExpressionSyntax, SizeOfExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, SizeOfExpressionSyntax, SizeOfExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SizeOfExpressionSyntax, SizeOfExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="SizeOfExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SizeOfExpressionSyntax, SizeOfExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as SizeOfExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as SizeOfExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class CastExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, CastExpressionSyntax, CastExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CastExpressionSyntax, CastExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CastExpressionSyntax, CastExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CastExpressionSyntax, CastExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CastExpressionSyntax, CastExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, CastExpressionSyntax original, CastExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CastExpressionSyntax, CastExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CastExpressionSyntax, CastExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, CastExpressionSyntax original, CastExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CastExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CastExpressionSyntax, CastExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, CastExpressionSyntax original, CastExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, CastExpressionSyntax original, CastExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CastExpressionSyntax, CastExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CastExpressionSyntax, CastExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CastExpressionSyntax, CastExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CastExpressionSyntax, CastExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CastExpressionSyntax, CastExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CastExpressionSyntax, CastExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CastExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CastExpressionSyntax, CastExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as CastExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as CastExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class RefExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, RefExpressionSyntax, RefExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefExpressionSyntax, RefExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefExpressionSyntax, RefExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, RefExpressionSyntax, RefExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefExpressionSyntax, RefExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, RefExpressionSyntax original, RefExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, RefExpressionSyntax, RefExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefExpressionSyntax, RefExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, RefExpressionSyntax original, RefExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="RefExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefExpressionSyntax, RefExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, RefExpressionSyntax original, RefExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.RefKeyword,
    		    Modified = modified.RefKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, RefExpressionSyntax original, RefExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefExpressionSyntax, RefExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefExpressionSyntax, RefExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, RefExpressionSyntax, RefExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefExpressionSyntax, RefExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, RefExpressionSyntax, RefExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefExpressionSyntax, RefExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="RefExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefExpressionSyntax, RefExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as RefExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as RefExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class InitializerExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, InitializerExpressionSyntax, InitializerExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InitializerExpressionSyntax, InitializerExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InitializerExpressionSyntax, InitializerExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, InitializerExpressionSyntax, InitializerExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InitializerExpressionSyntax, InitializerExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, InitializerExpressionSyntax original, InitializerExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, InitializerExpressionSyntax, InitializerExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InitializerExpressionSyntax, InitializerExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, InitializerExpressionSyntax original, InitializerExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="InitializerExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InitializerExpressionSyntax, InitializerExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, InitializerExpressionSyntax original, InitializerExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, InitializerExpressionSyntax original, InitializerExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InitializerExpressionSyntax, InitializerExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InitializerExpressionSyntax, InitializerExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, InitializerExpressionSyntax, InitializerExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InitializerExpressionSyntax, InitializerExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, InitializerExpressionSyntax, InitializerExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InitializerExpressionSyntax, InitializerExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="InitializerExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InitializerExpressionSyntax, InitializerExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as InitializerExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as InitializerExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ObjectCreationExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ObjectCreationExpressionSyntax original, ObjectCreationExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ObjectCreationExpressionSyntax original, ObjectCreationExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ObjectCreationExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ObjectCreationExpressionSyntax original, ObjectCreationExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.NewKeyword,
    		    Modified = modified.NewKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ObjectCreationExpressionSyntax original, ObjectCreationExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ObjectCreationExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ObjectCreationExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ObjectCreationExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class AnonymousObjectCreationExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, AnonymousObjectCreationExpressionSyntax original, AnonymousObjectCreationExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, AnonymousObjectCreationExpressionSyntax original, AnonymousObjectCreationExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AnonymousObjectCreationExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, AnonymousObjectCreationExpressionSyntax original, AnonymousObjectCreationExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.NewKeyword,
    		    Modified = modified.NewKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, AnonymousObjectCreationExpressionSyntax original, AnonymousObjectCreationExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AnonymousObjectCreationExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as AnonymousObjectCreationExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as AnonymousObjectCreationExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ArrayCreationExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ArrayCreationExpressionSyntax original, ArrayCreationExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ArrayCreationExpressionSyntax original, ArrayCreationExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ArrayCreationExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ArrayCreationExpressionSyntax original, ArrayCreationExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.NewKeyword,
    		    Modified = modified.NewKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ArrayCreationExpressionSyntax original, ArrayCreationExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ArrayCreationExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ArrayCreationExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ArrayCreationExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ImplicitArrayCreationExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ImplicitArrayCreationExpressionSyntax original, ImplicitArrayCreationExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ImplicitArrayCreationExpressionSyntax original, ImplicitArrayCreationExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ImplicitArrayCreationExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ImplicitArrayCreationExpressionSyntax original, ImplicitArrayCreationExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.NewKeyword,
    		    Modified = modified.NewKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBracketToken,
    		    Modified = modified.OpenBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBracketToken,
    		    Modified = modified.CloseBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ImplicitArrayCreationExpressionSyntax original, ImplicitArrayCreationExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ImplicitArrayCreationExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ImplicitArrayCreationExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ImplicitArrayCreationExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class StackAllocArrayCreationExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, StackAllocArrayCreationExpressionSyntax original, StackAllocArrayCreationExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, StackAllocArrayCreationExpressionSyntax original, StackAllocArrayCreationExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="StackAllocArrayCreationExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, StackAllocArrayCreationExpressionSyntax original, StackAllocArrayCreationExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.StackAllocKeyword,
    		    Modified = modified.StackAllocKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, StackAllocArrayCreationExpressionSyntax original, StackAllocArrayCreationExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="StackAllocArrayCreationExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as StackAllocArrayCreationExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as StackAllocArrayCreationExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class OmittedArraySizeExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, OmittedArraySizeExpressionSyntax original, OmittedArraySizeExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, OmittedArraySizeExpressionSyntax original, OmittedArraySizeExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="OmittedArraySizeExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, OmittedArraySizeExpressionSyntax original, OmittedArraySizeExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OmittedArraySizeExpressionToken,
    		    Modified = modified.OmittedArraySizeExpressionToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, OmittedArraySizeExpressionSyntax original, OmittedArraySizeExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="OmittedArraySizeExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as OmittedArraySizeExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as OmittedArraySizeExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class InterpolatedStringExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, InterpolatedStringExpressionSyntax original, InterpolatedStringExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, InterpolatedStringExpressionSyntax original, InterpolatedStringExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="InterpolatedStringExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, InterpolatedStringExpressionSyntax original, InterpolatedStringExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.StringStartToken,
    		    Modified = modified.StringStartToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.StringEndToken,
    		    Modified = modified.StringEndToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, InterpolatedStringExpressionSyntax original, InterpolatedStringExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="InterpolatedStringExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as InterpolatedStringExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as InterpolatedStringExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class IsPatternExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, IsPatternExpressionSyntax, IsPatternExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IsPatternExpressionSyntax, IsPatternExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IsPatternExpressionSyntax, IsPatternExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, IsPatternExpressionSyntax, IsPatternExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IsPatternExpressionSyntax, IsPatternExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, IsPatternExpressionSyntax original, IsPatternExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, IsPatternExpressionSyntax, IsPatternExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IsPatternExpressionSyntax, IsPatternExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, IsPatternExpressionSyntax original, IsPatternExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="IsPatternExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IsPatternExpressionSyntax, IsPatternExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, IsPatternExpressionSyntax original, IsPatternExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.IsKeyword,
    		    Modified = modified.IsKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, IsPatternExpressionSyntax original, IsPatternExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IsPatternExpressionSyntax, IsPatternExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IsPatternExpressionSyntax, IsPatternExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, IsPatternExpressionSyntax, IsPatternExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IsPatternExpressionSyntax, IsPatternExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, IsPatternExpressionSyntax, IsPatternExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IsPatternExpressionSyntax, IsPatternExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="IsPatternExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IsPatternExpressionSyntax, IsPatternExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as IsPatternExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as IsPatternExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ThrowExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ThrowExpressionSyntax, ThrowExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThrowExpressionSyntax, ThrowExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThrowExpressionSyntax, ThrowExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ThrowExpressionSyntax, ThrowExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThrowExpressionSyntax, ThrowExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ThrowExpressionSyntax original, ThrowExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ThrowExpressionSyntax, ThrowExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThrowExpressionSyntax, ThrowExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ThrowExpressionSyntax original, ThrowExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ThrowExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThrowExpressionSyntax, ThrowExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ThrowExpressionSyntax original, ThrowExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ThrowKeyword,
    		    Modified = modified.ThrowKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ThrowExpressionSyntax original, ThrowExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThrowExpressionSyntax, ThrowExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThrowExpressionSyntax, ThrowExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ThrowExpressionSyntax, ThrowExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThrowExpressionSyntax, ThrowExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ThrowExpressionSyntax, ThrowExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThrowExpressionSyntax, ThrowExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ThrowExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThrowExpressionSyntax, ThrowExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ThrowExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ThrowExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class PredefinedTypeServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, PredefinedTypeSyntax, PredefinedTypeSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PredefinedTypeSyntax, PredefinedTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PredefinedTypeSyntax, PredefinedTypeSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, PredefinedTypeSyntax, PredefinedTypeSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PredefinedTypeSyntax, PredefinedTypeSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, PredefinedTypeSyntax original, PredefinedTypeSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, PredefinedTypeSyntax, PredefinedTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PredefinedTypeSyntax, PredefinedTypeSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, PredefinedTypeSyntax original, PredefinedTypeSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="PredefinedTypeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PredefinedTypeSyntax, PredefinedTypeSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, PredefinedTypeSyntax original, PredefinedTypeSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, PredefinedTypeSyntax original, PredefinedTypeSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PredefinedTypeSyntax, PredefinedTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PredefinedTypeSyntax, PredefinedTypeSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, PredefinedTypeSyntax, PredefinedTypeSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PredefinedTypeSyntax, PredefinedTypeSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, PredefinedTypeSyntax, PredefinedTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PredefinedTypeSyntax, PredefinedTypeSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="PredefinedTypeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PredefinedTypeSyntax, PredefinedTypeSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as PredefinedTypeSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as PredefinedTypeSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class PointerTypeServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, PointerTypeSyntax, PointerTypeSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PointerTypeSyntax, PointerTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PointerTypeSyntax, PointerTypeSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, PointerTypeSyntax, PointerTypeSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PointerTypeSyntax, PointerTypeSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, PointerTypeSyntax original, PointerTypeSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, PointerTypeSyntax, PointerTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PointerTypeSyntax, PointerTypeSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, PointerTypeSyntax original, PointerTypeSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="PointerTypeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PointerTypeSyntax, PointerTypeSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, PointerTypeSyntax original, PointerTypeSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.AsteriskToken,
    		    Modified = modified.AsteriskToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, PointerTypeSyntax original, PointerTypeSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PointerTypeSyntax, PointerTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PointerTypeSyntax, PointerTypeSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, PointerTypeSyntax, PointerTypeSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PointerTypeSyntax, PointerTypeSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, PointerTypeSyntax, PointerTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PointerTypeSyntax, PointerTypeSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="PointerTypeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, PointerTypeSyntax, PointerTypeSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as PointerTypeSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as PointerTypeSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class NullableTypeServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, NullableTypeSyntax, NullableTypeSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NullableTypeSyntax, NullableTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NullableTypeSyntax, NullableTypeSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, NullableTypeSyntax, NullableTypeSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NullableTypeSyntax, NullableTypeSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, NullableTypeSyntax original, NullableTypeSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, NullableTypeSyntax, NullableTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NullableTypeSyntax, NullableTypeSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, NullableTypeSyntax original, NullableTypeSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="NullableTypeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NullableTypeSyntax, NullableTypeSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, NullableTypeSyntax original, NullableTypeSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.QuestionToken,
    		    Modified = modified.QuestionToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, NullableTypeSyntax original, NullableTypeSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NullableTypeSyntax, NullableTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NullableTypeSyntax, NullableTypeSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, NullableTypeSyntax, NullableTypeSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NullableTypeSyntax, NullableTypeSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, NullableTypeSyntax, NullableTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NullableTypeSyntax, NullableTypeSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="NullableTypeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, NullableTypeSyntax, NullableTypeSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as NullableTypeSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as NullableTypeSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class TupleTypeServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, TupleTypeSyntax, TupleTypeSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleTypeSyntax, TupleTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleTypeSyntax, TupleTypeSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TupleTypeSyntax, TupleTypeSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleTypeSyntax, TupleTypeSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, TupleTypeSyntax original, TupleTypeSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TupleTypeSyntax, TupleTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleTypeSyntax, TupleTypeSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, TupleTypeSyntax original, TupleTypeSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TupleTypeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleTypeSyntax, TupleTypeSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, TupleTypeSyntax original, TupleTypeSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, TupleTypeSyntax original, TupleTypeSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleTypeSyntax, TupleTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleTypeSyntax, TupleTypeSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TupleTypeSyntax, TupleTypeSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleTypeSyntax, TupleTypeSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TupleTypeSyntax, TupleTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleTypeSyntax, TupleTypeSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TupleTypeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TupleTypeSyntax, TupleTypeSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as TupleTypeSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as TupleTypeSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class OmittedTypeArgumentServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, OmittedTypeArgumentSyntax original, OmittedTypeArgumentSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, OmittedTypeArgumentSyntax original, OmittedTypeArgumentSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="OmittedTypeArgumentSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, OmittedTypeArgumentSyntax original, OmittedTypeArgumentSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OmittedTypeArgumentToken,
    		    Modified = modified.OmittedTypeArgumentToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, OmittedTypeArgumentSyntax original, OmittedTypeArgumentSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="OmittedTypeArgumentSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as OmittedTypeArgumentSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as OmittedTypeArgumentSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class RefTypeServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, RefTypeSyntax, RefTypeSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefTypeSyntax, RefTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefTypeSyntax, RefTypeSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, RefTypeSyntax, RefTypeSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefTypeSyntax, RefTypeSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, RefTypeSyntax original, RefTypeSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, RefTypeSyntax, RefTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefTypeSyntax, RefTypeSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, RefTypeSyntax original, RefTypeSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="RefTypeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefTypeSyntax, RefTypeSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, RefTypeSyntax original, RefTypeSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.RefKeyword,
    		    Modified = modified.RefKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ReadOnlyKeyword,
    		    Modified = modified.ReadOnlyKeyword
    		};
    		if(original.ReadOnlyKeyword != null && original.ReadOnlyKeyword.Kind() != SyntaxKind.None && 
    		   modified.ReadOnlyKeyword != null && modified.ReadOnlyKeyword.Kind() != SyntaxKind.None)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else
    		{
    			if(original.ReadOnlyKeyword != null && original.ReadOnlyKeyword.Kind() != SyntaxKind.None)
    				matchingSet.Originals.DisableMatching(original.ReadOnlyKeyword);
    			
    			if(modified.ReadOnlyKeyword != null && modified.ReadOnlyKeyword.Kind() != SyntaxKind.None)
    				matchingSet.Modifieds.DisableMatching(modified.ReadOnlyKeyword);
    		}
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, RefTypeSyntax original, RefTypeSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefTypeSyntax, RefTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefTypeSyntax, RefTypeSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, RefTypeSyntax, RefTypeSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefTypeSyntax, RefTypeSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, RefTypeSyntax, RefTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefTypeSyntax, RefTypeSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="RefTypeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, RefTypeSyntax, RefTypeSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as RefTypeSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as RefTypeSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class QualifiedNameServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, QualifiedNameSyntax, QualifiedNameSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QualifiedNameSyntax, QualifiedNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QualifiedNameSyntax, QualifiedNameSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, QualifiedNameSyntax, QualifiedNameSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QualifiedNameSyntax, QualifiedNameSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, QualifiedNameSyntax original, QualifiedNameSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, QualifiedNameSyntax, QualifiedNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QualifiedNameSyntax, QualifiedNameSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, QualifiedNameSyntax original, QualifiedNameSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="QualifiedNameSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QualifiedNameSyntax, QualifiedNameSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, QualifiedNameSyntax original, QualifiedNameSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.DotToken,
    		    Modified = modified.DotToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, QualifiedNameSyntax original, QualifiedNameSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QualifiedNameSyntax, QualifiedNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QualifiedNameSyntax, QualifiedNameSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, QualifiedNameSyntax, QualifiedNameSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QualifiedNameSyntax, QualifiedNameSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, QualifiedNameSyntax, QualifiedNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QualifiedNameSyntax, QualifiedNameSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="QualifiedNameSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, QualifiedNameSyntax, QualifiedNameSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as QualifiedNameSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as QualifiedNameSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class AliasQualifiedNameServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, AliasQualifiedNameSyntax, AliasQualifiedNameSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AliasQualifiedNameSyntax, AliasQualifiedNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AliasQualifiedNameSyntax, AliasQualifiedNameSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AliasQualifiedNameSyntax, AliasQualifiedNameSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AliasQualifiedNameSyntax, AliasQualifiedNameSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, AliasQualifiedNameSyntax original, AliasQualifiedNameSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AliasQualifiedNameSyntax, AliasQualifiedNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AliasQualifiedNameSyntax, AliasQualifiedNameSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, AliasQualifiedNameSyntax original, AliasQualifiedNameSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AliasQualifiedNameSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AliasQualifiedNameSyntax, AliasQualifiedNameSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, AliasQualifiedNameSyntax original, AliasQualifiedNameSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonColonToken,
    		    Modified = modified.ColonColonToken
    		};
    		if(original.ColonColonToken != null && original.ColonColonToken.Kind() != SyntaxKind.None && 
    		   modified.ColonColonToken != null && modified.ColonColonToken.Kind() != SyntaxKind.None)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else
    		{
    			if(original.ColonColonToken != null && original.ColonColonToken.Kind() != SyntaxKind.None)
    				matchingSet.Originals.DisableMatching(original.ColonColonToken);
    			
    			if(modified.ColonColonToken != null && modified.ColonColonToken.Kind() != SyntaxKind.None)
    				matchingSet.Modifieds.DisableMatching(modified.ColonColonToken);
    		}
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, AliasQualifiedNameSyntax original, AliasQualifiedNameSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AliasQualifiedNameSyntax, AliasQualifiedNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AliasQualifiedNameSyntax, AliasQualifiedNameSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AliasQualifiedNameSyntax, AliasQualifiedNameSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AliasQualifiedNameSyntax, AliasQualifiedNameSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AliasQualifiedNameSyntax, AliasQualifiedNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AliasQualifiedNameSyntax, AliasQualifiedNameSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AliasQualifiedNameSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AliasQualifiedNameSyntax, AliasQualifiedNameSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as AliasQualifiedNameSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as AliasQualifiedNameSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class IdentifierNameServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, IdentifierNameSyntax, IdentifierNameSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IdentifierNameSyntax, IdentifierNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IdentifierNameSyntax, IdentifierNameSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, IdentifierNameSyntax, IdentifierNameSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IdentifierNameSyntax, IdentifierNameSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, IdentifierNameSyntax original, IdentifierNameSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, IdentifierNameSyntax, IdentifierNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IdentifierNameSyntax, IdentifierNameSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, IdentifierNameSyntax original, IdentifierNameSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="IdentifierNameSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IdentifierNameSyntax, IdentifierNameSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, IdentifierNameSyntax original, IdentifierNameSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, IdentifierNameSyntax original, IdentifierNameSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IdentifierNameSyntax, IdentifierNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IdentifierNameSyntax, IdentifierNameSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, IdentifierNameSyntax, IdentifierNameSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IdentifierNameSyntax, IdentifierNameSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, IdentifierNameSyntax, IdentifierNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IdentifierNameSyntax, IdentifierNameSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="IdentifierNameSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IdentifierNameSyntax, IdentifierNameSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as IdentifierNameSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as IdentifierNameSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class GenericNameServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, GenericNameSyntax, GenericNameSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GenericNameSyntax, GenericNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GenericNameSyntax, GenericNameSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, GenericNameSyntax, GenericNameSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GenericNameSyntax, GenericNameSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, GenericNameSyntax original, GenericNameSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, GenericNameSyntax, GenericNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GenericNameSyntax, GenericNameSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, GenericNameSyntax original, GenericNameSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="GenericNameSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GenericNameSyntax, GenericNameSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, GenericNameSyntax original, GenericNameSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, GenericNameSyntax original, GenericNameSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GenericNameSyntax, GenericNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GenericNameSyntax, GenericNameSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, GenericNameSyntax, GenericNameSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GenericNameSyntax, GenericNameSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, GenericNameSyntax, GenericNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GenericNameSyntax, GenericNameSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="GenericNameSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GenericNameSyntax, GenericNameSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as GenericNameSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as GenericNameSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ThisExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ThisExpressionSyntax, ThisExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThisExpressionSyntax, ThisExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThisExpressionSyntax, ThisExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ThisExpressionSyntax, ThisExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThisExpressionSyntax, ThisExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ThisExpressionSyntax original, ThisExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ThisExpressionSyntax, ThisExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThisExpressionSyntax, ThisExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ThisExpressionSyntax original, ThisExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ThisExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThisExpressionSyntax, ThisExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ThisExpressionSyntax original, ThisExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Token,
    		    Modified = modified.Token
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ThisExpressionSyntax original, ThisExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThisExpressionSyntax, ThisExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThisExpressionSyntax, ThisExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ThisExpressionSyntax, ThisExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThisExpressionSyntax, ThisExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ThisExpressionSyntax, ThisExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThisExpressionSyntax, ThisExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ThisExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThisExpressionSyntax, ThisExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ThisExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ThisExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class BaseExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, BaseExpressionSyntax, BaseExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BaseExpressionSyntax, BaseExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BaseExpressionSyntax, BaseExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BaseExpressionSyntax, BaseExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BaseExpressionSyntax, BaseExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, BaseExpressionSyntax original, BaseExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BaseExpressionSyntax, BaseExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BaseExpressionSyntax, BaseExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, BaseExpressionSyntax original, BaseExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BaseExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BaseExpressionSyntax, BaseExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, BaseExpressionSyntax original, BaseExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Token,
    		    Modified = modified.Token
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, BaseExpressionSyntax original, BaseExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BaseExpressionSyntax, BaseExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BaseExpressionSyntax, BaseExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BaseExpressionSyntax, BaseExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BaseExpressionSyntax, BaseExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BaseExpressionSyntax, BaseExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BaseExpressionSyntax, BaseExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BaseExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BaseExpressionSyntax, BaseExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as BaseExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as BaseExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class AnonymousMethodExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, AnonymousMethodExpressionSyntax original, AnonymousMethodExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, AnonymousMethodExpressionSyntax original, AnonymousMethodExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AnonymousMethodExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, AnonymousMethodExpressionSyntax original, AnonymousMethodExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.AsyncKeyword,
    		    Modified = modified.AsyncKeyword
    		};
    		if(original.AsyncKeyword != null && original.AsyncKeyword.Kind() != SyntaxKind.None && 
    		   modified.AsyncKeyword != null && modified.AsyncKeyword.Kind() != SyntaxKind.None)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else
    		{
    			if(original.AsyncKeyword != null && original.AsyncKeyword.Kind() != SyntaxKind.None)
    				matchingSet.Originals.DisableMatching(original.AsyncKeyword);
    			
    			if(modified.AsyncKeyword != null && modified.AsyncKeyword.Kind() != SyntaxKind.None)
    				matchingSet.Modifieds.DisableMatching(modified.AsyncKeyword);
    		}
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.DelegateKeyword,
    		    Modified = modified.DelegateKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, AnonymousMethodExpressionSyntax original, AnonymousMethodExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AnonymousMethodExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as AnonymousMethodExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as AnonymousMethodExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class SimpleLambdaExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SimpleLambdaExpressionSyntax original, SimpleLambdaExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SimpleLambdaExpressionSyntax original, SimpleLambdaExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="SimpleLambdaExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SimpleLambdaExpressionSyntax original, SimpleLambdaExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.AsyncKeyword,
    		    Modified = modified.AsyncKeyword
    		};
    		if(original.AsyncKeyword != null && original.AsyncKeyword.Kind() != SyntaxKind.None && 
    		   modified.AsyncKeyword != null && modified.AsyncKeyword.Kind() != SyntaxKind.None)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else
    		{
    			if(original.AsyncKeyword != null && original.AsyncKeyword.Kind() != SyntaxKind.None)
    				matchingSet.Originals.DisableMatching(original.AsyncKeyword);
    			
    			if(modified.AsyncKeyword != null && modified.AsyncKeyword.Kind() != SyntaxKind.None)
    				matchingSet.Modifieds.DisableMatching(modified.AsyncKeyword);
    		}
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ArrowToken,
    		    Modified = modified.ArrowToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SimpleLambdaExpressionSyntax original, SimpleLambdaExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="SimpleLambdaExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as SimpleLambdaExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as SimpleLambdaExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ParenthesizedLambdaExpressionServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ParenthesizedLambdaExpressionSyntax original, ParenthesizedLambdaExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ParenthesizedLambdaExpressionSyntax original, ParenthesizedLambdaExpressionSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ParenthesizedLambdaExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ParenthesizedLambdaExpressionSyntax original, ParenthesizedLambdaExpressionSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.AsyncKeyword,
    		    Modified = modified.AsyncKeyword
    		};
    		if(original.AsyncKeyword != null && original.AsyncKeyword.Kind() != SyntaxKind.None && 
    		   modified.AsyncKeyword != null && modified.AsyncKeyword.Kind() != SyntaxKind.None)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else
    		{
    			if(original.AsyncKeyword != null && original.AsyncKeyword.Kind() != SyntaxKind.None)
    				matchingSet.Originals.DisableMatching(original.AsyncKeyword);
    			
    			if(modified.AsyncKeyword != null && modified.AsyncKeyword.Kind() != SyntaxKind.None)
    				matchingSet.Modifieds.DisableMatching(modified.AsyncKeyword);
    		}
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ArrowToken,
    		    Modified = modified.ArrowToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ParenthesizedLambdaExpressionSyntax original, ParenthesizedLambdaExpressionSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ParenthesizedLambdaExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ParenthesizedLambdaExpressionSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ParenthesizedLambdaExpressionSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ArgumentListServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ArgumentListSyntax, ArgumentListSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArgumentListSyntax, ArgumentListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArgumentListSyntax, ArgumentListSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ArgumentListSyntax, ArgumentListSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArgumentListSyntax, ArgumentListSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ArgumentListSyntax original, ArgumentListSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ArgumentListSyntax, ArgumentListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArgumentListSyntax, ArgumentListSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ArgumentListSyntax original, ArgumentListSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ArgumentListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArgumentListSyntax, ArgumentListSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ArgumentListSyntax original, ArgumentListSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ArgumentListSyntax original, ArgumentListSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArgumentListSyntax, ArgumentListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArgumentListSyntax, ArgumentListSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ArgumentListSyntax, ArgumentListSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArgumentListSyntax, ArgumentListSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ArgumentListSyntax, ArgumentListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArgumentListSyntax, ArgumentListSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ArgumentListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ArgumentListSyntax, ArgumentListSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ArgumentListSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ArgumentListSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class BracketedArgumentListServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, BracketedArgumentListSyntax, BracketedArgumentListSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BracketedArgumentListSyntax, BracketedArgumentListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BracketedArgumentListSyntax, BracketedArgumentListSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BracketedArgumentListSyntax, BracketedArgumentListSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BracketedArgumentListSyntax, BracketedArgumentListSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, BracketedArgumentListSyntax original, BracketedArgumentListSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BracketedArgumentListSyntax, BracketedArgumentListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BracketedArgumentListSyntax, BracketedArgumentListSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, BracketedArgumentListSyntax original, BracketedArgumentListSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BracketedArgumentListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BracketedArgumentListSyntax, BracketedArgumentListSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, BracketedArgumentListSyntax original, BracketedArgumentListSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBracketToken,
    		    Modified = modified.OpenBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBracketToken,
    		    Modified = modified.CloseBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, BracketedArgumentListSyntax original, BracketedArgumentListSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BracketedArgumentListSyntax, BracketedArgumentListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BracketedArgumentListSyntax, BracketedArgumentListSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BracketedArgumentListSyntax, BracketedArgumentListSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BracketedArgumentListSyntax, BracketedArgumentListSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BracketedArgumentListSyntax, BracketedArgumentListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BracketedArgumentListSyntax, BracketedArgumentListSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BracketedArgumentListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BracketedArgumentListSyntax, BracketedArgumentListSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as BracketedArgumentListSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as BracketedArgumentListSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class FromClauseServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, FromClauseSyntax, FromClauseSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FromClauseSyntax, FromClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FromClauseSyntax, FromClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, FromClauseSyntax, FromClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FromClauseSyntax, FromClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, FromClauseSyntax original, FromClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, FromClauseSyntax, FromClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FromClauseSyntax, FromClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, FromClauseSyntax original, FromClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="FromClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FromClauseSyntax, FromClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, FromClauseSyntax original, FromClauseSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.FromKeyword,
    		    Modified = modified.FromKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.InKeyword,
    		    Modified = modified.InKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, FromClauseSyntax original, FromClauseSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FromClauseSyntax, FromClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FromClauseSyntax, FromClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, FromClauseSyntax, FromClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FromClauseSyntax, FromClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, FromClauseSyntax, FromClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FromClauseSyntax, FromClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="FromClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FromClauseSyntax, FromClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as FromClauseSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as FromClauseSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class LetClauseServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, LetClauseSyntax, LetClauseSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LetClauseSyntax, LetClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LetClauseSyntax, LetClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LetClauseSyntax, LetClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LetClauseSyntax, LetClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, LetClauseSyntax original, LetClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LetClauseSyntax, LetClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LetClauseSyntax, LetClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, LetClauseSyntax original, LetClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LetClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LetClauseSyntax, LetClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, LetClauseSyntax original, LetClauseSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LetKeyword,
    		    Modified = modified.LetKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EqualsToken,
    		    Modified = modified.EqualsToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, LetClauseSyntax original, LetClauseSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LetClauseSyntax, LetClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LetClauseSyntax, LetClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LetClauseSyntax, LetClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LetClauseSyntax, LetClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LetClauseSyntax, LetClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LetClauseSyntax, LetClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LetClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LetClauseSyntax, LetClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as LetClauseSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as LetClauseSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class JoinClauseServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, JoinClauseSyntax, JoinClauseSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, JoinClauseSyntax, JoinClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, JoinClauseSyntax, JoinClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, JoinClauseSyntax, JoinClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, JoinClauseSyntax, JoinClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, JoinClauseSyntax original, JoinClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, JoinClauseSyntax, JoinClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, JoinClauseSyntax, JoinClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, JoinClauseSyntax original, JoinClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="JoinClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, JoinClauseSyntax, JoinClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, JoinClauseSyntax original, JoinClauseSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.JoinKeyword,
    		    Modified = modified.JoinKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.InKeyword,
    		    Modified = modified.InKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OnKeyword,
    		    Modified = modified.OnKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EqualsKeyword,
    		    Modified = modified.EqualsKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, JoinClauseSyntax original, JoinClauseSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, JoinClauseSyntax, JoinClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, JoinClauseSyntax, JoinClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, JoinClauseSyntax, JoinClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, JoinClauseSyntax, JoinClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, JoinClauseSyntax, JoinClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, JoinClauseSyntax, JoinClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="JoinClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, JoinClauseSyntax, JoinClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as JoinClauseSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as JoinClauseSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class WhereClauseServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, WhereClauseSyntax, WhereClauseSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhereClauseSyntax, WhereClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhereClauseSyntax, WhereClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, WhereClauseSyntax, WhereClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhereClauseSyntax, WhereClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, WhereClauseSyntax original, WhereClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, WhereClauseSyntax, WhereClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhereClauseSyntax, WhereClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, WhereClauseSyntax original, WhereClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="WhereClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhereClauseSyntax, WhereClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, WhereClauseSyntax original, WhereClauseSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.WhereKeyword,
    		    Modified = modified.WhereKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, WhereClauseSyntax original, WhereClauseSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhereClauseSyntax, WhereClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhereClauseSyntax, WhereClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, WhereClauseSyntax, WhereClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhereClauseSyntax, WhereClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, WhereClauseSyntax, WhereClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhereClauseSyntax, WhereClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="WhereClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhereClauseSyntax, WhereClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as WhereClauseSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as WhereClauseSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class OrderByClauseServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, OrderByClauseSyntax, OrderByClauseSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OrderByClauseSyntax, OrderByClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OrderByClauseSyntax, OrderByClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, OrderByClauseSyntax, OrderByClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OrderByClauseSyntax, OrderByClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, OrderByClauseSyntax original, OrderByClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, OrderByClauseSyntax, OrderByClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OrderByClauseSyntax, OrderByClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, OrderByClauseSyntax original, OrderByClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="OrderByClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OrderByClauseSyntax, OrderByClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, OrderByClauseSyntax original, OrderByClauseSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OrderByKeyword,
    		    Modified = modified.OrderByKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, OrderByClauseSyntax original, OrderByClauseSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OrderByClauseSyntax, OrderByClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OrderByClauseSyntax, OrderByClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, OrderByClauseSyntax, OrderByClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OrderByClauseSyntax, OrderByClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, OrderByClauseSyntax, OrderByClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OrderByClauseSyntax, OrderByClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="OrderByClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, OrderByClauseSyntax, OrderByClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as OrderByClauseSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as OrderByClauseSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class SelectClauseServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, SelectClauseSyntax, SelectClauseSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SelectClauseSyntax, SelectClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SelectClauseSyntax, SelectClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, SelectClauseSyntax, SelectClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SelectClauseSyntax, SelectClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SelectClauseSyntax original, SelectClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, SelectClauseSyntax, SelectClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SelectClauseSyntax, SelectClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SelectClauseSyntax original, SelectClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="SelectClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SelectClauseSyntax, SelectClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SelectClauseSyntax original, SelectClauseSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SelectKeyword,
    		    Modified = modified.SelectKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SelectClauseSyntax original, SelectClauseSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SelectClauseSyntax, SelectClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SelectClauseSyntax, SelectClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, SelectClauseSyntax, SelectClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SelectClauseSyntax, SelectClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, SelectClauseSyntax, SelectClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SelectClauseSyntax, SelectClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="SelectClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SelectClauseSyntax, SelectClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as SelectClauseSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as SelectClauseSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class GroupClauseServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, GroupClauseSyntax, GroupClauseSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GroupClauseSyntax, GroupClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GroupClauseSyntax, GroupClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, GroupClauseSyntax, GroupClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GroupClauseSyntax, GroupClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, GroupClauseSyntax original, GroupClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, GroupClauseSyntax, GroupClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GroupClauseSyntax, GroupClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, GroupClauseSyntax original, GroupClauseSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="GroupClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GroupClauseSyntax, GroupClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, GroupClauseSyntax original, GroupClauseSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.GroupKeyword,
    		    Modified = modified.GroupKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ByKeyword,
    		    Modified = modified.ByKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, GroupClauseSyntax original, GroupClauseSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GroupClauseSyntax, GroupClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GroupClauseSyntax, GroupClauseSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, GroupClauseSyntax, GroupClauseSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GroupClauseSyntax, GroupClauseSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, GroupClauseSyntax, GroupClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GroupClauseSyntax, GroupClauseSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="GroupClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GroupClauseSyntax, GroupClauseSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as GroupClauseSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as GroupClauseSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class InterpolatedStringTextServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, InterpolatedStringTextSyntax, InterpolatedStringTextSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolatedStringTextSyntax, InterpolatedStringTextSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolatedStringTextSyntax, InterpolatedStringTextSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, InterpolatedStringTextSyntax, InterpolatedStringTextSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolatedStringTextSyntax, InterpolatedStringTextSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, InterpolatedStringTextSyntax original, InterpolatedStringTextSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, InterpolatedStringTextSyntax, InterpolatedStringTextSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolatedStringTextSyntax, InterpolatedStringTextSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, InterpolatedStringTextSyntax original, InterpolatedStringTextSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="InterpolatedStringTextSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolatedStringTextSyntax, InterpolatedStringTextSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, InterpolatedStringTextSyntax original, InterpolatedStringTextSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.TextToken,
    		    Modified = modified.TextToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, InterpolatedStringTextSyntax original, InterpolatedStringTextSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolatedStringTextSyntax, InterpolatedStringTextSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolatedStringTextSyntax, InterpolatedStringTextSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, InterpolatedStringTextSyntax, InterpolatedStringTextSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolatedStringTextSyntax, InterpolatedStringTextSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, InterpolatedStringTextSyntax, InterpolatedStringTextSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolatedStringTextSyntax, InterpolatedStringTextSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="InterpolatedStringTextSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolatedStringTextSyntax, InterpolatedStringTextSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as InterpolatedStringTextSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as InterpolatedStringTextSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class InterpolationServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, InterpolationSyntax, InterpolationSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationSyntax, InterpolationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationSyntax, InterpolationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, InterpolationSyntax, InterpolationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationSyntax, InterpolationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, InterpolationSyntax original, InterpolationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, InterpolationSyntax, InterpolationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationSyntax, InterpolationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, InterpolationSyntax original, InterpolationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="InterpolationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationSyntax, InterpolationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, InterpolationSyntax original, InterpolationSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, InterpolationSyntax original, InterpolationSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationSyntax, InterpolationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationSyntax, InterpolationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, InterpolationSyntax, InterpolationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationSyntax, InterpolationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, InterpolationSyntax, InterpolationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationSyntax, InterpolationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="InterpolationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, InterpolationSyntax, InterpolationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as InterpolationSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as InterpolationSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class BlockServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, BlockSyntax, BlockSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BlockSyntax, BlockSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BlockSyntax, BlockSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BlockSyntax, BlockSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BlockSyntax, BlockSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, BlockSyntax original, BlockSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BlockSyntax, BlockSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BlockSyntax, BlockSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, BlockSyntax original, BlockSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BlockSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BlockSyntax, BlockSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, BlockSyntax original, BlockSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, BlockSyntax original, BlockSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BlockSyntax, BlockSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BlockSyntax, BlockSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BlockSyntax, BlockSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BlockSyntax, BlockSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BlockSyntax, BlockSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BlockSyntax, BlockSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BlockSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BlockSyntax, BlockSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as BlockSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as BlockSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class LocalFunctionStatementServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, LocalFunctionStatementSyntax, LocalFunctionStatementSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LocalFunctionStatementSyntax, LocalFunctionStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LocalFunctionStatementSyntax, LocalFunctionStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LocalFunctionStatementSyntax, LocalFunctionStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LocalFunctionStatementSyntax, LocalFunctionStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, LocalFunctionStatementSyntax original, LocalFunctionStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LocalFunctionStatementSyntax, LocalFunctionStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LocalFunctionStatementSyntax, LocalFunctionStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, LocalFunctionStatementSyntax original, LocalFunctionStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LocalFunctionStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LocalFunctionStatementSyntax, LocalFunctionStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, LocalFunctionStatementSyntax original, LocalFunctionStatementSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && original.SemicolonToken.Kind() != SyntaxKind.None && 
    		   modified.SemicolonToken != null && modified.SemicolonToken.Kind() != SyntaxKind.None)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else
    		{
    			if(original.SemicolonToken != null && original.SemicolonToken.Kind() != SyntaxKind.None)
    				matchingSet.Originals.DisableMatching(original.SemicolonToken);
    			
    			if(modified.SemicolonToken != null && modified.SemicolonToken.Kind() != SyntaxKind.None)
    				matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    		}
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, LocalFunctionStatementSyntax original, LocalFunctionStatementSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LocalFunctionStatementSyntax, LocalFunctionStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LocalFunctionStatementSyntax, LocalFunctionStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LocalFunctionStatementSyntax, LocalFunctionStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LocalFunctionStatementSyntax, LocalFunctionStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LocalFunctionStatementSyntax, LocalFunctionStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LocalFunctionStatementSyntax, LocalFunctionStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LocalFunctionStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LocalFunctionStatementSyntax, LocalFunctionStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as LocalFunctionStatementSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as LocalFunctionStatementSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class LocalDeclarationStatementServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, LocalDeclarationStatementSyntax original, LocalDeclarationStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, LocalDeclarationStatementSyntax original, LocalDeclarationStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LocalDeclarationStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, LocalDeclarationStatementSyntax original, LocalDeclarationStatementSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, LocalDeclarationStatementSyntax original, LocalDeclarationStatementSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LocalDeclarationStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as LocalDeclarationStatementSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as LocalDeclarationStatementSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ExpressionStatementServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ExpressionStatementSyntax, ExpressionStatementSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExpressionStatementSyntax, ExpressionStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExpressionStatementSyntax, ExpressionStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ExpressionStatementSyntax, ExpressionStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExpressionStatementSyntax, ExpressionStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ExpressionStatementSyntax original, ExpressionStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ExpressionStatementSyntax, ExpressionStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExpressionStatementSyntax, ExpressionStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ExpressionStatementSyntax original, ExpressionStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ExpressionStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExpressionStatementSyntax, ExpressionStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ExpressionStatementSyntax original, ExpressionStatementSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ExpressionStatementSyntax original, ExpressionStatementSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExpressionStatementSyntax, ExpressionStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExpressionStatementSyntax, ExpressionStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ExpressionStatementSyntax, ExpressionStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExpressionStatementSyntax, ExpressionStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ExpressionStatementSyntax, ExpressionStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExpressionStatementSyntax, ExpressionStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ExpressionStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ExpressionStatementSyntax, ExpressionStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ExpressionStatementSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ExpressionStatementSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class EmptyStatementServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, EmptyStatementSyntax, EmptyStatementSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EmptyStatementSyntax, EmptyStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EmptyStatementSyntax, EmptyStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EmptyStatementSyntax, EmptyStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EmptyStatementSyntax, EmptyStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, EmptyStatementSyntax original, EmptyStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EmptyStatementSyntax, EmptyStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EmptyStatementSyntax, EmptyStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, EmptyStatementSyntax original, EmptyStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EmptyStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EmptyStatementSyntax, EmptyStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, EmptyStatementSyntax original, EmptyStatementSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, EmptyStatementSyntax original, EmptyStatementSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EmptyStatementSyntax, EmptyStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EmptyStatementSyntax, EmptyStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EmptyStatementSyntax, EmptyStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EmptyStatementSyntax, EmptyStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, EmptyStatementSyntax, EmptyStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EmptyStatementSyntax, EmptyStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EmptyStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, EmptyStatementSyntax, EmptyStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as EmptyStatementSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as EmptyStatementSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class LabeledStatementServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, LabeledStatementSyntax, LabeledStatementSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LabeledStatementSyntax, LabeledStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LabeledStatementSyntax, LabeledStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LabeledStatementSyntax, LabeledStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LabeledStatementSyntax, LabeledStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, LabeledStatementSyntax original, LabeledStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LabeledStatementSyntax, LabeledStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LabeledStatementSyntax, LabeledStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, LabeledStatementSyntax original, LabeledStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LabeledStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LabeledStatementSyntax, LabeledStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, LabeledStatementSyntax original, LabeledStatementSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, LabeledStatementSyntax original, LabeledStatementSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LabeledStatementSyntax, LabeledStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LabeledStatementSyntax, LabeledStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LabeledStatementSyntax, LabeledStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LabeledStatementSyntax, LabeledStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LabeledStatementSyntax, LabeledStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LabeledStatementSyntax, LabeledStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LabeledStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LabeledStatementSyntax, LabeledStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as LabeledStatementSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as LabeledStatementSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class GotoStatementServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, GotoStatementSyntax, GotoStatementSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GotoStatementSyntax, GotoStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GotoStatementSyntax, GotoStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, GotoStatementSyntax, GotoStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GotoStatementSyntax, GotoStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, GotoStatementSyntax original, GotoStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, GotoStatementSyntax, GotoStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GotoStatementSyntax, GotoStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, GotoStatementSyntax original, GotoStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="GotoStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GotoStatementSyntax, GotoStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, GotoStatementSyntax original, GotoStatementSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.GotoKeyword,
    		    Modified = modified.GotoKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CaseOrDefaultKeyword,
    		    Modified = modified.CaseOrDefaultKeyword
    		};
    		if(original.CaseOrDefaultKeyword != null && original.CaseOrDefaultKeyword.Kind() != SyntaxKind.None && 
    		   modified.CaseOrDefaultKeyword != null && modified.CaseOrDefaultKeyword.Kind() != SyntaxKind.None)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else
    		{
    			if(original.CaseOrDefaultKeyword != null && original.CaseOrDefaultKeyword.Kind() != SyntaxKind.None)
    				matchingSet.Originals.DisableMatching(original.CaseOrDefaultKeyword);
    			
    			if(modified.CaseOrDefaultKeyword != null && modified.CaseOrDefaultKeyword.Kind() != SyntaxKind.None)
    				matchingSet.Modifieds.DisableMatching(modified.CaseOrDefaultKeyword);
    		}
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, GotoStatementSyntax original, GotoStatementSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GotoStatementSyntax, GotoStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GotoStatementSyntax, GotoStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, GotoStatementSyntax, GotoStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GotoStatementSyntax, GotoStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, GotoStatementSyntax, GotoStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GotoStatementSyntax, GotoStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="GotoStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, GotoStatementSyntax, GotoStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as GotoStatementSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as GotoStatementSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class BreakStatementServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, BreakStatementSyntax, BreakStatementSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BreakStatementSyntax, BreakStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BreakStatementSyntax, BreakStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BreakStatementSyntax, BreakStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BreakStatementSyntax, BreakStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, BreakStatementSyntax original, BreakStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BreakStatementSyntax, BreakStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BreakStatementSyntax, BreakStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, BreakStatementSyntax original, BreakStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BreakStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BreakStatementSyntax, BreakStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, BreakStatementSyntax original, BreakStatementSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.BreakKeyword,
    		    Modified = modified.BreakKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, BreakStatementSyntax original, BreakStatementSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BreakStatementSyntax, BreakStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BreakStatementSyntax, BreakStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BreakStatementSyntax, BreakStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BreakStatementSyntax, BreakStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, BreakStatementSyntax, BreakStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BreakStatementSyntax, BreakStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BreakStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, BreakStatementSyntax, BreakStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as BreakStatementSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as BreakStatementSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ContinueStatementServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ContinueStatementSyntax, ContinueStatementSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ContinueStatementSyntax, ContinueStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ContinueStatementSyntax, ContinueStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ContinueStatementSyntax, ContinueStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ContinueStatementSyntax, ContinueStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ContinueStatementSyntax original, ContinueStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ContinueStatementSyntax, ContinueStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ContinueStatementSyntax, ContinueStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ContinueStatementSyntax original, ContinueStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ContinueStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ContinueStatementSyntax, ContinueStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ContinueStatementSyntax original, ContinueStatementSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ContinueKeyword,
    		    Modified = modified.ContinueKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ContinueStatementSyntax original, ContinueStatementSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ContinueStatementSyntax, ContinueStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ContinueStatementSyntax, ContinueStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ContinueStatementSyntax, ContinueStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ContinueStatementSyntax, ContinueStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ContinueStatementSyntax, ContinueStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ContinueStatementSyntax, ContinueStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ContinueStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ContinueStatementSyntax, ContinueStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ContinueStatementSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ContinueStatementSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ReturnStatementServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ReturnStatementSyntax, ReturnStatementSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ReturnStatementSyntax, ReturnStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ReturnStatementSyntax, ReturnStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ReturnStatementSyntax, ReturnStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ReturnStatementSyntax, ReturnStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ReturnStatementSyntax original, ReturnStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ReturnStatementSyntax, ReturnStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ReturnStatementSyntax, ReturnStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ReturnStatementSyntax original, ReturnStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ReturnStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ReturnStatementSyntax, ReturnStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ReturnStatementSyntax original, ReturnStatementSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ReturnKeyword,
    		    Modified = modified.ReturnKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ReturnStatementSyntax original, ReturnStatementSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ReturnStatementSyntax, ReturnStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ReturnStatementSyntax, ReturnStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ReturnStatementSyntax, ReturnStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ReturnStatementSyntax, ReturnStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ReturnStatementSyntax, ReturnStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ReturnStatementSyntax, ReturnStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ReturnStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ReturnStatementSyntax, ReturnStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ReturnStatementSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ReturnStatementSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ThrowStatementServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ThrowStatementSyntax, ThrowStatementSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThrowStatementSyntax, ThrowStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThrowStatementSyntax, ThrowStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ThrowStatementSyntax, ThrowStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThrowStatementSyntax, ThrowStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ThrowStatementSyntax original, ThrowStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ThrowStatementSyntax, ThrowStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThrowStatementSyntax, ThrowStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ThrowStatementSyntax original, ThrowStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ThrowStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThrowStatementSyntax, ThrowStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ThrowStatementSyntax original, ThrowStatementSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ThrowKeyword,
    		    Modified = modified.ThrowKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ThrowStatementSyntax original, ThrowStatementSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThrowStatementSyntax, ThrowStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThrowStatementSyntax, ThrowStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ThrowStatementSyntax, ThrowStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThrowStatementSyntax, ThrowStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ThrowStatementSyntax, ThrowStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThrowStatementSyntax, ThrowStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ThrowStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ThrowStatementSyntax, ThrowStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ThrowStatementSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ThrowStatementSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class YieldStatementServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, YieldStatementSyntax, YieldStatementSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, YieldStatementSyntax, YieldStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, YieldStatementSyntax, YieldStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, YieldStatementSyntax, YieldStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, YieldStatementSyntax, YieldStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, YieldStatementSyntax original, YieldStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, YieldStatementSyntax, YieldStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, YieldStatementSyntax, YieldStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, YieldStatementSyntax original, YieldStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="YieldStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, YieldStatementSyntax, YieldStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, YieldStatementSyntax original, YieldStatementSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.YieldKeyword,
    		    Modified = modified.YieldKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ReturnOrBreakKeyword,
    		    Modified = modified.ReturnOrBreakKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, YieldStatementSyntax original, YieldStatementSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, YieldStatementSyntax, YieldStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, YieldStatementSyntax, YieldStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, YieldStatementSyntax, YieldStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, YieldStatementSyntax, YieldStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, YieldStatementSyntax, YieldStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, YieldStatementSyntax, YieldStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="YieldStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, YieldStatementSyntax, YieldStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as YieldStatementSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as YieldStatementSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class WhileStatementServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, WhileStatementSyntax, WhileStatementSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhileStatementSyntax, WhileStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhileStatementSyntax, WhileStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, WhileStatementSyntax, WhileStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhileStatementSyntax, WhileStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, WhileStatementSyntax original, WhileStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, WhileStatementSyntax, WhileStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhileStatementSyntax, WhileStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, WhileStatementSyntax original, WhileStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="WhileStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhileStatementSyntax, WhileStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, WhileStatementSyntax original, WhileStatementSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.WhileKeyword,
    		    Modified = modified.WhileKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, WhileStatementSyntax original, WhileStatementSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhileStatementSyntax, WhileStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhileStatementSyntax, WhileStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, WhileStatementSyntax, WhileStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhileStatementSyntax, WhileStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, WhileStatementSyntax, WhileStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhileStatementSyntax, WhileStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="WhileStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, WhileStatementSyntax, WhileStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as WhileStatementSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as WhileStatementSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class DoStatementServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, DoStatementSyntax, DoStatementSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DoStatementSyntax, DoStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DoStatementSyntax, DoStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DoStatementSyntax, DoStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DoStatementSyntax, DoStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, DoStatementSyntax original, DoStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DoStatementSyntax, DoStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DoStatementSyntax, DoStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, DoStatementSyntax original, DoStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DoStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DoStatementSyntax, DoStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, DoStatementSyntax original, DoStatementSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.DoKeyword,
    		    Modified = modified.DoKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.WhileKeyword,
    		    Modified = modified.WhileKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, DoStatementSyntax original, DoStatementSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DoStatementSyntax, DoStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DoStatementSyntax, DoStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DoStatementSyntax, DoStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DoStatementSyntax, DoStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DoStatementSyntax, DoStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DoStatementSyntax, DoStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DoStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DoStatementSyntax, DoStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as DoStatementSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as DoStatementSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ForStatementServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ForStatementSyntax, ForStatementSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForStatementSyntax, ForStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForStatementSyntax, ForStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ForStatementSyntax, ForStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForStatementSyntax, ForStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ForStatementSyntax original, ForStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ForStatementSyntax, ForStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForStatementSyntax, ForStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ForStatementSyntax original, ForStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ForStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForStatementSyntax, ForStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ForStatementSyntax original, ForStatementSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ForKeyword,
    		    Modified = modified.ForKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.FirstSemicolonToken,
    		    Modified = modified.FirstSemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SecondSemicolonToken,
    		    Modified = modified.SecondSemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ForStatementSyntax original, ForStatementSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForStatementSyntax, ForStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForStatementSyntax, ForStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ForStatementSyntax, ForStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForStatementSyntax, ForStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ForStatementSyntax, ForStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForStatementSyntax, ForStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ForStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForStatementSyntax, ForStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ForStatementSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ForStatementSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class UsingStatementServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, UsingStatementSyntax, UsingStatementSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UsingStatementSyntax, UsingStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UsingStatementSyntax, UsingStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, UsingStatementSyntax, UsingStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UsingStatementSyntax, UsingStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, UsingStatementSyntax original, UsingStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, UsingStatementSyntax, UsingStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UsingStatementSyntax, UsingStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, UsingStatementSyntax original, UsingStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="UsingStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UsingStatementSyntax, UsingStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, UsingStatementSyntax original, UsingStatementSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.UsingKeyword,
    		    Modified = modified.UsingKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, UsingStatementSyntax original, UsingStatementSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UsingStatementSyntax, UsingStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UsingStatementSyntax, UsingStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, UsingStatementSyntax, UsingStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UsingStatementSyntax, UsingStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, UsingStatementSyntax, UsingStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UsingStatementSyntax, UsingStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="UsingStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UsingStatementSyntax, UsingStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as UsingStatementSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as UsingStatementSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class FixedStatementServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, FixedStatementSyntax, FixedStatementSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FixedStatementSyntax, FixedStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FixedStatementSyntax, FixedStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, FixedStatementSyntax, FixedStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FixedStatementSyntax, FixedStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, FixedStatementSyntax original, FixedStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, FixedStatementSyntax, FixedStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FixedStatementSyntax, FixedStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, FixedStatementSyntax original, FixedStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="FixedStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FixedStatementSyntax, FixedStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, FixedStatementSyntax original, FixedStatementSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.FixedKeyword,
    		    Modified = modified.FixedKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, FixedStatementSyntax original, FixedStatementSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FixedStatementSyntax, FixedStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FixedStatementSyntax, FixedStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, FixedStatementSyntax, FixedStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FixedStatementSyntax, FixedStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, FixedStatementSyntax, FixedStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FixedStatementSyntax, FixedStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="FixedStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, FixedStatementSyntax, FixedStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as FixedStatementSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as FixedStatementSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class CheckedStatementServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, CheckedStatementSyntax, CheckedStatementSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CheckedStatementSyntax, CheckedStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CheckedStatementSyntax, CheckedStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CheckedStatementSyntax, CheckedStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CheckedStatementSyntax, CheckedStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, CheckedStatementSyntax original, CheckedStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CheckedStatementSyntax, CheckedStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CheckedStatementSyntax, CheckedStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, CheckedStatementSyntax original, CheckedStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CheckedStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CheckedStatementSyntax, CheckedStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, CheckedStatementSyntax original, CheckedStatementSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, CheckedStatementSyntax original, CheckedStatementSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CheckedStatementSyntax, CheckedStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CheckedStatementSyntax, CheckedStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CheckedStatementSyntax, CheckedStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CheckedStatementSyntax, CheckedStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CheckedStatementSyntax, CheckedStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CheckedStatementSyntax, CheckedStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CheckedStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CheckedStatementSyntax, CheckedStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as CheckedStatementSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as CheckedStatementSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class UnsafeStatementServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, UnsafeStatementSyntax, UnsafeStatementSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UnsafeStatementSyntax, UnsafeStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UnsafeStatementSyntax, UnsafeStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, UnsafeStatementSyntax, UnsafeStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UnsafeStatementSyntax, UnsafeStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, UnsafeStatementSyntax original, UnsafeStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, UnsafeStatementSyntax, UnsafeStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UnsafeStatementSyntax, UnsafeStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, UnsafeStatementSyntax original, UnsafeStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="UnsafeStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UnsafeStatementSyntax, UnsafeStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, UnsafeStatementSyntax original, UnsafeStatementSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.UnsafeKeyword,
    		    Modified = modified.UnsafeKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, UnsafeStatementSyntax original, UnsafeStatementSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UnsafeStatementSyntax, UnsafeStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UnsafeStatementSyntax, UnsafeStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, UnsafeStatementSyntax, UnsafeStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UnsafeStatementSyntax, UnsafeStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, UnsafeStatementSyntax, UnsafeStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UnsafeStatementSyntax, UnsafeStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="UnsafeStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, UnsafeStatementSyntax, UnsafeStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as UnsafeStatementSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as UnsafeStatementSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class LockStatementServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, LockStatementSyntax, LockStatementSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LockStatementSyntax, LockStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LockStatementSyntax, LockStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LockStatementSyntax, LockStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LockStatementSyntax, LockStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, LockStatementSyntax original, LockStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LockStatementSyntax, LockStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LockStatementSyntax, LockStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, LockStatementSyntax original, LockStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LockStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LockStatementSyntax, LockStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, LockStatementSyntax original, LockStatementSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LockKeyword,
    		    Modified = modified.LockKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, LockStatementSyntax original, LockStatementSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LockStatementSyntax, LockStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LockStatementSyntax, LockStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LockStatementSyntax, LockStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LockStatementSyntax, LockStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, LockStatementSyntax, LockStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LockStatementSyntax, LockStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LockStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, LockStatementSyntax, LockStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as LockStatementSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as LockStatementSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class IfStatementServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, IfStatementSyntax, IfStatementSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IfStatementSyntax, IfStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IfStatementSyntax, IfStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, IfStatementSyntax, IfStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IfStatementSyntax, IfStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, IfStatementSyntax original, IfStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, IfStatementSyntax, IfStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IfStatementSyntax, IfStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, IfStatementSyntax original, IfStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="IfStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IfStatementSyntax, IfStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, IfStatementSyntax original, IfStatementSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.IfKeyword,
    		    Modified = modified.IfKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, IfStatementSyntax original, IfStatementSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IfStatementSyntax, IfStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IfStatementSyntax, IfStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, IfStatementSyntax, IfStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IfStatementSyntax, IfStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, IfStatementSyntax, IfStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IfStatementSyntax, IfStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="IfStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, IfStatementSyntax, IfStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as IfStatementSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as IfStatementSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class SwitchStatementServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, SwitchStatementSyntax, SwitchStatementSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SwitchStatementSyntax, SwitchStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SwitchStatementSyntax, SwitchStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, SwitchStatementSyntax, SwitchStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SwitchStatementSyntax, SwitchStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SwitchStatementSyntax original, SwitchStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, SwitchStatementSyntax, SwitchStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SwitchStatementSyntax, SwitchStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SwitchStatementSyntax original, SwitchStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="SwitchStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SwitchStatementSyntax, SwitchStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SwitchStatementSyntax original, SwitchStatementSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SwitchKeyword,
    		    Modified = modified.SwitchKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SwitchStatementSyntax original, SwitchStatementSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SwitchStatementSyntax, SwitchStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SwitchStatementSyntax, SwitchStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, SwitchStatementSyntax, SwitchStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SwitchStatementSyntax, SwitchStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, SwitchStatementSyntax, SwitchStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SwitchStatementSyntax, SwitchStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="SwitchStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SwitchStatementSyntax, SwitchStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as SwitchStatementSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as SwitchStatementSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class TryStatementServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, TryStatementSyntax, TryStatementSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TryStatementSyntax, TryStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TryStatementSyntax, TryStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TryStatementSyntax, TryStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TryStatementSyntax, TryStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, TryStatementSyntax original, TryStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TryStatementSyntax, TryStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TryStatementSyntax, TryStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, TryStatementSyntax original, TryStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TryStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TryStatementSyntax, TryStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, TryStatementSyntax original, TryStatementSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.TryKeyword,
    		    Modified = modified.TryKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, TryStatementSyntax original, TryStatementSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TryStatementSyntax, TryStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TryStatementSyntax, TryStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TryStatementSyntax, TryStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TryStatementSyntax, TryStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, TryStatementSyntax, TryStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TryStatementSyntax, TryStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TryStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, TryStatementSyntax, TryStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as TryStatementSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as TryStatementSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ForEachStatementServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ForEachStatementSyntax, ForEachStatementSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForEachStatementSyntax, ForEachStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForEachStatementSyntax, ForEachStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ForEachStatementSyntax, ForEachStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForEachStatementSyntax, ForEachStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ForEachStatementSyntax original, ForEachStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ForEachStatementSyntax, ForEachStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForEachStatementSyntax, ForEachStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ForEachStatementSyntax original, ForEachStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ForEachStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForEachStatementSyntax, ForEachStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ForEachStatementSyntax original, ForEachStatementSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ForEachKeyword,
    		    Modified = modified.ForEachKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.InKeyword,
    		    Modified = modified.InKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ForEachStatementSyntax original, ForEachStatementSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForEachStatementSyntax, ForEachStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForEachStatementSyntax, ForEachStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ForEachStatementSyntax, ForEachStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForEachStatementSyntax, ForEachStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ForEachStatementSyntax, ForEachStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForEachStatementSyntax, ForEachStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ForEachStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForEachStatementSyntax, ForEachStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ForEachStatementSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ForEachStatementSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ForEachVariableStatementServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ForEachVariableStatementSyntax, ForEachVariableStatementSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForEachVariableStatementSyntax, ForEachVariableStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForEachVariableStatementSyntax, ForEachVariableStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ForEachVariableStatementSyntax, ForEachVariableStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForEachVariableStatementSyntax, ForEachVariableStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ForEachVariableStatementSyntax original, ForEachVariableStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ForEachVariableStatementSyntax, ForEachVariableStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForEachVariableStatementSyntax, ForEachVariableStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ForEachVariableStatementSyntax original, ForEachVariableStatementSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ForEachVariableStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForEachVariableStatementSyntax, ForEachVariableStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ForEachVariableStatementSyntax original, ForEachVariableStatementSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ForEachKeyword,
    		    Modified = modified.ForEachKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.InKeyword,
    		    Modified = modified.InKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ForEachVariableStatementSyntax original, ForEachVariableStatementSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForEachVariableStatementSyntax, ForEachVariableStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForEachVariableStatementSyntax, ForEachVariableStatementSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ForEachVariableStatementSyntax, ForEachVariableStatementSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForEachVariableStatementSyntax, ForEachVariableStatementSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ForEachVariableStatementSyntax, ForEachVariableStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForEachVariableStatementSyntax, ForEachVariableStatementSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ForEachVariableStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ForEachVariableStatementSyntax, ForEachVariableStatementSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ForEachVariableStatementSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ForEachVariableStatementSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class SingleVariableDesignationServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, SingleVariableDesignationSyntax, SingleVariableDesignationSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SingleVariableDesignationSyntax, SingleVariableDesignationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SingleVariableDesignationSyntax, SingleVariableDesignationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, SingleVariableDesignationSyntax, SingleVariableDesignationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SingleVariableDesignationSyntax, SingleVariableDesignationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SingleVariableDesignationSyntax original, SingleVariableDesignationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, SingleVariableDesignationSyntax, SingleVariableDesignationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SingleVariableDesignationSyntax, SingleVariableDesignationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SingleVariableDesignationSyntax original, SingleVariableDesignationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="SingleVariableDesignationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SingleVariableDesignationSyntax, SingleVariableDesignationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SingleVariableDesignationSyntax original, SingleVariableDesignationSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SingleVariableDesignationSyntax original, SingleVariableDesignationSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SingleVariableDesignationSyntax, SingleVariableDesignationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SingleVariableDesignationSyntax, SingleVariableDesignationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, SingleVariableDesignationSyntax, SingleVariableDesignationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SingleVariableDesignationSyntax, SingleVariableDesignationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, SingleVariableDesignationSyntax, SingleVariableDesignationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SingleVariableDesignationSyntax, SingleVariableDesignationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="SingleVariableDesignationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, SingleVariableDesignationSyntax, SingleVariableDesignationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as SingleVariableDesignationSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as SingleVariableDesignationSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class DiscardDesignationServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, DiscardDesignationSyntax, DiscardDesignationSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DiscardDesignationSyntax, DiscardDesignationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DiscardDesignationSyntax, DiscardDesignationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DiscardDesignationSyntax, DiscardDesignationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DiscardDesignationSyntax, DiscardDesignationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, DiscardDesignationSyntax original, DiscardDesignationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DiscardDesignationSyntax, DiscardDesignationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DiscardDesignationSyntax, DiscardDesignationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, DiscardDesignationSyntax original, DiscardDesignationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DiscardDesignationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DiscardDesignationSyntax, DiscardDesignationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, DiscardDesignationSyntax original, DiscardDesignationSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.UnderscoreToken,
    		    Modified = modified.UnderscoreToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, DiscardDesignationSyntax original, DiscardDesignationSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DiscardDesignationSyntax, DiscardDesignationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DiscardDesignationSyntax, DiscardDesignationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DiscardDesignationSyntax, DiscardDesignationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DiscardDesignationSyntax, DiscardDesignationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DiscardDesignationSyntax, DiscardDesignationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DiscardDesignationSyntax, DiscardDesignationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DiscardDesignationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DiscardDesignationSyntax, DiscardDesignationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as DiscardDesignationSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as DiscardDesignationSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class ParenthesizedVariableDesignationServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, ParenthesizedVariableDesignationSyntax original, ParenthesizedVariableDesignationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, ParenthesizedVariableDesignationSyntax original, ParenthesizedVariableDesignationSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ParenthesizedVariableDesignationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, ParenthesizedVariableDesignationSyntax original, ParenthesizedVariableDesignationSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, ParenthesizedVariableDesignationSyntax original, ParenthesizedVariableDesignationSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ParenthesizedVariableDesignationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as ParenthesizedVariableDesignationSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as ParenthesizedVariableDesignationSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class CasePatternSwitchLabelServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, CasePatternSwitchLabelSyntax original, CasePatternSwitchLabelSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, CasePatternSwitchLabelSyntax original, CasePatternSwitchLabelSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CasePatternSwitchLabelSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, CasePatternSwitchLabelSyntax original, CasePatternSwitchLabelSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, CasePatternSwitchLabelSyntax original, CasePatternSwitchLabelSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CasePatternSwitchLabelSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as CasePatternSwitchLabelSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as CasePatternSwitchLabelSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class CaseSwitchLabelServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, CaseSwitchLabelSyntax, CaseSwitchLabelSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CaseSwitchLabelSyntax, CaseSwitchLabelSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CaseSwitchLabelSyntax, CaseSwitchLabelSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CaseSwitchLabelSyntax, CaseSwitchLabelSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CaseSwitchLabelSyntax, CaseSwitchLabelSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, CaseSwitchLabelSyntax original, CaseSwitchLabelSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CaseSwitchLabelSyntax, CaseSwitchLabelSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CaseSwitchLabelSyntax, CaseSwitchLabelSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, CaseSwitchLabelSyntax original, CaseSwitchLabelSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CaseSwitchLabelSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CaseSwitchLabelSyntax, CaseSwitchLabelSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, CaseSwitchLabelSyntax original, CaseSwitchLabelSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, CaseSwitchLabelSyntax original, CaseSwitchLabelSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CaseSwitchLabelSyntax, CaseSwitchLabelSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CaseSwitchLabelSyntax, CaseSwitchLabelSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CaseSwitchLabelSyntax, CaseSwitchLabelSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CaseSwitchLabelSyntax, CaseSwitchLabelSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, CaseSwitchLabelSyntax, CaseSwitchLabelSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CaseSwitchLabelSyntax, CaseSwitchLabelSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CaseSwitchLabelSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, CaseSwitchLabelSyntax, CaseSwitchLabelSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as CaseSwitchLabelSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as CaseSwitchLabelSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
    partial class DefaultSwitchLabelServiceProvider 
    : IPairwisable<SyntaxNodeOrToken?, DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax>,
      IPairwisable<SyntaxNodeOrToken?, SyntaxNodeOrToken?, SyntaxNodeOrToken?>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, DefaultSwitchLabelSyntax original, DefaultSwitchLabelSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, DefaultSwitchLabelSyntax original, DefaultSwitchLabelSyntax modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DefaultSwitchLabelSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, DefaultSwitchLabelSyntax original, DefaultSwitchLabelSyntax modified)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, DefaultSwitchLabelSyntax original, DefaultSwitchLabelSyntax modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax)"/> is not executed and <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax)"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="PartnersCore(MatchingContext{SyntaxNodeOrToken?}, DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax)"/>.</param>
        partial void PartnersAfter(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DefaultSwitchLabelSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <remarks>This is the default implementation for <see cref="Partners(MatchingContext{SyntaxNodeOrToken?}, DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax)"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		var o = original.Value.IsNode ? original.Value.AsNode() as DefaultSwitchLabelSyntax : null;
    		var m = modified.Value.IsNode ? modified.Value.AsNode() as DefaultSwitchLabelSyntax : null;
    		if(o != null && m != null)
    		{
    		   foreach (var pairwiseMatch in this.Partners(context, o, m))
               {
                    yield return pairwiseMatch;
               }
    		}
    		
    		yield break;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein the matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        public IEnumerable<MatchInfo<SyntaxNodeOrToken?>> Partners(MatchingContext<SyntaxNodeOrToken?> context, SyntaxNodeOrToken? original, SyntaxNodeOrToken? modified)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(context, original, modified, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(context, original, modified);
    		PartnersAfter(context, original, modified, ref result);
    		return result;
    	}
    }
    
}
// Generated helper templates
// Generated items
