
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;
using Jawilliam.CDF.Approach.Flad;
using Jawilliam.CDF.Approach.Awareness;
using Jawilliam.CDF.Approach;
using Jawilliam.CDF.Approach.Services;
using Jawilliam.CDF.Approach.Criterions;

namespace Jawilliam.CDF.CSharp.Flad
{
    partial class SyntaxTokenServiceProvider : INameEqualityCondition<SyntaxToken, SyntaxToken> { }
    partial class LanguageServiceProvider { }
    
    partial class NameEqualsServiceProvider : IPartnership<SyntaxNodeOrToken?, NameEqualsSyntax, NameEqualsSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(NameEqualsSyntax, NameEqualsSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, NameEqualsSyntax, NameEqualsSyntax}.Partners(NameEqualsSyntax, NameEqualsSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(NameEqualsSyntax, NameEqualsSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, NameEqualsSyntax, NameEqualsSyntax}.Partners(NameEqualsSyntax, NameEqualsSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(NameEqualsSyntax original, NameEqualsSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(NameEqualsSyntax, NameEqualsSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, NameEqualsSyntax, NameEqualsSyntax}.Partners(NameEqualsSyntax, NameEqualsSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(NameEqualsSyntax original, NameEqualsSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="NameEqualsSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, NameEqualsSyntax, NameEqualsSyntax}.Partners(NameEqualsSyntax, NameEqualsSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(NameEqualsSyntax original, NameEqualsSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EqualsToken,
    		    Modified = modified.EqualsToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, NameEqualsSyntax, NameEqualsSyntax>.Partners(NameEqualsSyntax original, NameEqualsSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class TypeParameterListServiceProvider : IPartnership<SyntaxNodeOrToken?, TypeParameterListSyntax, TypeParameterListSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(TypeParameterListSyntax, TypeParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, TypeParameterListSyntax, TypeParameterListSyntax}.Partners(TypeParameterListSyntax, TypeParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(TypeParameterListSyntax, TypeParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, TypeParameterListSyntax, TypeParameterListSyntax}.Partners(TypeParameterListSyntax, TypeParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(TypeParameterListSyntax original, TypeParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(TypeParameterListSyntax, TypeParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, TypeParameterListSyntax, TypeParameterListSyntax}.Partners(TypeParameterListSyntax, TypeParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(TypeParameterListSyntax original, TypeParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TypeParameterListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, TypeParameterListSyntax, TypeParameterListSyntax}.Partners(TypeParameterListSyntax, TypeParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(TypeParameterListSyntax original, TypeParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LessThanToken,
    		    Modified = modified.LessThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.GreaterThanToken,
    		    Modified = modified.GreaterThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, TypeParameterListSyntax, TypeParameterListSyntax>.Partners(TypeParameterListSyntax original, TypeParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class TypeParameterServiceProvider : IPartnership<SyntaxNodeOrToken?, TypeParameterSyntax, TypeParameterSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(TypeParameterSyntax, TypeParameterSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, TypeParameterSyntax, TypeParameterSyntax}.Partners(TypeParameterSyntax, TypeParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(TypeParameterSyntax, TypeParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, TypeParameterSyntax, TypeParameterSyntax}.Partners(TypeParameterSyntax, TypeParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(TypeParameterSyntax original, TypeParameterSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(TypeParameterSyntax, TypeParameterSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, TypeParameterSyntax, TypeParameterSyntax}.Partners(TypeParameterSyntax, TypeParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(TypeParameterSyntax original, TypeParameterSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TypeParameterSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, TypeParameterSyntax, TypeParameterSyntax}.Partners(TypeParameterSyntax, TypeParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(TypeParameterSyntax original, TypeParameterSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.VarianceKeyword,
    		    Modified = modified.VarianceKeyword
    		};
    		if(original.VarianceKeyword != null && modified.VarianceKeyword != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.VarianceKeyword != null)
    			matchingSet.Originals.DisableMatching(original.VarianceKeyword);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.VarianceKeyword);
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, TypeParameterSyntax, TypeParameterSyntax>.Partners(TypeParameterSyntax original, TypeParameterSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class BaseListServiceProvider : IPartnership<SyntaxNodeOrToken?, BaseListSyntax, BaseListSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(BaseListSyntax, BaseListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, BaseListSyntax, BaseListSyntax}.Partners(BaseListSyntax, BaseListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(BaseListSyntax, BaseListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, BaseListSyntax, BaseListSyntax}.Partners(BaseListSyntax, BaseListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(BaseListSyntax original, BaseListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(BaseListSyntax, BaseListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, BaseListSyntax, BaseListSyntax}.Partners(BaseListSyntax, BaseListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(BaseListSyntax original, BaseListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BaseListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, BaseListSyntax, BaseListSyntax}.Partners(BaseListSyntax, BaseListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(BaseListSyntax original, BaseListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, BaseListSyntax, BaseListSyntax>.Partners(BaseListSyntax original, BaseListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class TypeParameterConstraintClauseServiceProvider : IPartnership<SyntaxNodeOrToken?, TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax}.Partners(TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax}.Partners(TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(TypeParameterConstraintClauseSyntax original, TypeParameterConstraintClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax}.Partners(TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(TypeParameterConstraintClauseSyntax original, TypeParameterConstraintClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TypeParameterConstraintClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax}.Partners(TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(TypeParameterConstraintClauseSyntax original, TypeParameterConstraintClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.WhereKeyword,
    		    Modified = modified.WhereKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, TypeParameterConstraintClauseSyntax, TypeParameterConstraintClauseSyntax>.Partners(TypeParameterConstraintClauseSyntax original, TypeParameterConstraintClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ExplicitInterfaceSpecifierServiceProvider : IPartnership<SyntaxNodeOrToken?, ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax}.Partners(ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax}.Partners(ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ExplicitInterfaceSpecifierSyntax original, ExplicitInterfaceSpecifierSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax}.Partners(ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ExplicitInterfaceSpecifierSyntax original, ExplicitInterfaceSpecifierSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ExplicitInterfaceSpecifierSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax}.Partners(ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ExplicitInterfaceSpecifierSyntax original, ExplicitInterfaceSpecifierSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.DotToken,
    		    Modified = modified.DotToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ExplicitInterfaceSpecifierSyntax, ExplicitInterfaceSpecifierSyntax>.Partners(ExplicitInterfaceSpecifierSyntax original, ExplicitInterfaceSpecifierSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ConstructorInitializerServiceProvider : IPartnership<SyntaxNodeOrToken?, ConstructorInitializerSyntax, ConstructorInitializerSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ConstructorInitializerSyntax, ConstructorInitializerSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ConstructorInitializerSyntax, ConstructorInitializerSyntax}.Partners(ConstructorInitializerSyntax, ConstructorInitializerSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ConstructorInitializerSyntax, ConstructorInitializerSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ConstructorInitializerSyntax, ConstructorInitializerSyntax}.Partners(ConstructorInitializerSyntax, ConstructorInitializerSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ConstructorInitializerSyntax original, ConstructorInitializerSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ConstructorInitializerSyntax, ConstructorInitializerSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ConstructorInitializerSyntax, ConstructorInitializerSyntax}.Partners(ConstructorInitializerSyntax, ConstructorInitializerSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ConstructorInitializerSyntax original, ConstructorInitializerSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ConstructorInitializerSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ConstructorInitializerSyntax, ConstructorInitializerSyntax}.Partners(ConstructorInitializerSyntax, ConstructorInitializerSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ConstructorInitializerSyntax original, ConstructorInitializerSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ThisOrBaseKeyword,
    		    Modified = modified.ThisOrBaseKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ConstructorInitializerSyntax, ConstructorInitializerSyntax>.Partners(ConstructorInitializerSyntax original, ConstructorInitializerSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ArrowExpressionClauseServiceProvider : IPartnership<SyntaxNodeOrToken?, ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax}.Partners(ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax}.Partners(ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ArrowExpressionClauseSyntax original, ArrowExpressionClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax}.Partners(ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ArrowExpressionClauseSyntax original, ArrowExpressionClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ArrowExpressionClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax}.Partners(ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ArrowExpressionClauseSyntax original, ArrowExpressionClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ArrowToken,
    		    Modified = modified.ArrowToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ArrowExpressionClauseSyntax, ArrowExpressionClauseSyntax>.Partners(ArrowExpressionClauseSyntax original, ArrowExpressionClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class AccessorListServiceProvider : IPartnership<SyntaxNodeOrToken?, AccessorListSyntax, AccessorListSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(AccessorListSyntax, AccessorListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, AccessorListSyntax, AccessorListSyntax}.Partners(AccessorListSyntax, AccessorListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(AccessorListSyntax, AccessorListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, AccessorListSyntax, AccessorListSyntax}.Partners(AccessorListSyntax, AccessorListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(AccessorListSyntax original, AccessorListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(AccessorListSyntax, AccessorListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, AccessorListSyntax, AccessorListSyntax}.Partners(AccessorListSyntax, AccessorListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(AccessorListSyntax original, AccessorListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AccessorListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, AccessorListSyntax, AccessorListSyntax}.Partners(AccessorListSyntax, AccessorListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(AccessorListSyntax original, AccessorListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, AccessorListSyntax, AccessorListSyntax>.Partners(AccessorListSyntax original, AccessorListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class AccessorDeclarationServiceProvider : IPartnership<SyntaxNodeOrToken?, AccessorDeclarationSyntax, AccessorDeclarationSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(AccessorDeclarationSyntax, AccessorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, AccessorDeclarationSyntax, AccessorDeclarationSyntax}.Partners(AccessorDeclarationSyntax, AccessorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(AccessorDeclarationSyntax, AccessorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, AccessorDeclarationSyntax, AccessorDeclarationSyntax}.Partners(AccessorDeclarationSyntax, AccessorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(AccessorDeclarationSyntax original, AccessorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(AccessorDeclarationSyntax, AccessorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, AccessorDeclarationSyntax, AccessorDeclarationSyntax}.Partners(AccessorDeclarationSyntax, AccessorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(AccessorDeclarationSyntax original, AccessorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AccessorDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, AccessorDeclarationSyntax, AccessorDeclarationSyntax}.Partners(AccessorDeclarationSyntax, AccessorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(AccessorDeclarationSyntax original, AccessorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && modified.SemicolonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.SemicolonToken != null)
    			matchingSet.Originals.DisableMatching(original.SemicolonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, AccessorDeclarationSyntax, AccessorDeclarationSyntax>.Partners(AccessorDeclarationSyntax original, AccessorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ParameterServiceProvider : IPartnership<SyntaxNodeOrToken?, ParameterSyntax, ParameterSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ParameterSyntax, ParameterSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ParameterSyntax, ParameterSyntax}.Partners(ParameterSyntax, ParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ParameterSyntax, ParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ParameterSyntax, ParameterSyntax}.Partners(ParameterSyntax, ParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ParameterSyntax original, ParameterSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ParameterSyntax, ParameterSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ParameterSyntax, ParameterSyntax}.Partners(ParameterSyntax, ParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ParameterSyntax original, ParameterSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ParameterSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ParameterSyntax, ParameterSyntax}.Partners(ParameterSyntax, ParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ParameterSyntax original, ParameterSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ParameterSyntax, ParameterSyntax>.Partners(ParameterSyntax original, ParameterSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class CrefParameterServiceProvider : IPartnership<SyntaxNodeOrToken?, CrefParameterSyntax, CrefParameterSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(CrefParameterSyntax, CrefParameterSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, CrefParameterSyntax, CrefParameterSyntax}.Partners(CrefParameterSyntax, CrefParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(CrefParameterSyntax, CrefParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, CrefParameterSyntax, CrefParameterSyntax}.Partners(CrefParameterSyntax, CrefParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(CrefParameterSyntax original, CrefParameterSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(CrefParameterSyntax, CrefParameterSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, CrefParameterSyntax, CrefParameterSyntax}.Partners(CrefParameterSyntax, CrefParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(CrefParameterSyntax original, CrefParameterSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CrefParameterSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, CrefParameterSyntax, CrefParameterSyntax}.Partners(CrefParameterSyntax, CrefParameterSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(CrefParameterSyntax original, CrefParameterSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.RefOrOutKeyword,
    		    Modified = modified.RefOrOutKeyword
    		};
    		if(original.RefOrOutKeyword != null && modified.RefOrOutKeyword != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.RefOrOutKeyword != null)
    			matchingSet.Originals.DisableMatching(original.RefOrOutKeyword);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.RefOrOutKeyword);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, CrefParameterSyntax, CrefParameterSyntax>.Partners(CrefParameterSyntax original, CrefParameterSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class XmlElementStartTagServiceProvider : IPartnership<SyntaxNodeOrToken?, XmlElementStartTagSyntax, XmlElementStartTagSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(XmlElementStartTagSyntax, XmlElementStartTagSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, XmlElementStartTagSyntax, XmlElementStartTagSyntax}.Partners(XmlElementStartTagSyntax, XmlElementStartTagSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(XmlElementStartTagSyntax, XmlElementStartTagSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, XmlElementStartTagSyntax, XmlElementStartTagSyntax}.Partners(XmlElementStartTagSyntax, XmlElementStartTagSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(XmlElementStartTagSyntax original, XmlElementStartTagSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(XmlElementStartTagSyntax, XmlElementStartTagSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, XmlElementStartTagSyntax, XmlElementStartTagSyntax}.Partners(XmlElementStartTagSyntax, XmlElementStartTagSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(XmlElementStartTagSyntax original, XmlElementStartTagSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlElementStartTagSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, XmlElementStartTagSyntax, XmlElementStartTagSyntax}.Partners(XmlElementStartTagSyntax, XmlElementStartTagSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(XmlElementStartTagSyntax original, XmlElementStartTagSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LessThanToken,
    		    Modified = modified.LessThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.GreaterThanToken,
    		    Modified = modified.GreaterThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, XmlElementStartTagSyntax, XmlElementStartTagSyntax>.Partners(XmlElementStartTagSyntax original, XmlElementStartTagSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class XmlElementEndTagServiceProvider : IPartnership<SyntaxNodeOrToken?, XmlElementEndTagSyntax, XmlElementEndTagSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(XmlElementEndTagSyntax, XmlElementEndTagSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, XmlElementEndTagSyntax, XmlElementEndTagSyntax}.Partners(XmlElementEndTagSyntax, XmlElementEndTagSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(XmlElementEndTagSyntax, XmlElementEndTagSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, XmlElementEndTagSyntax, XmlElementEndTagSyntax}.Partners(XmlElementEndTagSyntax, XmlElementEndTagSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(XmlElementEndTagSyntax original, XmlElementEndTagSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(XmlElementEndTagSyntax, XmlElementEndTagSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, XmlElementEndTagSyntax, XmlElementEndTagSyntax}.Partners(XmlElementEndTagSyntax, XmlElementEndTagSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(XmlElementEndTagSyntax original, XmlElementEndTagSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlElementEndTagSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, XmlElementEndTagSyntax, XmlElementEndTagSyntax}.Partners(XmlElementEndTagSyntax, XmlElementEndTagSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(XmlElementEndTagSyntax original, XmlElementEndTagSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LessThanSlashToken,
    		    Modified = modified.LessThanSlashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.GreaterThanToken,
    		    Modified = modified.GreaterThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, XmlElementEndTagSyntax, XmlElementEndTagSyntax>.Partners(XmlElementEndTagSyntax original, XmlElementEndTagSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class XmlNameServiceProvider : IPartnership<SyntaxNodeOrToken?, XmlNameSyntax, XmlNameSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(XmlNameSyntax, XmlNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, XmlNameSyntax, XmlNameSyntax}.Partners(XmlNameSyntax, XmlNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(XmlNameSyntax, XmlNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, XmlNameSyntax, XmlNameSyntax}.Partners(XmlNameSyntax, XmlNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(XmlNameSyntax original, XmlNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(XmlNameSyntax, XmlNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, XmlNameSyntax, XmlNameSyntax}.Partners(XmlNameSyntax, XmlNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(XmlNameSyntax original, XmlNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlNameSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, XmlNameSyntax, XmlNameSyntax}.Partners(XmlNameSyntax, XmlNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(XmlNameSyntax original, XmlNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LocalName,
    		    Modified = modified.LocalName
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, XmlNameSyntax, XmlNameSyntax>.Partners(XmlNameSyntax original, XmlNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class XmlPrefixServiceProvider : IPartnership<SyntaxNodeOrToken?, XmlPrefixSyntax, XmlPrefixSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(XmlPrefixSyntax, XmlPrefixSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, XmlPrefixSyntax, XmlPrefixSyntax}.Partners(XmlPrefixSyntax, XmlPrefixSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(XmlPrefixSyntax, XmlPrefixSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, XmlPrefixSyntax, XmlPrefixSyntax}.Partners(XmlPrefixSyntax, XmlPrefixSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(XmlPrefixSyntax original, XmlPrefixSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(XmlPrefixSyntax, XmlPrefixSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, XmlPrefixSyntax, XmlPrefixSyntax}.Partners(XmlPrefixSyntax, XmlPrefixSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(XmlPrefixSyntax original, XmlPrefixSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlPrefixSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, XmlPrefixSyntax, XmlPrefixSyntax}.Partners(XmlPrefixSyntax, XmlPrefixSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(XmlPrefixSyntax original, XmlPrefixSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Prefix,
    		    Modified = modified.Prefix
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, XmlPrefixSyntax, XmlPrefixSyntax>.Partners(XmlPrefixSyntax original, XmlPrefixSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class TypeArgumentListServiceProvider : IPartnership<SyntaxNodeOrToken?, TypeArgumentListSyntax, TypeArgumentListSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(TypeArgumentListSyntax, TypeArgumentListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, TypeArgumentListSyntax, TypeArgumentListSyntax}.Partners(TypeArgumentListSyntax, TypeArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(TypeArgumentListSyntax, TypeArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, TypeArgumentListSyntax, TypeArgumentListSyntax}.Partners(TypeArgumentListSyntax, TypeArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(TypeArgumentListSyntax original, TypeArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(TypeArgumentListSyntax, TypeArgumentListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, TypeArgumentListSyntax, TypeArgumentListSyntax}.Partners(TypeArgumentListSyntax, TypeArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(TypeArgumentListSyntax original, TypeArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TypeArgumentListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, TypeArgumentListSyntax, TypeArgumentListSyntax}.Partners(TypeArgumentListSyntax, TypeArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(TypeArgumentListSyntax original, TypeArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LessThanToken,
    		    Modified = modified.LessThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.GreaterThanToken,
    		    Modified = modified.GreaterThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, TypeArgumentListSyntax, TypeArgumentListSyntax>.Partners(TypeArgumentListSyntax original, TypeArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ArrayRankSpecifierServiceProvider : IPartnership<SyntaxNodeOrToken?, ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax}.Partners(ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax}.Partners(ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ArrayRankSpecifierSyntax original, ArrayRankSpecifierSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax}.Partners(ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ArrayRankSpecifierSyntax original, ArrayRankSpecifierSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ArrayRankSpecifierSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax}.Partners(ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ArrayRankSpecifierSyntax original, ArrayRankSpecifierSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBracketToken,
    		    Modified = modified.OpenBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBracketToken,
    		    Modified = modified.CloseBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ArrayRankSpecifierSyntax, ArrayRankSpecifierSyntax>.Partners(ArrayRankSpecifierSyntax original, ArrayRankSpecifierSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class TupleElementServiceProvider : IPartnership<SyntaxNodeOrToken?, TupleElementSyntax, TupleElementSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(TupleElementSyntax, TupleElementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, TupleElementSyntax, TupleElementSyntax}.Partners(TupleElementSyntax, TupleElementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(TupleElementSyntax, TupleElementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, TupleElementSyntax, TupleElementSyntax}.Partners(TupleElementSyntax, TupleElementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(TupleElementSyntax original, TupleElementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(TupleElementSyntax, TupleElementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, TupleElementSyntax, TupleElementSyntax}.Partners(TupleElementSyntax, TupleElementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(TupleElementSyntax original, TupleElementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TupleElementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, TupleElementSyntax, TupleElementSyntax}.Partners(TupleElementSyntax, TupleElementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(TupleElementSyntax original, TupleElementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
    		if(original.Identifier != null && modified.Identifier != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.Identifier != null)
    			matchingSet.Originals.DisableMatching(original.Identifier);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.Identifier);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, TupleElementSyntax, TupleElementSyntax>.Partners(TupleElementSyntax original, TupleElementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ArgumentServiceProvider : IPartnership<SyntaxNodeOrToken?, ArgumentSyntax, ArgumentSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ArgumentSyntax, ArgumentSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ArgumentSyntax, ArgumentSyntax}.Partners(ArgumentSyntax, ArgumentSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ArgumentSyntax, ArgumentSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ArgumentSyntax, ArgumentSyntax}.Partners(ArgumentSyntax, ArgumentSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ArgumentSyntax original, ArgumentSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ArgumentSyntax, ArgumentSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ArgumentSyntax, ArgumentSyntax}.Partners(ArgumentSyntax, ArgumentSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ArgumentSyntax original, ArgumentSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ArgumentSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ArgumentSyntax, ArgumentSyntax}.Partners(ArgumentSyntax, ArgumentSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ArgumentSyntax original, ArgumentSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.RefOrOutKeyword,
    		    Modified = modified.RefOrOutKeyword
    		};
    		if(original.RefOrOutKeyword != null && modified.RefOrOutKeyword != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.RefOrOutKeyword != null)
    			matchingSet.Originals.DisableMatching(original.RefOrOutKeyword);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.RefOrOutKeyword);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ArgumentSyntax, ArgumentSyntax>.Partners(ArgumentSyntax original, ArgumentSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class NameColonServiceProvider : IPartnership<SyntaxNodeOrToken?, NameColonSyntax, NameColonSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(NameColonSyntax, NameColonSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, NameColonSyntax, NameColonSyntax}.Partners(NameColonSyntax, NameColonSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(NameColonSyntax, NameColonSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, NameColonSyntax, NameColonSyntax}.Partners(NameColonSyntax, NameColonSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(NameColonSyntax original, NameColonSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(NameColonSyntax, NameColonSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, NameColonSyntax, NameColonSyntax}.Partners(NameColonSyntax, NameColonSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(NameColonSyntax original, NameColonSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="NameColonSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, NameColonSyntax, NameColonSyntax}.Partners(NameColonSyntax, NameColonSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(NameColonSyntax original, NameColonSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, NameColonSyntax, NameColonSyntax>.Partners(NameColonSyntax original, NameColonSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class JoinIntoClauseServiceProvider : IPartnership<SyntaxNodeOrToken?, JoinIntoClauseSyntax, JoinIntoClauseSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(JoinIntoClauseSyntax, JoinIntoClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, JoinIntoClauseSyntax, JoinIntoClauseSyntax}.Partners(JoinIntoClauseSyntax, JoinIntoClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(JoinIntoClauseSyntax, JoinIntoClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, JoinIntoClauseSyntax, JoinIntoClauseSyntax}.Partners(JoinIntoClauseSyntax, JoinIntoClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(JoinIntoClauseSyntax original, JoinIntoClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(JoinIntoClauseSyntax, JoinIntoClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, JoinIntoClauseSyntax, JoinIntoClauseSyntax}.Partners(JoinIntoClauseSyntax, JoinIntoClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(JoinIntoClauseSyntax original, JoinIntoClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="JoinIntoClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, JoinIntoClauseSyntax, JoinIntoClauseSyntax}.Partners(JoinIntoClauseSyntax, JoinIntoClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(JoinIntoClauseSyntax original, JoinIntoClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.IntoKeyword,
    		    Modified = modified.IntoKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, JoinIntoClauseSyntax, JoinIntoClauseSyntax>.Partners(JoinIntoClauseSyntax original, JoinIntoClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class OrderingServiceProvider : IPartnership<SyntaxNodeOrToken?, OrderingSyntax, OrderingSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(OrderingSyntax, OrderingSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, OrderingSyntax, OrderingSyntax}.Partners(OrderingSyntax, OrderingSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(OrderingSyntax, OrderingSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, OrderingSyntax, OrderingSyntax}.Partners(OrderingSyntax, OrderingSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(OrderingSyntax original, OrderingSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(OrderingSyntax, OrderingSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, OrderingSyntax, OrderingSyntax}.Partners(OrderingSyntax, OrderingSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(OrderingSyntax original, OrderingSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="OrderingSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, OrderingSyntax, OrderingSyntax}.Partners(OrderingSyntax, OrderingSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(OrderingSyntax original, OrderingSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.AscendingOrDescendingKeyword,
    		    Modified = modified.AscendingOrDescendingKeyword
    		};
    		if(original.AscendingOrDescendingKeyword != null && modified.AscendingOrDescendingKeyword != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.AscendingOrDescendingKeyword != null)
    			matchingSet.Originals.DisableMatching(original.AscendingOrDescendingKeyword);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.AscendingOrDescendingKeyword);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, OrderingSyntax, OrderingSyntax>.Partners(OrderingSyntax original, OrderingSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class QueryContinuationServiceProvider : IPartnership<SyntaxNodeOrToken?, QueryContinuationSyntax, QueryContinuationSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(QueryContinuationSyntax, QueryContinuationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, QueryContinuationSyntax, QueryContinuationSyntax}.Partners(QueryContinuationSyntax, QueryContinuationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(QueryContinuationSyntax, QueryContinuationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, QueryContinuationSyntax, QueryContinuationSyntax}.Partners(QueryContinuationSyntax, QueryContinuationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(QueryContinuationSyntax original, QueryContinuationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(QueryContinuationSyntax, QueryContinuationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, QueryContinuationSyntax, QueryContinuationSyntax}.Partners(QueryContinuationSyntax, QueryContinuationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(QueryContinuationSyntax original, QueryContinuationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="QueryContinuationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, QueryContinuationSyntax, QueryContinuationSyntax}.Partners(QueryContinuationSyntax, QueryContinuationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(QueryContinuationSyntax original, QueryContinuationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.IntoKeyword,
    		    Modified = modified.IntoKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, QueryContinuationSyntax, QueryContinuationSyntax>.Partners(QueryContinuationSyntax original, QueryContinuationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class WhenClauseServiceProvider : IPartnership<SyntaxNodeOrToken?, WhenClauseSyntax, WhenClauseSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(WhenClauseSyntax, WhenClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, WhenClauseSyntax, WhenClauseSyntax}.Partners(WhenClauseSyntax, WhenClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(WhenClauseSyntax, WhenClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, WhenClauseSyntax, WhenClauseSyntax}.Partners(WhenClauseSyntax, WhenClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(WhenClauseSyntax original, WhenClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(WhenClauseSyntax, WhenClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, WhenClauseSyntax, WhenClauseSyntax}.Partners(WhenClauseSyntax, WhenClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(WhenClauseSyntax original, WhenClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="WhenClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, WhenClauseSyntax, WhenClauseSyntax}.Partners(WhenClauseSyntax, WhenClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(WhenClauseSyntax original, WhenClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.WhenKeyword,
    		    Modified = modified.WhenKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, WhenClauseSyntax, WhenClauseSyntax>.Partners(WhenClauseSyntax original, WhenClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class InterpolationAlignmentClauseServiceProvider : IPartnership<SyntaxNodeOrToken?, InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax}.Partners(InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax}.Partners(InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(InterpolationAlignmentClauseSyntax original, InterpolationAlignmentClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax}.Partners(InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(InterpolationAlignmentClauseSyntax original, InterpolationAlignmentClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="InterpolationAlignmentClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax}.Partners(InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(InterpolationAlignmentClauseSyntax original, InterpolationAlignmentClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CommaToken,
    		    Modified = modified.CommaToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, InterpolationAlignmentClauseSyntax, InterpolationAlignmentClauseSyntax>.Partners(InterpolationAlignmentClauseSyntax original, InterpolationAlignmentClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class InterpolationFormatClauseServiceProvider : IPartnership<SyntaxNodeOrToken?, InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax}.Partners(InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax}.Partners(InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(InterpolationFormatClauseSyntax original, InterpolationFormatClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax}.Partners(InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(InterpolationFormatClauseSyntax original, InterpolationFormatClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="InterpolationFormatClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax}.Partners(InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(InterpolationFormatClauseSyntax original, InterpolationFormatClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.FormatStringToken,
    		    Modified = modified.FormatStringToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, InterpolationFormatClauseSyntax, InterpolationFormatClauseSyntax>.Partners(InterpolationFormatClauseSyntax original, InterpolationFormatClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class VariableDeclaratorServiceProvider : IPartnership<SyntaxNodeOrToken?, VariableDeclaratorSyntax, VariableDeclaratorSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(VariableDeclaratorSyntax, VariableDeclaratorSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, VariableDeclaratorSyntax, VariableDeclaratorSyntax}.Partners(VariableDeclaratorSyntax, VariableDeclaratorSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(VariableDeclaratorSyntax, VariableDeclaratorSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, VariableDeclaratorSyntax, VariableDeclaratorSyntax}.Partners(VariableDeclaratorSyntax, VariableDeclaratorSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(VariableDeclaratorSyntax original, VariableDeclaratorSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(VariableDeclaratorSyntax, VariableDeclaratorSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, VariableDeclaratorSyntax, VariableDeclaratorSyntax}.Partners(VariableDeclaratorSyntax, VariableDeclaratorSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(VariableDeclaratorSyntax original, VariableDeclaratorSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="VariableDeclaratorSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, VariableDeclaratorSyntax, VariableDeclaratorSyntax}.Partners(VariableDeclaratorSyntax, VariableDeclaratorSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(VariableDeclaratorSyntax original, VariableDeclaratorSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, VariableDeclaratorSyntax, VariableDeclaratorSyntax>.Partners(VariableDeclaratorSyntax original, VariableDeclaratorSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class EqualsValueClauseServiceProvider : IPartnership<SyntaxNodeOrToken?, EqualsValueClauseSyntax, EqualsValueClauseSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(EqualsValueClauseSyntax, EqualsValueClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, EqualsValueClauseSyntax, EqualsValueClauseSyntax}.Partners(EqualsValueClauseSyntax, EqualsValueClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(EqualsValueClauseSyntax, EqualsValueClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, EqualsValueClauseSyntax, EqualsValueClauseSyntax}.Partners(EqualsValueClauseSyntax, EqualsValueClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(EqualsValueClauseSyntax original, EqualsValueClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(EqualsValueClauseSyntax, EqualsValueClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, EqualsValueClauseSyntax, EqualsValueClauseSyntax}.Partners(EqualsValueClauseSyntax, EqualsValueClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(EqualsValueClauseSyntax original, EqualsValueClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EqualsValueClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, EqualsValueClauseSyntax, EqualsValueClauseSyntax}.Partners(EqualsValueClauseSyntax, EqualsValueClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(EqualsValueClauseSyntax original, EqualsValueClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EqualsToken,
    		    Modified = modified.EqualsToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, EqualsValueClauseSyntax, EqualsValueClauseSyntax>.Partners(EqualsValueClauseSyntax original, EqualsValueClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ElseClauseServiceProvider : IPartnership<SyntaxNodeOrToken?, ElseClauseSyntax, ElseClauseSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ElseClauseSyntax, ElseClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ElseClauseSyntax, ElseClauseSyntax}.Partners(ElseClauseSyntax, ElseClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ElseClauseSyntax, ElseClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ElseClauseSyntax, ElseClauseSyntax}.Partners(ElseClauseSyntax, ElseClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ElseClauseSyntax original, ElseClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ElseClauseSyntax, ElseClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ElseClauseSyntax, ElseClauseSyntax}.Partners(ElseClauseSyntax, ElseClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ElseClauseSyntax original, ElseClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ElseClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ElseClauseSyntax, ElseClauseSyntax}.Partners(ElseClauseSyntax, ElseClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ElseClauseSyntax original, ElseClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ElseKeyword,
    		    Modified = modified.ElseKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ElseClauseSyntax, ElseClauseSyntax>.Partners(ElseClauseSyntax original, ElseClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class CatchClauseServiceProvider : IPartnership<SyntaxNodeOrToken?, CatchClauseSyntax, CatchClauseSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(CatchClauseSyntax, CatchClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, CatchClauseSyntax, CatchClauseSyntax}.Partners(CatchClauseSyntax, CatchClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(CatchClauseSyntax, CatchClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, CatchClauseSyntax, CatchClauseSyntax}.Partners(CatchClauseSyntax, CatchClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(CatchClauseSyntax original, CatchClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(CatchClauseSyntax, CatchClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, CatchClauseSyntax, CatchClauseSyntax}.Partners(CatchClauseSyntax, CatchClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(CatchClauseSyntax original, CatchClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CatchClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, CatchClauseSyntax, CatchClauseSyntax}.Partners(CatchClauseSyntax, CatchClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(CatchClauseSyntax original, CatchClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CatchKeyword,
    		    Modified = modified.CatchKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, CatchClauseSyntax, CatchClauseSyntax>.Partners(CatchClauseSyntax original, CatchClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class CatchDeclarationServiceProvider : IPartnership<SyntaxNodeOrToken?, CatchDeclarationSyntax, CatchDeclarationSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(CatchDeclarationSyntax, CatchDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, CatchDeclarationSyntax, CatchDeclarationSyntax}.Partners(CatchDeclarationSyntax, CatchDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(CatchDeclarationSyntax, CatchDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, CatchDeclarationSyntax, CatchDeclarationSyntax}.Partners(CatchDeclarationSyntax, CatchDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(CatchDeclarationSyntax original, CatchDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(CatchDeclarationSyntax, CatchDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, CatchDeclarationSyntax, CatchDeclarationSyntax}.Partners(CatchDeclarationSyntax, CatchDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(CatchDeclarationSyntax original, CatchDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CatchDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, CatchDeclarationSyntax, CatchDeclarationSyntax}.Partners(CatchDeclarationSyntax, CatchDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(CatchDeclarationSyntax original, CatchDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
    		if(original.Identifier != null && modified.Identifier != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.Identifier != null)
    			matchingSet.Originals.DisableMatching(original.Identifier);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.Identifier);
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, CatchDeclarationSyntax, CatchDeclarationSyntax>.Partners(CatchDeclarationSyntax original, CatchDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class CatchFilterClauseServiceProvider : IPartnership<SyntaxNodeOrToken?, CatchFilterClauseSyntax, CatchFilterClauseSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(CatchFilterClauseSyntax, CatchFilterClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, CatchFilterClauseSyntax, CatchFilterClauseSyntax}.Partners(CatchFilterClauseSyntax, CatchFilterClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(CatchFilterClauseSyntax, CatchFilterClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, CatchFilterClauseSyntax, CatchFilterClauseSyntax}.Partners(CatchFilterClauseSyntax, CatchFilterClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(CatchFilterClauseSyntax original, CatchFilterClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(CatchFilterClauseSyntax, CatchFilterClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, CatchFilterClauseSyntax, CatchFilterClauseSyntax}.Partners(CatchFilterClauseSyntax, CatchFilterClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(CatchFilterClauseSyntax original, CatchFilterClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CatchFilterClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, CatchFilterClauseSyntax, CatchFilterClauseSyntax}.Partners(CatchFilterClauseSyntax, CatchFilterClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(CatchFilterClauseSyntax original, CatchFilterClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.WhenKeyword,
    		    Modified = modified.WhenKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, CatchFilterClauseSyntax, CatchFilterClauseSyntax>.Partners(CatchFilterClauseSyntax original, CatchFilterClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class FinallyClauseServiceProvider : IPartnership<SyntaxNodeOrToken?, FinallyClauseSyntax, FinallyClauseSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(FinallyClauseSyntax, FinallyClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, FinallyClauseSyntax, FinallyClauseSyntax}.Partners(FinallyClauseSyntax, FinallyClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(FinallyClauseSyntax, FinallyClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, FinallyClauseSyntax, FinallyClauseSyntax}.Partners(FinallyClauseSyntax, FinallyClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(FinallyClauseSyntax original, FinallyClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(FinallyClauseSyntax, FinallyClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, FinallyClauseSyntax, FinallyClauseSyntax}.Partners(FinallyClauseSyntax, FinallyClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(FinallyClauseSyntax original, FinallyClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="FinallyClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, FinallyClauseSyntax, FinallyClauseSyntax}.Partners(FinallyClauseSyntax, FinallyClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(FinallyClauseSyntax original, FinallyClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.FinallyKeyword,
    		    Modified = modified.FinallyKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, FinallyClauseSyntax, FinallyClauseSyntax>.Partners(FinallyClauseSyntax original, FinallyClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class CompilationUnitServiceProvider : IPartnership<SyntaxNodeOrToken?, CompilationUnitSyntax, CompilationUnitSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(CompilationUnitSyntax, CompilationUnitSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, CompilationUnitSyntax, CompilationUnitSyntax}.Partners(CompilationUnitSyntax, CompilationUnitSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(CompilationUnitSyntax, CompilationUnitSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, CompilationUnitSyntax, CompilationUnitSyntax}.Partners(CompilationUnitSyntax, CompilationUnitSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(CompilationUnitSyntax original, CompilationUnitSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(CompilationUnitSyntax, CompilationUnitSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, CompilationUnitSyntax, CompilationUnitSyntax}.Partners(CompilationUnitSyntax, CompilationUnitSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(CompilationUnitSyntax original, CompilationUnitSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CompilationUnitSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, CompilationUnitSyntax, CompilationUnitSyntax}.Partners(CompilationUnitSyntax, CompilationUnitSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(CompilationUnitSyntax original, CompilationUnitSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfFileToken,
    		    Modified = modified.EndOfFileToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, CompilationUnitSyntax, CompilationUnitSyntax>.Partners(CompilationUnitSyntax original, CompilationUnitSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ExternAliasDirectiveServiceProvider : IPartnership<SyntaxNodeOrToken?, ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax}.Partners(ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax}.Partners(ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ExternAliasDirectiveSyntax original, ExternAliasDirectiveSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax}.Partners(ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ExternAliasDirectiveSyntax original, ExternAliasDirectiveSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ExternAliasDirectiveSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax}.Partners(ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ExternAliasDirectiveSyntax original, ExternAliasDirectiveSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ExternKeyword,
    		    Modified = modified.ExternKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.AliasKeyword,
    		    Modified = modified.AliasKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ExternAliasDirectiveSyntax, ExternAliasDirectiveSyntax>.Partners(ExternAliasDirectiveSyntax original, ExternAliasDirectiveSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class UsingDirectiveServiceProvider : IPartnership<SyntaxNodeOrToken?, UsingDirectiveSyntax, UsingDirectiveSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(UsingDirectiveSyntax, UsingDirectiveSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, UsingDirectiveSyntax, UsingDirectiveSyntax}.Partners(UsingDirectiveSyntax, UsingDirectiveSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(UsingDirectiveSyntax, UsingDirectiveSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, UsingDirectiveSyntax, UsingDirectiveSyntax}.Partners(UsingDirectiveSyntax, UsingDirectiveSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(UsingDirectiveSyntax original, UsingDirectiveSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(UsingDirectiveSyntax, UsingDirectiveSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, UsingDirectiveSyntax, UsingDirectiveSyntax}.Partners(UsingDirectiveSyntax, UsingDirectiveSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(UsingDirectiveSyntax original, UsingDirectiveSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="UsingDirectiveSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, UsingDirectiveSyntax, UsingDirectiveSyntax}.Partners(UsingDirectiveSyntax, UsingDirectiveSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(UsingDirectiveSyntax original, UsingDirectiveSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.UsingKeyword,
    		    Modified = modified.UsingKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.StaticKeyword,
    		    Modified = modified.StaticKeyword
    		};
    		if(original.StaticKeyword != null && modified.StaticKeyword != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.StaticKeyword != null)
    			matchingSet.Originals.DisableMatching(original.StaticKeyword);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.StaticKeyword);
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, UsingDirectiveSyntax, UsingDirectiveSyntax>.Partners(UsingDirectiveSyntax original, UsingDirectiveSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class AttributeListServiceProvider : IPartnership<SyntaxNodeOrToken?, AttributeListSyntax, AttributeListSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(AttributeListSyntax, AttributeListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, AttributeListSyntax, AttributeListSyntax}.Partners(AttributeListSyntax, AttributeListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(AttributeListSyntax, AttributeListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, AttributeListSyntax, AttributeListSyntax}.Partners(AttributeListSyntax, AttributeListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(AttributeListSyntax original, AttributeListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(AttributeListSyntax, AttributeListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, AttributeListSyntax, AttributeListSyntax}.Partners(AttributeListSyntax, AttributeListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(AttributeListSyntax original, AttributeListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AttributeListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, AttributeListSyntax, AttributeListSyntax}.Partners(AttributeListSyntax, AttributeListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(AttributeListSyntax original, AttributeListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBracketToken,
    		    Modified = modified.OpenBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBracketToken,
    		    Modified = modified.CloseBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, AttributeListSyntax, AttributeListSyntax>.Partners(AttributeListSyntax original, AttributeListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class AttributeTargetSpecifierServiceProvider : IPartnership<SyntaxNodeOrToken?, AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax}.Partners(AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax}.Partners(AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(AttributeTargetSpecifierSyntax original, AttributeTargetSpecifierSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax}.Partners(AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(AttributeTargetSpecifierSyntax original, AttributeTargetSpecifierSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AttributeTargetSpecifierSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax}.Partners(AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(AttributeTargetSpecifierSyntax original, AttributeTargetSpecifierSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, AttributeTargetSpecifierSyntax, AttributeTargetSpecifierSyntax>.Partners(AttributeTargetSpecifierSyntax original, AttributeTargetSpecifierSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class AttributeArgumentListServiceProvider : IPartnership<SyntaxNodeOrToken?, AttributeArgumentListSyntax, AttributeArgumentListSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(AttributeArgumentListSyntax, AttributeArgumentListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, AttributeArgumentListSyntax, AttributeArgumentListSyntax}.Partners(AttributeArgumentListSyntax, AttributeArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(AttributeArgumentListSyntax, AttributeArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, AttributeArgumentListSyntax, AttributeArgumentListSyntax}.Partners(AttributeArgumentListSyntax, AttributeArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(AttributeArgumentListSyntax original, AttributeArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(AttributeArgumentListSyntax, AttributeArgumentListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, AttributeArgumentListSyntax, AttributeArgumentListSyntax}.Partners(AttributeArgumentListSyntax, AttributeArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(AttributeArgumentListSyntax original, AttributeArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AttributeArgumentListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, AttributeArgumentListSyntax, AttributeArgumentListSyntax}.Partners(AttributeArgumentListSyntax, AttributeArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(AttributeArgumentListSyntax original, AttributeArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, AttributeArgumentListSyntax, AttributeArgumentListSyntax>.Partners(AttributeArgumentListSyntax original, AttributeArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class DelegateDeclarationServiceProvider : IPartnership<SyntaxNodeOrToken?, DelegateDeclarationSyntax, DelegateDeclarationSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(DelegateDeclarationSyntax, DelegateDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, DelegateDeclarationSyntax, DelegateDeclarationSyntax}.Partners(DelegateDeclarationSyntax, DelegateDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(DelegateDeclarationSyntax, DelegateDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, DelegateDeclarationSyntax, DelegateDeclarationSyntax}.Partners(DelegateDeclarationSyntax, DelegateDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(DelegateDeclarationSyntax original, DelegateDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(DelegateDeclarationSyntax, DelegateDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, DelegateDeclarationSyntax, DelegateDeclarationSyntax}.Partners(DelegateDeclarationSyntax, DelegateDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(DelegateDeclarationSyntax original, DelegateDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DelegateDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, DelegateDeclarationSyntax, DelegateDeclarationSyntax}.Partners(DelegateDeclarationSyntax, DelegateDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(DelegateDeclarationSyntax original, DelegateDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.DelegateKeyword,
    		    Modified = modified.DelegateKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, DelegateDeclarationSyntax, DelegateDeclarationSyntax>.Partners(DelegateDeclarationSyntax original, DelegateDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class EnumMemberDeclarationServiceProvider : IPartnership<SyntaxNodeOrToken?, EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax}.Partners(EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax}.Partners(EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(EnumMemberDeclarationSyntax original, EnumMemberDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax}.Partners(EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(EnumMemberDeclarationSyntax original, EnumMemberDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EnumMemberDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax}.Partners(EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(EnumMemberDeclarationSyntax original, EnumMemberDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, EnumMemberDeclarationSyntax, EnumMemberDeclarationSyntax>.Partners(EnumMemberDeclarationSyntax original, EnumMemberDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class NamespaceDeclarationServiceProvider : IPartnership<SyntaxNodeOrToken?, NamespaceDeclarationSyntax, NamespaceDeclarationSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(NamespaceDeclarationSyntax, NamespaceDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, NamespaceDeclarationSyntax, NamespaceDeclarationSyntax}.Partners(NamespaceDeclarationSyntax, NamespaceDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(NamespaceDeclarationSyntax, NamespaceDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, NamespaceDeclarationSyntax, NamespaceDeclarationSyntax}.Partners(NamespaceDeclarationSyntax, NamespaceDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(NamespaceDeclarationSyntax original, NamespaceDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(NamespaceDeclarationSyntax, NamespaceDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, NamespaceDeclarationSyntax, NamespaceDeclarationSyntax}.Partners(NamespaceDeclarationSyntax, NamespaceDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(NamespaceDeclarationSyntax original, NamespaceDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="NamespaceDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, NamespaceDeclarationSyntax, NamespaceDeclarationSyntax}.Partners(NamespaceDeclarationSyntax, NamespaceDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(NamespaceDeclarationSyntax original, NamespaceDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.NamespaceKeyword,
    		    Modified = modified.NamespaceKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && modified.SemicolonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.SemicolonToken != null)
    			matchingSet.Originals.DisableMatching(original.SemicolonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, NamespaceDeclarationSyntax, NamespaceDeclarationSyntax>.Partners(NamespaceDeclarationSyntax original, NamespaceDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class EnumDeclarationServiceProvider : IPartnership<SyntaxNodeOrToken?, EnumDeclarationSyntax, EnumDeclarationSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(EnumDeclarationSyntax, EnumDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, EnumDeclarationSyntax, EnumDeclarationSyntax}.Partners(EnumDeclarationSyntax, EnumDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(EnumDeclarationSyntax, EnumDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, EnumDeclarationSyntax, EnumDeclarationSyntax}.Partners(EnumDeclarationSyntax, EnumDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(EnumDeclarationSyntax original, EnumDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(EnumDeclarationSyntax, EnumDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, EnumDeclarationSyntax, EnumDeclarationSyntax}.Partners(EnumDeclarationSyntax, EnumDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(EnumDeclarationSyntax original, EnumDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EnumDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, EnumDeclarationSyntax, EnumDeclarationSyntax}.Partners(EnumDeclarationSyntax, EnumDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(EnumDeclarationSyntax original, EnumDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EnumKeyword,
    		    Modified = modified.EnumKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && modified.SemicolonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.SemicolonToken != null)
    			matchingSet.Originals.DisableMatching(original.SemicolonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, EnumDeclarationSyntax, EnumDeclarationSyntax>.Partners(EnumDeclarationSyntax original, EnumDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ClassDeclarationServiceProvider : IPartnership<SyntaxNodeOrToken?, ClassDeclarationSyntax, ClassDeclarationSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ClassDeclarationSyntax, ClassDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ClassDeclarationSyntax, ClassDeclarationSyntax}.Partners(ClassDeclarationSyntax, ClassDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ClassDeclarationSyntax, ClassDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ClassDeclarationSyntax, ClassDeclarationSyntax}.Partners(ClassDeclarationSyntax, ClassDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ClassDeclarationSyntax original, ClassDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ClassDeclarationSyntax, ClassDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ClassDeclarationSyntax, ClassDeclarationSyntax}.Partners(ClassDeclarationSyntax, ClassDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ClassDeclarationSyntax original, ClassDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ClassDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ClassDeclarationSyntax, ClassDeclarationSyntax}.Partners(ClassDeclarationSyntax, ClassDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ClassDeclarationSyntax original, ClassDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && modified.SemicolonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.SemicolonToken != null)
    			matchingSet.Originals.DisableMatching(original.SemicolonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ClassDeclarationSyntax, ClassDeclarationSyntax>.Partners(ClassDeclarationSyntax original, ClassDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class StructDeclarationServiceProvider : IPartnership<SyntaxNodeOrToken?, StructDeclarationSyntax, StructDeclarationSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(StructDeclarationSyntax, StructDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, StructDeclarationSyntax, StructDeclarationSyntax}.Partners(StructDeclarationSyntax, StructDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(StructDeclarationSyntax, StructDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, StructDeclarationSyntax, StructDeclarationSyntax}.Partners(StructDeclarationSyntax, StructDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(StructDeclarationSyntax original, StructDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(StructDeclarationSyntax, StructDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, StructDeclarationSyntax, StructDeclarationSyntax}.Partners(StructDeclarationSyntax, StructDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(StructDeclarationSyntax original, StructDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="StructDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, StructDeclarationSyntax, StructDeclarationSyntax}.Partners(StructDeclarationSyntax, StructDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(StructDeclarationSyntax original, StructDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && modified.SemicolonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.SemicolonToken != null)
    			matchingSet.Originals.DisableMatching(original.SemicolonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, StructDeclarationSyntax, StructDeclarationSyntax>.Partners(StructDeclarationSyntax original, StructDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class InterfaceDeclarationServiceProvider : IPartnership<SyntaxNodeOrToken?, InterfaceDeclarationSyntax, InterfaceDeclarationSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(InterfaceDeclarationSyntax, InterfaceDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, InterfaceDeclarationSyntax, InterfaceDeclarationSyntax}.Partners(InterfaceDeclarationSyntax, InterfaceDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(InterfaceDeclarationSyntax, InterfaceDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, InterfaceDeclarationSyntax, InterfaceDeclarationSyntax}.Partners(InterfaceDeclarationSyntax, InterfaceDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(InterfaceDeclarationSyntax original, InterfaceDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(InterfaceDeclarationSyntax, InterfaceDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, InterfaceDeclarationSyntax, InterfaceDeclarationSyntax}.Partners(InterfaceDeclarationSyntax, InterfaceDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(InterfaceDeclarationSyntax original, InterfaceDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="InterfaceDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, InterfaceDeclarationSyntax, InterfaceDeclarationSyntax}.Partners(InterfaceDeclarationSyntax, InterfaceDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(InterfaceDeclarationSyntax original, InterfaceDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && modified.SemicolonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.SemicolonToken != null)
    			matchingSet.Originals.DisableMatching(original.SemicolonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, InterfaceDeclarationSyntax, InterfaceDeclarationSyntax>.Partners(InterfaceDeclarationSyntax original, InterfaceDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class FieldDeclarationServiceProvider : IPartnership<SyntaxNodeOrToken?, FieldDeclarationSyntax, FieldDeclarationSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(FieldDeclarationSyntax, FieldDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, FieldDeclarationSyntax, FieldDeclarationSyntax}.Partners(FieldDeclarationSyntax, FieldDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(FieldDeclarationSyntax, FieldDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, FieldDeclarationSyntax, FieldDeclarationSyntax}.Partners(FieldDeclarationSyntax, FieldDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(FieldDeclarationSyntax original, FieldDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(FieldDeclarationSyntax, FieldDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, FieldDeclarationSyntax, FieldDeclarationSyntax}.Partners(FieldDeclarationSyntax, FieldDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(FieldDeclarationSyntax original, FieldDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="FieldDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, FieldDeclarationSyntax, FieldDeclarationSyntax}.Partners(FieldDeclarationSyntax, FieldDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(FieldDeclarationSyntax original, FieldDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, FieldDeclarationSyntax, FieldDeclarationSyntax>.Partners(FieldDeclarationSyntax original, FieldDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class EventFieldDeclarationServiceProvider : IPartnership<SyntaxNodeOrToken?, EventFieldDeclarationSyntax, EventFieldDeclarationSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(EventFieldDeclarationSyntax, EventFieldDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, EventFieldDeclarationSyntax, EventFieldDeclarationSyntax}.Partners(EventFieldDeclarationSyntax, EventFieldDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(EventFieldDeclarationSyntax, EventFieldDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, EventFieldDeclarationSyntax, EventFieldDeclarationSyntax}.Partners(EventFieldDeclarationSyntax, EventFieldDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(EventFieldDeclarationSyntax original, EventFieldDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(EventFieldDeclarationSyntax, EventFieldDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, EventFieldDeclarationSyntax, EventFieldDeclarationSyntax}.Partners(EventFieldDeclarationSyntax, EventFieldDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(EventFieldDeclarationSyntax original, EventFieldDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EventFieldDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, EventFieldDeclarationSyntax, EventFieldDeclarationSyntax}.Partners(EventFieldDeclarationSyntax, EventFieldDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(EventFieldDeclarationSyntax original, EventFieldDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EventKeyword,
    		    Modified = modified.EventKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, EventFieldDeclarationSyntax, EventFieldDeclarationSyntax>.Partners(EventFieldDeclarationSyntax original, EventFieldDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class MethodDeclarationServiceProvider : IPartnership<SyntaxNodeOrToken?, MethodDeclarationSyntax, MethodDeclarationSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(MethodDeclarationSyntax, MethodDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, MethodDeclarationSyntax, MethodDeclarationSyntax}.Partners(MethodDeclarationSyntax, MethodDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MethodDeclarationSyntax, MethodDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, MethodDeclarationSyntax, MethodDeclarationSyntax}.Partners(MethodDeclarationSyntax, MethodDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MethodDeclarationSyntax original, MethodDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(MethodDeclarationSyntax, MethodDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, MethodDeclarationSyntax, MethodDeclarationSyntax}.Partners(MethodDeclarationSyntax, MethodDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(MethodDeclarationSyntax original, MethodDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="MethodDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, MethodDeclarationSyntax, MethodDeclarationSyntax}.Partners(MethodDeclarationSyntax, MethodDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MethodDeclarationSyntax original, MethodDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && modified.SemicolonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.SemicolonToken != null)
    			matchingSet.Originals.DisableMatching(original.SemicolonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, MethodDeclarationSyntax, MethodDeclarationSyntax>.Partners(MethodDeclarationSyntax original, MethodDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class OperatorDeclarationServiceProvider : IPartnership<SyntaxNodeOrToken?, OperatorDeclarationSyntax, OperatorDeclarationSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(OperatorDeclarationSyntax, OperatorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, OperatorDeclarationSyntax, OperatorDeclarationSyntax}.Partners(OperatorDeclarationSyntax, OperatorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(OperatorDeclarationSyntax, OperatorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, OperatorDeclarationSyntax, OperatorDeclarationSyntax}.Partners(OperatorDeclarationSyntax, OperatorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(OperatorDeclarationSyntax original, OperatorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(OperatorDeclarationSyntax, OperatorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, OperatorDeclarationSyntax, OperatorDeclarationSyntax}.Partners(OperatorDeclarationSyntax, OperatorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(OperatorDeclarationSyntax original, OperatorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="OperatorDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, OperatorDeclarationSyntax, OperatorDeclarationSyntax}.Partners(OperatorDeclarationSyntax, OperatorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(OperatorDeclarationSyntax original, OperatorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorKeyword,
    		    Modified = modified.OperatorKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorToken,
    		    Modified = modified.OperatorToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && modified.SemicolonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.SemicolonToken != null)
    			matchingSet.Originals.DisableMatching(original.SemicolonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, OperatorDeclarationSyntax, OperatorDeclarationSyntax>.Partners(OperatorDeclarationSyntax original, OperatorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ConversionOperatorDeclarationServiceProvider : IPartnership<SyntaxNodeOrToken?, ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax}.Partners(ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax}.Partners(ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ConversionOperatorDeclarationSyntax original, ConversionOperatorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax}.Partners(ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ConversionOperatorDeclarationSyntax original, ConversionOperatorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ConversionOperatorDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax}.Partners(ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ConversionOperatorDeclarationSyntax original, ConversionOperatorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ImplicitOrExplicitKeyword,
    		    Modified = modified.ImplicitOrExplicitKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorKeyword,
    		    Modified = modified.OperatorKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && modified.SemicolonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.SemicolonToken != null)
    			matchingSet.Originals.DisableMatching(original.SemicolonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ConversionOperatorDeclarationSyntax, ConversionOperatorDeclarationSyntax>.Partners(ConversionOperatorDeclarationSyntax original, ConversionOperatorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ConstructorDeclarationServiceProvider : IPartnership<SyntaxNodeOrToken?, ConstructorDeclarationSyntax, ConstructorDeclarationSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ConstructorDeclarationSyntax, ConstructorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ConstructorDeclarationSyntax, ConstructorDeclarationSyntax}.Partners(ConstructorDeclarationSyntax, ConstructorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ConstructorDeclarationSyntax, ConstructorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ConstructorDeclarationSyntax, ConstructorDeclarationSyntax}.Partners(ConstructorDeclarationSyntax, ConstructorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ConstructorDeclarationSyntax original, ConstructorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ConstructorDeclarationSyntax, ConstructorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ConstructorDeclarationSyntax, ConstructorDeclarationSyntax}.Partners(ConstructorDeclarationSyntax, ConstructorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ConstructorDeclarationSyntax original, ConstructorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ConstructorDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ConstructorDeclarationSyntax, ConstructorDeclarationSyntax}.Partners(ConstructorDeclarationSyntax, ConstructorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ConstructorDeclarationSyntax original, ConstructorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && modified.SemicolonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.SemicolonToken != null)
    			matchingSet.Originals.DisableMatching(original.SemicolonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ConstructorDeclarationSyntax, ConstructorDeclarationSyntax>.Partners(ConstructorDeclarationSyntax original, ConstructorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class DestructorDeclarationServiceProvider : IPartnership<SyntaxNodeOrToken?, DestructorDeclarationSyntax, DestructorDeclarationSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(DestructorDeclarationSyntax, DestructorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, DestructorDeclarationSyntax, DestructorDeclarationSyntax}.Partners(DestructorDeclarationSyntax, DestructorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(DestructorDeclarationSyntax, DestructorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, DestructorDeclarationSyntax, DestructorDeclarationSyntax}.Partners(DestructorDeclarationSyntax, DestructorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(DestructorDeclarationSyntax original, DestructorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(DestructorDeclarationSyntax, DestructorDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, DestructorDeclarationSyntax, DestructorDeclarationSyntax}.Partners(DestructorDeclarationSyntax, DestructorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(DestructorDeclarationSyntax original, DestructorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DestructorDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, DestructorDeclarationSyntax, DestructorDeclarationSyntax}.Partners(DestructorDeclarationSyntax, DestructorDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(DestructorDeclarationSyntax original, DestructorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.TildeToken,
    		    Modified = modified.TildeToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && modified.SemicolonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.SemicolonToken != null)
    			matchingSet.Originals.DisableMatching(original.SemicolonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, DestructorDeclarationSyntax, DestructorDeclarationSyntax>.Partners(DestructorDeclarationSyntax original, DestructorDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class PropertyDeclarationServiceProvider : IPartnership<SyntaxNodeOrToken?, PropertyDeclarationSyntax, PropertyDeclarationSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(PropertyDeclarationSyntax, PropertyDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, PropertyDeclarationSyntax, PropertyDeclarationSyntax}.Partners(PropertyDeclarationSyntax, PropertyDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(PropertyDeclarationSyntax, PropertyDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, PropertyDeclarationSyntax, PropertyDeclarationSyntax}.Partners(PropertyDeclarationSyntax, PropertyDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(PropertyDeclarationSyntax original, PropertyDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(PropertyDeclarationSyntax, PropertyDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, PropertyDeclarationSyntax, PropertyDeclarationSyntax}.Partners(PropertyDeclarationSyntax, PropertyDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(PropertyDeclarationSyntax original, PropertyDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="PropertyDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, PropertyDeclarationSyntax, PropertyDeclarationSyntax}.Partners(PropertyDeclarationSyntax, PropertyDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(PropertyDeclarationSyntax original, PropertyDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && modified.SemicolonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.SemicolonToken != null)
    			matchingSet.Originals.DisableMatching(original.SemicolonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, PropertyDeclarationSyntax, PropertyDeclarationSyntax>.Partners(PropertyDeclarationSyntax original, PropertyDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class EventDeclarationServiceProvider : IPartnership<SyntaxNodeOrToken?, EventDeclarationSyntax, EventDeclarationSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(EventDeclarationSyntax, EventDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, EventDeclarationSyntax, EventDeclarationSyntax}.Partners(EventDeclarationSyntax, EventDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(EventDeclarationSyntax, EventDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, EventDeclarationSyntax, EventDeclarationSyntax}.Partners(EventDeclarationSyntax, EventDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(EventDeclarationSyntax original, EventDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(EventDeclarationSyntax, EventDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, EventDeclarationSyntax, EventDeclarationSyntax}.Partners(EventDeclarationSyntax, EventDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(EventDeclarationSyntax original, EventDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EventDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, EventDeclarationSyntax, EventDeclarationSyntax}.Partners(EventDeclarationSyntax, EventDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(EventDeclarationSyntax original, EventDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EventKeyword,
    		    Modified = modified.EventKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, EventDeclarationSyntax, EventDeclarationSyntax>.Partners(EventDeclarationSyntax original, EventDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class IndexerDeclarationServiceProvider : IPartnership<SyntaxNodeOrToken?, IndexerDeclarationSyntax, IndexerDeclarationSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(IndexerDeclarationSyntax, IndexerDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, IndexerDeclarationSyntax, IndexerDeclarationSyntax}.Partners(IndexerDeclarationSyntax, IndexerDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(IndexerDeclarationSyntax, IndexerDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, IndexerDeclarationSyntax, IndexerDeclarationSyntax}.Partners(IndexerDeclarationSyntax, IndexerDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(IndexerDeclarationSyntax original, IndexerDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(IndexerDeclarationSyntax, IndexerDeclarationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, IndexerDeclarationSyntax, IndexerDeclarationSyntax}.Partners(IndexerDeclarationSyntax, IndexerDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(IndexerDeclarationSyntax original, IndexerDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="IndexerDeclarationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, IndexerDeclarationSyntax, IndexerDeclarationSyntax}.Partners(IndexerDeclarationSyntax, IndexerDeclarationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(IndexerDeclarationSyntax original, IndexerDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ThisKeyword,
    		    Modified = modified.ThisKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && modified.SemicolonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.SemicolonToken != null)
    			matchingSet.Originals.DisableMatching(original.SemicolonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, IndexerDeclarationSyntax, IndexerDeclarationSyntax>.Partners(IndexerDeclarationSyntax original, IndexerDeclarationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ConstructorConstraintServiceProvider : IPartnership<SyntaxNodeOrToken?, ConstructorConstraintSyntax, ConstructorConstraintSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ConstructorConstraintSyntax, ConstructorConstraintSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ConstructorConstraintSyntax, ConstructorConstraintSyntax}.Partners(ConstructorConstraintSyntax, ConstructorConstraintSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ConstructorConstraintSyntax, ConstructorConstraintSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ConstructorConstraintSyntax, ConstructorConstraintSyntax}.Partners(ConstructorConstraintSyntax, ConstructorConstraintSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ConstructorConstraintSyntax original, ConstructorConstraintSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ConstructorConstraintSyntax, ConstructorConstraintSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ConstructorConstraintSyntax, ConstructorConstraintSyntax}.Partners(ConstructorConstraintSyntax, ConstructorConstraintSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ConstructorConstraintSyntax original, ConstructorConstraintSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ConstructorConstraintSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ConstructorConstraintSyntax, ConstructorConstraintSyntax}.Partners(ConstructorConstraintSyntax, ConstructorConstraintSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ConstructorConstraintSyntax original, ConstructorConstraintSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.NewKeyword,
    		    Modified = modified.NewKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ConstructorConstraintSyntax, ConstructorConstraintSyntax>.Partners(ConstructorConstraintSyntax original, ConstructorConstraintSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ClassOrStructConstraintServiceProvider : IPartnership<SyntaxNodeOrToken?, ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax}.Partners(ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax}.Partners(ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ClassOrStructConstraintSyntax original, ClassOrStructConstraintSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax}.Partners(ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ClassOrStructConstraintSyntax original, ClassOrStructConstraintSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ClassOrStructConstraintSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax}.Partners(ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ClassOrStructConstraintSyntax original, ClassOrStructConstraintSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ClassOrStructKeyword,
    		    Modified = modified.ClassOrStructKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ClassOrStructConstraintSyntax, ClassOrStructConstraintSyntax>.Partners(ClassOrStructConstraintSyntax original, ClassOrStructConstraintSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ParameterListServiceProvider : IPartnership<SyntaxNodeOrToken?, ParameterListSyntax, ParameterListSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ParameterListSyntax, ParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ParameterListSyntax, ParameterListSyntax}.Partners(ParameterListSyntax, ParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ParameterListSyntax, ParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ParameterListSyntax, ParameterListSyntax}.Partners(ParameterListSyntax, ParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ParameterListSyntax original, ParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ParameterListSyntax, ParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ParameterListSyntax, ParameterListSyntax}.Partners(ParameterListSyntax, ParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ParameterListSyntax original, ParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ParameterListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ParameterListSyntax, ParameterListSyntax}.Partners(ParameterListSyntax, ParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ParameterListSyntax original, ParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ParameterListSyntax, ParameterListSyntax>.Partners(ParameterListSyntax original, ParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class BracketedParameterListServiceProvider : IPartnership<SyntaxNodeOrToken?, BracketedParameterListSyntax, BracketedParameterListSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(BracketedParameterListSyntax, BracketedParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, BracketedParameterListSyntax, BracketedParameterListSyntax}.Partners(BracketedParameterListSyntax, BracketedParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(BracketedParameterListSyntax, BracketedParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, BracketedParameterListSyntax, BracketedParameterListSyntax}.Partners(BracketedParameterListSyntax, BracketedParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(BracketedParameterListSyntax original, BracketedParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(BracketedParameterListSyntax, BracketedParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, BracketedParameterListSyntax, BracketedParameterListSyntax}.Partners(BracketedParameterListSyntax, BracketedParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(BracketedParameterListSyntax original, BracketedParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BracketedParameterListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, BracketedParameterListSyntax, BracketedParameterListSyntax}.Partners(BracketedParameterListSyntax, BracketedParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(BracketedParameterListSyntax original, BracketedParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBracketToken,
    		    Modified = modified.OpenBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBracketToken,
    		    Modified = modified.CloseBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, BracketedParameterListSyntax, BracketedParameterListSyntax>.Partners(BracketedParameterListSyntax original, BracketedParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class DocumentationCommentTriviaServiceProvider : IPartnership<SyntaxNodeOrToken?, DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax}.Partners(DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax}.Partners(DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(DocumentationCommentTriviaSyntax original, DocumentationCommentTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax}.Partners(DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(DocumentationCommentTriviaSyntax original, DocumentationCommentTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DocumentationCommentTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax}.Partners(DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(DocumentationCommentTriviaSyntax original, DocumentationCommentTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfComment,
    		    Modified = modified.EndOfComment
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, DocumentationCommentTriviaSyntax, DocumentationCommentTriviaSyntax>.Partners(DocumentationCommentTriviaSyntax original, DocumentationCommentTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class EndIfDirectiveTriviaServiceProvider : IPartnership<SyntaxNodeOrToken?, EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax}.Partners(EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax}.Partners(EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(EndIfDirectiveTriviaSyntax original, EndIfDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax}.Partners(EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(EndIfDirectiveTriviaSyntax original, EndIfDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EndIfDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax}.Partners(EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(EndIfDirectiveTriviaSyntax original, EndIfDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndIfKeyword,
    		    Modified = modified.EndIfKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, EndIfDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax>.Partners(EndIfDirectiveTriviaSyntax original, EndIfDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class RegionDirectiveTriviaServiceProvider : IPartnership<SyntaxNodeOrToken?, RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax}.Partners(RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax}.Partners(RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(RegionDirectiveTriviaSyntax original, RegionDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax}.Partners(RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(RegionDirectiveTriviaSyntax original, RegionDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="RegionDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax}.Partners(RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(RegionDirectiveTriviaSyntax original, RegionDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.RegionKeyword,
    		    Modified = modified.RegionKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, RegionDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax>.Partners(RegionDirectiveTriviaSyntax original, RegionDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class EndRegionDirectiveTriviaServiceProvider : IPartnership<SyntaxNodeOrToken?, EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax}.Partners(EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax}.Partners(EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(EndRegionDirectiveTriviaSyntax original, EndRegionDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax}.Partners(EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(EndRegionDirectiveTriviaSyntax original, EndRegionDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EndRegionDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax}.Partners(EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(EndRegionDirectiveTriviaSyntax original, EndRegionDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndRegionKeyword,
    		    Modified = modified.EndRegionKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, EndRegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax>.Partners(EndRegionDirectiveTriviaSyntax original, EndRegionDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ErrorDirectiveTriviaServiceProvider : IPartnership<SyntaxNodeOrToken?, ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax}.Partners(ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax}.Partners(ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ErrorDirectiveTriviaSyntax original, ErrorDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax}.Partners(ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ErrorDirectiveTriviaSyntax original, ErrorDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ErrorDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax}.Partners(ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ErrorDirectiveTriviaSyntax original, ErrorDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ErrorKeyword,
    		    Modified = modified.ErrorKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ErrorDirectiveTriviaSyntax, ErrorDirectiveTriviaSyntax>.Partners(ErrorDirectiveTriviaSyntax original, ErrorDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class WarningDirectiveTriviaServiceProvider : IPartnership<SyntaxNodeOrToken?, WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax}.Partners(WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax}.Partners(WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(WarningDirectiveTriviaSyntax original, WarningDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax}.Partners(WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(WarningDirectiveTriviaSyntax original, WarningDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="WarningDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax}.Partners(WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(WarningDirectiveTriviaSyntax original, WarningDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.WarningKeyword,
    		    Modified = modified.WarningKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, WarningDirectiveTriviaSyntax, WarningDirectiveTriviaSyntax>.Partners(WarningDirectiveTriviaSyntax original, WarningDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class BadDirectiveTriviaServiceProvider : IPartnership<SyntaxNodeOrToken?, BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax}.Partners(BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax}.Partners(BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(BadDirectiveTriviaSyntax original, BadDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax}.Partners(BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(BadDirectiveTriviaSyntax original, BadDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BadDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax}.Partners(BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(BadDirectiveTriviaSyntax original, BadDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, BadDirectiveTriviaSyntax, BadDirectiveTriviaSyntax>.Partners(BadDirectiveTriviaSyntax original, BadDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class DefineDirectiveTriviaServiceProvider : IPartnership<SyntaxNodeOrToken?, DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax}.Partners(DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax}.Partners(DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(DefineDirectiveTriviaSyntax original, DefineDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax}.Partners(DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(DefineDirectiveTriviaSyntax original, DefineDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DefineDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax}.Partners(DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(DefineDirectiveTriviaSyntax original, DefineDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.DefineKeyword,
    		    Modified = modified.DefineKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Name,
    		    Modified = modified.Name
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, DefineDirectiveTriviaSyntax, DefineDirectiveTriviaSyntax>.Partners(DefineDirectiveTriviaSyntax original, DefineDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class UndefDirectiveTriviaServiceProvider : IPartnership<SyntaxNodeOrToken?, UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax}.Partners(UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax}.Partners(UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(UndefDirectiveTriviaSyntax original, UndefDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax}.Partners(UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(UndefDirectiveTriviaSyntax original, UndefDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="UndefDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax}.Partners(UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(UndefDirectiveTriviaSyntax original, UndefDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.UndefKeyword,
    		    Modified = modified.UndefKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Name,
    		    Modified = modified.Name
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, UndefDirectiveTriviaSyntax, UndefDirectiveTriviaSyntax>.Partners(UndefDirectiveTriviaSyntax original, UndefDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class LineDirectiveTriviaServiceProvider : IPartnership<SyntaxNodeOrToken?, LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax}.Partners(LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax}.Partners(LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(LineDirectiveTriviaSyntax original, LineDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax}.Partners(LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(LineDirectiveTriviaSyntax original, LineDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LineDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax}.Partners(LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(LineDirectiveTriviaSyntax original, LineDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LineKeyword,
    		    Modified = modified.LineKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Line,
    		    Modified = modified.Line
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.File,
    		    Modified = modified.File
    		};
    		if(original.File != null && modified.File != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.File != null)
    			matchingSet.Originals.DisableMatching(original.File);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.File);
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, LineDirectiveTriviaSyntax, LineDirectiveTriviaSyntax>.Partners(LineDirectiveTriviaSyntax original, LineDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class PragmaWarningDirectiveTriviaServiceProvider : IPartnership<SyntaxNodeOrToken?, PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax}.Partners(PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax}.Partners(PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(PragmaWarningDirectiveTriviaSyntax original, PragmaWarningDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax}.Partners(PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(PragmaWarningDirectiveTriviaSyntax original, PragmaWarningDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="PragmaWarningDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax}.Partners(PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(PragmaWarningDirectiveTriviaSyntax original, PragmaWarningDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.PragmaKeyword,
    		    Modified = modified.PragmaKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.WarningKeyword,
    		    Modified = modified.WarningKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.DisableOrRestoreKeyword,
    		    Modified = modified.DisableOrRestoreKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, PragmaWarningDirectiveTriviaSyntax, PragmaWarningDirectiveTriviaSyntax>.Partners(PragmaWarningDirectiveTriviaSyntax original, PragmaWarningDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class PragmaChecksumDirectiveTriviaServiceProvider : IPartnership<SyntaxNodeOrToken?, PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax}.Partners(PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax}.Partners(PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(PragmaChecksumDirectiveTriviaSyntax original, PragmaChecksumDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax}.Partners(PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(PragmaChecksumDirectiveTriviaSyntax original, PragmaChecksumDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="PragmaChecksumDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax}.Partners(PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(PragmaChecksumDirectiveTriviaSyntax original, PragmaChecksumDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.PragmaKeyword,
    		    Modified = modified.PragmaKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ChecksumKeyword,
    		    Modified = modified.ChecksumKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.File,
    		    Modified = modified.File
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Guid,
    		    Modified = modified.Guid
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Bytes,
    		    Modified = modified.Bytes
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, PragmaChecksumDirectiveTriviaSyntax, PragmaChecksumDirectiveTriviaSyntax>.Partners(PragmaChecksumDirectiveTriviaSyntax original, PragmaChecksumDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ReferenceDirectiveTriviaServiceProvider : IPartnership<SyntaxNodeOrToken?, ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax}.Partners(ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax}.Partners(ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ReferenceDirectiveTriviaSyntax original, ReferenceDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax}.Partners(ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ReferenceDirectiveTriviaSyntax original, ReferenceDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ReferenceDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax}.Partners(ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ReferenceDirectiveTriviaSyntax original, ReferenceDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ReferenceKeyword,
    		    Modified = modified.ReferenceKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.File,
    		    Modified = modified.File
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ReferenceDirectiveTriviaSyntax, ReferenceDirectiveTriviaSyntax>.Partners(ReferenceDirectiveTriviaSyntax original, ReferenceDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class LoadDirectiveTriviaServiceProvider : IPartnership<SyntaxNodeOrToken?, LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax}.Partners(LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax}.Partners(LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(LoadDirectiveTriviaSyntax original, LoadDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax}.Partners(LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(LoadDirectiveTriviaSyntax original, LoadDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LoadDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax}.Partners(LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(LoadDirectiveTriviaSyntax original, LoadDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LoadKeyword,
    		    Modified = modified.LoadKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.File,
    		    Modified = modified.File
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, LoadDirectiveTriviaSyntax, LoadDirectiveTriviaSyntax>.Partners(LoadDirectiveTriviaSyntax original, LoadDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ShebangDirectiveTriviaServiceProvider : IPartnership<SyntaxNodeOrToken?, ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax}.Partners(ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax}.Partners(ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ShebangDirectiveTriviaSyntax original, ShebangDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax}.Partners(ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ShebangDirectiveTriviaSyntax original, ShebangDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ShebangDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax}.Partners(ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ShebangDirectiveTriviaSyntax original, ShebangDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ExclamationToken,
    		    Modified = modified.ExclamationToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ShebangDirectiveTriviaSyntax, ShebangDirectiveTriviaSyntax>.Partners(ShebangDirectiveTriviaSyntax original, ShebangDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ElseDirectiveTriviaServiceProvider : IPartnership<SyntaxNodeOrToken?, ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax}.Partners(ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax}.Partners(ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ElseDirectiveTriviaSyntax original, ElseDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax}.Partners(ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ElseDirectiveTriviaSyntax original, ElseDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ElseDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax}.Partners(ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ElseDirectiveTriviaSyntax original, ElseDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ElseKeyword,
    		    Modified = modified.ElseKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ElseDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax>.Partners(ElseDirectiveTriviaSyntax original, ElseDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class IfDirectiveTriviaServiceProvider : IPartnership<SyntaxNodeOrToken?, IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax}.Partners(IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax}.Partners(IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(IfDirectiveTriviaSyntax original, IfDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax}.Partners(IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(IfDirectiveTriviaSyntax original, IfDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="IfDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax}.Partners(IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(IfDirectiveTriviaSyntax original, IfDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.IfKeyword,
    		    Modified = modified.IfKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax>.Partners(IfDirectiveTriviaSyntax original, IfDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ElifDirectiveTriviaServiceProvider : IPartnership<SyntaxNodeOrToken?, ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax}.Partners(ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax}.Partners(ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ElifDirectiveTriviaSyntax original, ElifDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax}.Partners(ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ElifDirectiveTriviaSyntax original, ElifDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ElifDirectiveTriviaSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax}.Partners(ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ElifDirectiveTriviaSyntax original, ElifDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.HashToken,
    		    Modified = modified.HashToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ElifKeyword,
    		    Modified = modified.ElifKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndOfDirectiveToken,
    		    Modified = modified.EndOfDirectiveToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ElifDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax>.Partners(ElifDirectiveTriviaSyntax original, ElifDirectiveTriviaSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class QualifiedCrefServiceProvider : IPartnership<SyntaxNodeOrToken?, QualifiedCrefSyntax, QualifiedCrefSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(QualifiedCrefSyntax, QualifiedCrefSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, QualifiedCrefSyntax, QualifiedCrefSyntax}.Partners(QualifiedCrefSyntax, QualifiedCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(QualifiedCrefSyntax, QualifiedCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, QualifiedCrefSyntax, QualifiedCrefSyntax}.Partners(QualifiedCrefSyntax, QualifiedCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(QualifiedCrefSyntax original, QualifiedCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(QualifiedCrefSyntax, QualifiedCrefSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, QualifiedCrefSyntax, QualifiedCrefSyntax}.Partners(QualifiedCrefSyntax, QualifiedCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(QualifiedCrefSyntax original, QualifiedCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="QualifiedCrefSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, QualifiedCrefSyntax, QualifiedCrefSyntax}.Partners(QualifiedCrefSyntax, QualifiedCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(QualifiedCrefSyntax original, QualifiedCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.DotToken,
    		    Modified = modified.DotToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, QualifiedCrefSyntax, QualifiedCrefSyntax>.Partners(QualifiedCrefSyntax original, QualifiedCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class IndexerMemberCrefServiceProvider : IPartnership<SyntaxNodeOrToken?, IndexerMemberCrefSyntax, IndexerMemberCrefSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(IndexerMemberCrefSyntax, IndexerMemberCrefSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, IndexerMemberCrefSyntax, IndexerMemberCrefSyntax}.Partners(IndexerMemberCrefSyntax, IndexerMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(IndexerMemberCrefSyntax, IndexerMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, IndexerMemberCrefSyntax, IndexerMemberCrefSyntax}.Partners(IndexerMemberCrefSyntax, IndexerMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(IndexerMemberCrefSyntax original, IndexerMemberCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(IndexerMemberCrefSyntax, IndexerMemberCrefSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, IndexerMemberCrefSyntax, IndexerMemberCrefSyntax}.Partners(IndexerMemberCrefSyntax, IndexerMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(IndexerMemberCrefSyntax original, IndexerMemberCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="IndexerMemberCrefSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, IndexerMemberCrefSyntax, IndexerMemberCrefSyntax}.Partners(IndexerMemberCrefSyntax, IndexerMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(IndexerMemberCrefSyntax original, IndexerMemberCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ThisKeyword,
    		    Modified = modified.ThisKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, IndexerMemberCrefSyntax, IndexerMemberCrefSyntax>.Partners(IndexerMemberCrefSyntax original, IndexerMemberCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class OperatorMemberCrefServiceProvider : IPartnership<SyntaxNodeOrToken?, OperatorMemberCrefSyntax, OperatorMemberCrefSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(OperatorMemberCrefSyntax, OperatorMemberCrefSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, OperatorMemberCrefSyntax, OperatorMemberCrefSyntax}.Partners(OperatorMemberCrefSyntax, OperatorMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(OperatorMemberCrefSyntax, OperatorMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, OperatorMemberCrefSyntax, OperatorMemberCrefSyntax}.Partners(OperatorMemberCrefSyntax, OperatorMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(OperatorMemberCrefSyntax original, OperatorMemberCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(OperatorMemberCrefSyntax, OperatorMemberCrefSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, OperatorMemberCrefSyntax, OperatorMemberCrefSyntax}.Partners(OperatorMemberCrefSyntax, OperatorMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(OperatorMemberCrefSyntax original, OperatorMemberCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="OperatorMemberCrefSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, OperatorMemberCrefSyntax, OperatorMemberCrefSyntax}.Partners(OperatorMemberCrefSyntax, OperatorMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(OperatorMemberCrefSyntax original, OperatorMemberCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorKeyword,
    		    Modified = modified.OperatorKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorToken,
    		    Modified = modified.OperatorToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, OperatorMemberCrefSyntax, OperatorMemberCrefSyntax>.Partners(OperatorMemberCrefSyntax original, OperatorMemberCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ConversionOperatorMemberCrefServiceProvider : IPartnership<SyntaxNodeOrToken?, ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax}.Partners(ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax}.Partners(ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ConversionOperatorMemberCrefSyntax original, ConversionOperatorMemberCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax}.Partners(ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ConversionOperatorMemberCrefSyntax original, ConversionOperatorMemberCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ConversionOperatorMemberCrefSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax}.Partners(ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ConversionOperatorMemberCrefSyntax original, ConversionOperatorMemberCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ImplicitOrExplicitKeyword,
    		    Modified = modified.ImplicitOrExplicitKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorKeyword,
    		    Modified = modified.OperatorKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ConversionOperatorMemberCrefSyntax, ConversionOperatorMemberCrefSyntax>.Partners(ConversionOperatorMemberCrefSyntax original, ConversionOperatorMemberCrefSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class CrefParameterListServiceProvider : IPartnership<SyntaxNodeOrToken?, CrefParameterListSyntax, CrefParameterListSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(CrefParameterListSyntax, CrefParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, CrefParameterListSyntax, CrefParameterListSyntax}.Partners(CrefParameterListSyntax, CrefParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(CrefParameterListSyntax, CrefParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, CrefParameterListSyntax, CrefParameterListSyntax}.Partners(CrefParameterListSyntax, CrefParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(CrefParameterListSyntax original, CrefParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(CrefParameterListSyntax, CrefParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, CrefParameterListSyntax, CrefParameterListSyntax}.Partners(CrefParameterListSyntax, CrefParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(CrefParameterListSyntax original, CrefParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CrefParameterListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, CrefParameterListSyntax, CrefParameterListSyntax}.Partners(CrefParameterListSyntax, CrefParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(CrefParameterListSyntax original, CrefParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, CrefParameterListSyntax, CrefParameterListSyntax>.Partners(CrefParameterListSyntax original, CrefParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class CrefBracketedParameterListServiceProvider : IPartnership<SyntaxNodeOrToken?, CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax}.Partners(CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax}.Partners(CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(CrefBracketedParameterListSyntax original, CrefBracketedParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax}.Partners(CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(CrefBracketedParameterListSyntax original, CrefBracketedParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CrefBracketedParameterListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax}.Partners(CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(CrefBracketedParameterListSyntax original, CrefBracketedParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBracketToken,
    		    Modified = modified.OpenBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBracketToken,
    		    Modified = modified.CloseBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, CrefBracketedParameterListSyntax, CrefBracketedParameterListSyntax>.Partners(CrefBracketedParameterListSyntax original, CrefBracketedParameterListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class XmlEmptyElementServiceProvider : IPartnership<SyntaxNodeOrToken?, XmlEmptyElementSyntax, XmlEmptyElementSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(XmlEmptyElementSyntax, XmlEmptyElementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, XmlEmptyElementSyntax, XmlEmptyElementSyntax}.Partners(XmlEmptyElementSyntax, XmlEmptyElementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(XmlEmptyElementSyntax, XmlEmptyElementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, XmlEmptyElementSyntax, XmlEmptyElementSyntax}.Partners(XmlEmptyElementSyntax, XmlEmptyElementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(XmlEmptyElementSyntax original, XmlEmptyElementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(XmlEmptyElementSyntax, XmlEmptyElementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, XmlEmptyElementSyntax, XmlEmptyElementSyntax}.Partners(XmlEmptyElementSyntax, XmlEmptyElementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(XmlEmptyElementSyntax original, XmlEmptyElementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlEmptyElementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, XmlEmptyElementSyntax, XmlEmptyElementSyntax}.Partners(XmlEmptyElementSyntax, XmlEmptyElementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(XmlEmptyElementSyntax original, XmlEmptyElementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LessThanToken,
    		    Modified = modified.LessThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SlashGreaterThanToken,
    		    Modified = modified.SlashGreaterThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, XmlEmptyElementSyntax, XmlEmptyElementSyntax>.Partners(XmlEmptyElementSyntax original, XmlEmptyElementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class XmlCDataSectionServiceProvider : IPartnership<SyntaxNodeOrToken?, XmlCDataSectionSyntax, XmlCDataSectionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(XmlCDataSectionSyntax, XmlCDataSectionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, XmlCDataSectionSyntax, XmlCDataSectionSyntax}.Partners(XmlCDataSectionSyntax, XmlCDataSectionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(XmlCDataSectionSyntax, XmlCDataSectionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, XmlCDataSectionSyntax, XmlCDataSectionSyntax}.Partners(XmlCDataSectionSyntax, XmlCDataSectionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(XmlCDataSectionSyntax original, XmlCDataSectionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(XmlCDataSectionSyntax, XmlCDataSectionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, XmlCDataSectionSyntax, XmlCDataSectionSyntax}.Partners(XmlCDataSectionSyntax, XmlCDataSectionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(XmlCDataSectionSyntax original, XmlCDataSectionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlCDataSectionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, XmlCDataSectionSyntax, XmlCDataSectionSyntax}.Partners(XmlCDataSectionSyntax, XmlCDataSectionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(XmlCDataSectionSyntax original, XmlCDataSectionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.StartCDataToken,
    		    Modified = modified.StartCDataToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndCDataToken,
    		    Modified = modified.EndCDataToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, XmlCDataSectionSyntax, XmlCDataSectionSyntax>.Partners(XmlCDataSectionSyntax original, XmlCDataSectionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class XmlProcessingInstructionServiceProvider : IPartnership<SyntaxNodeOrToken?, XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax}.Partners(XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax}.Partners(XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(XmlProcessingInstructionSyntax original, XmlProcessingInstructionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax}.Partners(XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(XmlProcessingInstructionSyntax original, XmlProcessingInstructionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlProcessingInstructionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax}.Partners(XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(XmlProcessingInstructionSyntax original, XmlProcessingInstructionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.StartProcessingInstructionToken,
    		    Modified = modified.StartProcessingInstructionToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndProcessingInstructionToken,
    		    Modified = modified.EndProcessingInstructionToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, XmlProcessingInstructionSyntax, XmlProcessingInstructionSyntax>.Partners(XmlProcessingInstructionSyntax original, XmlProcessingInstructionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class XmlCommentServiceProvider : IPartnership<SyntaxNodeOrToken?, XmlCommentSyntax, XmlCommentSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(XmlCommentSyntax, XmlCommentSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, XmlCommentSyntax, XmlCommentSyntax}.Partners(XmlCommentSyntax, XmlCommentSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(XmlCommentSyntax, XmlCommentSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, XmlCommentSyntax, XmlCommentSyntax}.Partners(XmlCommentSyntax, XmlCommentSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(XmlCommentSyntax original, XmlCommentSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(XmlCommentSyntax, XmlCommentSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, XmlCommentSyntax, XmlCommentSyntax}.Partners(XmlCommentSyntax, XmlCommentSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(XmlCommentSyntax original, XmlCommentSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlCommentSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, XmlCommentSyntax, XmlCommentSyntax}.Partners(XmlCommentSyntax, XmlCommentSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(XmlCommentSyntax original, XmlCommentSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LessThanExclamationMinusMinusToken,
    		    Modified = modified.LessThanExclamationMinusMinusToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.MinusMinusGreaterThanToken,
    		    Modified = modified.MinusMinusGreaterThanToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, XmlCommentSyntax, XmlCommentSyntax>.Partners(XmlCommentSyntax original, XmlCommentSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class XmlTextAttributeServiceProvider : IPartnership<SyntaxNodeOrToken?, XmlTextAttributeSyntax, XmlTextAttributeSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(XmlTextAttributeSyntax, XmlTextAttributeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, XmlTextAttributeSyntax, XmlTextAttributeSyntax}.Partners(XmlTextAttributeSyntax, XmlTextAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(XmlTextAttributeSyntax, XmlTextAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, XmlTextAttributeSyntax, XmlTextAttributeSyntax}.Partners(XmlTextAttributeSyntax, XmlTextAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(XmlTextAttributeSyntax original, XmlTextAttributeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(XmlTextAttributeSyntax, XmlTextAttributeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, XmlTextAttributeSyntax, XmlTextAttributeSyntax}.Partners(XmlTextAttributeSyntax, XmlTextAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(XmlTextAttributeSyntax original, XmlTextAttributeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlTextAttributeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, XmlTextAttributeSyntax, XmlTextAttributeSyntax}.Partners(XmlTextAttributeSyntax, XmlTextAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(XmlTextAttributeSyntax original, XmlTextAttributeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EqualsToken,
    		    Modified = modified.EqualsToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.StartQuoteToken,
    		    Modified = modified.StartQuoteToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndQuoteToken,
    		    Modified = modified.EndQuoteToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, XmlTextAttributeSyntax, XmlTextAttributeSyntax>.Partners(XmlTextAttributeSyntax original, XmlTextAttributeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class XmlCrefAttributeServiceProvider : IPartnership<SyntaxNodeOrToken?, XmlCrefAttributeSyntax, XmlCrefAttributeSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(XmlCrefAttributeSyntax, XmlCrefAttributeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, XmlCrefAttributeSyntax, XmlCrefAttributeSyntax}.Partners(XmlCrefAttributeSyntax, XmlCrefAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(XmlCrefAttributeSyntax, XmlCrefAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, XmlCrefAttributeSyntax, XmlCrefAttributeSyntax}.Partners(XmlCrefAttributeSyntax, XmlCrefAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(XmlCrefAttributeSyntax original, XmlCrefAttributeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(XmlCrefAttributeSyntax, XmlCrefAttributeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, XmlCrefAttributeSyntax, XmlCrefAttributeSyntax}.Partners(XmlCrefAttributeSyntax, XmlCrefAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(XmlCrefAttributeSyntax original, XmlCrefAttributeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlCrefAttributeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, XmlCrefAttributeSyntax, XmlCrefAttributeSyntax}.Partners(XmlCrefAttributeSyntax, XmlCrefAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(XmlCrefAttributeSyntax original, XmlCrefAttributeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EqualsToken,
    		    Modified = modified.EqualsToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.StartQuoteToken,
    		    Modified = modified.StartQuoteToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndQuoteToken,
    		    Modified = modified.EndQuoteToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, XmlCrefAttributeSyntax, XmlCrefAttributeSyntax>.Partners(XmlCrefAttributeSyntax original, XmlCrefAttributeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class XmlNameAttributeServiceProvider : IPartnership<SyntaxNodeOrToken?, XmlNameAttributeSyntax, XmlNameAttributeSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(XmlNameAttributeSyntax, XmlNameAttributeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, XmlNameAttributeSyntax, XmlNameAttributeSyntax}.Partners(XmlNameAttributeSyntax, XmlNameAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(XmlNameAttributeSyntax, XmlNameAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, XmlNameAttributeSyntax, XmlNameAttributeSyntax}.Partners(XmlNameAttributeSyntax, XmlNameAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(XmlNameAttributeSyntax original, XmlNameAttributeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(XmlNameAttributeSyntax, XmlNameAttributeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, XmlNameAttributeSyntax, XmlNameAttributeSyntax}.Partners(XmlNameAttributeSyntax, XmlNameAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(XmlNameAttributeSyntax original, XmlNameAttributeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="XmlNameAttributeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, XmlNameAttributeSyntax, XmlNameAttributeSyntax}.Partners(XmlNameAttributeSyntax, XmlNameAttributeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(XmlNameAttributeSyntax original, XmlNameAttributeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EqualsToken,
    		    Modified = modified.EqualsToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.StartQuoteToken,
    		    Modified = modified.StartQuoteToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EndQuoteToken,
    		    Modified = modified.EndQuoteToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, XmlNameAttributeSyntax, XmlNameAttributeSyntax>.Partners(XmlNameAttributeSyntax original, XmlNameAttributeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ParenthesizedExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax}.Partners(ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax}.Partners(ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ParenthesizedExpressionSyntax original, ParenthesizedExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax}.Partners(ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ParenthesizedExpressionSyntax original, ParenthesizedExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ParenthesizedExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax}.Partners(ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ParenthesizedExpressionSyntax original, ParenthesizedExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ParenthesizedExpressionSyntax, ParenthesizedExpressionSyntax>.Partners(ParenthesizedExpressionSyntax original, ParenthesizedExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class TupleExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, TupleExpressionSyntax, TupleExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(TupleExpressionSyntax, TupleExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, TupleExpressionSyntax, TupleExpressionSyntax}.Partners(TupleExpressionSyntax, TupleExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(TupleExpressionSyntax, TupleExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, TupleExpressionSyntax, TupleExpressionSyntax}.Partners(TupleExpressionSyntax, TupleExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(TupleExpressionSyntax original, TupleExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(TupleExpressionSyntax, TupleExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, TupleExpressionSyntax, TupleExpressionSyntax}.Partners(TupleExpressionSyntax, TupleExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(TupleExpressionSyntax original, TupleExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TupleExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, TupleExpressionSyntax, TupleExpressionSyntax}.Partners(TupleExpressionSyntax, TupleExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(TupleExpressionSyntax original, TupleExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, TupleExpressionSyntax, TupleExpressionSyntax>.Partners(TupleExpressionSyntax original, TupleExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class PrefixUnaryExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax}.Partners(PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax}.Partners(PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(PrefixUnaryExpressionSyntax original, PrefixUnaryExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax}.Partners(PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(PrefixUnaryExpressionSyntax original, PrefixUnaryExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="PrefixUnaryExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax}.Partners(PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(PrefixUnaryExpressionSyntax original, PrefixUnaryExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorToken,
    		    Modified = modified.OperatorToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, PrefixUnaryExpressionSyntax, PrefixUnaryExpressionSyntax>.Partners(PrefixUnaryExpressionSyntax original, PrefixUnaryExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class AwaitExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, AwaitExpressionSyntax, AwaitExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(AwaitExpressionSyntax, AwaitExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, AwaitExpressionSyntax, AwaitExpressionSyntax}.Partners(AwaitExpressionSyntax, AwaitExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(AwaitExpressionSyntax, AwaitExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, AwaitExpressionSyntax, AwaitExpressionSyntax}.Partners(AwaitExpressionSyntax, AwaitExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(AwaitExpressionSyntax original, AwaitExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(AwaitExpressionSyntax, AwaitExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, AwaitExpressionSyntax, AwaitExpressionSyntax}.Partners(AwaitExpressionSyntax, AwaitExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(AwaitExpressionSyntax original, AwaitExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AwaitExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, AwaitExpressionSyntax, AwaitExpressionSyntax}.Partners(AwaitExpressionSyntax, AwaitExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(AwaitExpressionSyntax original, AwaitExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.AwaitKeyword,
    		    Modified = modified.AwaitKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, AwaitExpressionSyntax, AwaitExpressionSyntax>.Partners(AwaitExpressionSyntax original, AwaitExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class PostfixUnaryExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax}.Partners(PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax}.Partners(PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(PostfixUnaryExpressionSyntax original, PostfixUnaryExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax}.Partners(PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(PostfixUnaryExpressionSyntax original, PostfixUnaryExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="PostfixUnaryExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax}.Partners(PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(PostfixUnaryExpressionSyntax original, PostfixUnaryExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorToken,
    		    Modified = modified.OperatorToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, PostfixUnaryExpressionSyntax, PostfixUnaryExpressionSyntax>.Partners(PostfixUnaryExpressionSyntax original, PostfixUnaryExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class MemberAccessExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, MemberAccessExpressionSyntax, MemberAccessExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(MemberAccessExpressionSyntax, MemberAccessExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, MemberAccessExpressionSyntax, MemberAccessExpressionSyntax}.Partners(MemberAccessExpressionSyntax, MemberAccessExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MemberAccessExpressionSyntax, MemberAccessExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, MemberAccessExpressionSyntax, MemberAccessExpressionSyntax}.Partners(MemberAccessExpressionSyntax, MemberAccessExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MemberAccessExpressionSyntax original, MemberAccessExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(MemberAccessExpressionSyntax, MemberAccessExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, MemberAccessExpressionSyntax, MemberAccessExpressionSyntax}.Partners(MemberAccessExpressionSyntax, MemberAccessExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(MemberAccessExpressionSyntax original, MemberAccessExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="MemberAccessExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, MemberAccessExpressionSyntax, MemberAccessExpressionSyntax}.Partners(MemberAccessExpressionSyntax, MemberAccessExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MemberAccessExpressionSyntax original, MemberAccessExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorToken,
    		    Modified = modified.OperatorToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, MemberAccessExpressionSyntax, MemberAccessExpressionSyntax>.Partners(MemberAccessExpressionSyntax original, MemberAccessExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ConditionalAccessExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax}.Partners(ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax}.Partners(ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ConditionalAccessExpressionSyntax original, ConditionalAccessExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax}.Partners(ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ConditionalAccessExpressionSyntax original, ConditionalAccessExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ConditionalAccessExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax}.Partners(ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ConditionalAccessExpressionSyntax original, ConditionalAccessExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorToken,
    		    Modified = modified.OperatorToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ConditionalAccessExpressionSyntax, ConditionalAccessExpressionSyntax>.Partners(ConditionalAccessExpressionSyntax original, ConditionalAccessExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class MemberBindingExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, MemberBindingExpressionSyntax, MemberBindingExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(MemberBindingExpressionSyntax, MemberBindingExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, MemberBindingExpressionSyntax, MemberBindingExpressionSyntax}.Partners(MemberBindingExpressionSyntax, MemberBindingExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MemberBindingExpressionSyntax, MemberBindingExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, MemberBindingExpressionSyntax, MemberBindingExpressionSyntax}.Partners(MemberBindingExpressionSyntax, MemberBindingExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MemberBindingExpressionSyntax original, MemberBindingExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(MemberBindingExpressionSyntax, MemberBindingExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, MemberBindingExpressionSyntax, MemberBindingExpressionSyntax}.Partners(MemberBindingExpressionSyntax, MemberBindingExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(MemberBindingExpressionSyntax original, MemberBindingExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="MemberBindingExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, MemberBindingExpressionSyntax, MemberBindingExpressionSyntax}.Partners(MemberBindingExpressionSyntax, MemberBindingExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MemberBindingExpressionSyntax original, MemberBindingExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorToken,
    		    Modified = modified.OperatorToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, MemberBindingExpressionSyntax, MemberBindingExpressionSyntax>.Partners(MemberBindingExpressionSyntax original, MemberBindingExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class BinaryExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, BinaryExpressionSyntax, BinaryExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(BinaryExpressionSyntax, BinaryExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, BinaryExpressionSyntax, BinaryExpressionSyntax}.Partners(BinaryExpressionSyntax, BinaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(BinaryExpressionSyntax, BinaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, BinaryExpressionSyntax, BinaryExpressionSyntax}.Partners(BinaryExpressionSyntax, BinaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(BinaryExpressionSyntax original, BinaryExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(BinaryExpressionSyntax, BinaryExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, BinaryExpressionSyntax, BinaryExpressionSyntax}.Partners(BinaryExpressionSyntax, BinaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(BinaryExpressionSyntax original, BinaryExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BinaryExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, BinaryExpressionSyntax, BinaryExpressionSyntax}.Partners(BinaryExpressionSyntax, BinaryExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(BinaryExpressionSyntax original, BinaryExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorToken,
    		    Modified = modified.OperatorToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, BinaryExpressionSyntax, BinaryExpressionSyntax>.Partners(BinaryExpressionSyntax original, BinaryExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class AssignmentExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, AssignmentExpressionSyntax, AssignmentExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(AssignmentExpressionSyntax, AssignmentExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, AssignmentExpressionSyntax, AssignmentExpressionSyntax}.Partners(AssignmentExpressionSyntax, AssignmentExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(AssignmentExpressionSyntax, AssignmentExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, AssignmentExpressionSyntax, AssignmentExpressionSyntax}.Partners(AssignmentExpressionSyntax, AssignmentExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(AssignmentExpressionSyntax original, AssignmentExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(AssignmentExpressionSyntax, AssignmentExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, AssignmentExpressionSyntax, AssignmentExpressionSyntax}.Partners(AssignmentExpressionSyntax, AssignmentExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(AssignmentExpressionSyntax original, AssignmentExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AssignmentExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, AssignmentExpressionSyntax, AssignmentExpressionSyntax}.Partners(AssignmentExpressionSyntax, AssignmentExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(AssignmentExpressionSyntax original, AssignmentExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OperatorToken,
    		    Modified = modified.OperatorToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, AssignmentExpressionSyntax, AssignmentExpressionSyntax>.Partners(AssignmentExpressionSyntax original, AssignmentExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ConditionalExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, ConditionalExpressionSyntax, ConditionalExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ConditionalExpressionSyntax, ConditionalExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ConditionalExpressionSyntax, ConditionalExpressionSyntax}.Partners(ConditionalExpressionSyntax, ConditionalExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ConditionalExpressionSyntax, ConditionalExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ConditionalExpressionSyntax, ConditionalExpressionSyntax}.Partners(ConditionalExpressionSyntax, ConditionalExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ConditionalExpressionSyntax original, ConditionalExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ConditionalExpressionSyntax, ConditionalExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ConditionalExpressionSyntax, ConditionalExpressionSyntax}.Partners(ConditionalExpressionSyntax, ConditionalExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ConditionalExpressionSyntax original, ConditionalExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ConditionalExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ConditionalExpressionSyntax, ConditionalExpressionSyntax}.Partners(ConditionalExpressionSyntax, ConditionalExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ConditionalExpressionSyntax original, ConditionalExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.QuestionToken,
    		    Modified = modified.QuestionToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ConditionalExpressionSyntax, ConditionalExpressionSyntax>.Partners(ConditionalExpressionSyntax original, ConditionalExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class LiteralExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, LiteralExpressionSyntax, LiteralExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(LiteralExpressionSyntax, LiteralExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, LiteralExpressionSyntax, LiteralExpressionSyntax}.Partners(LiteralExpressionSyntax, LiteralExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(LiteralExpressionSyntax, LiteralExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, LiteralExpressionSyntax, LiteralExpressionSyntax}.Partners(LiteralExpressionSyntax, LiteralExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(LiteralExpressionSyntax original, LiteralExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(LiteralExpressionSyntax, LiteralExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, LiteralExpressionSyntax, LiteralExpressionSyntax}.Partners(LiteralExpressionSyntax, LiteralExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(LiteralExpressionSyntax original, LiteralExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LiteralExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, LiteralExpressionSyntax, LiteralExpressionSyntax}.Partners(LiteralExpressionSyntax, LiteralExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(LiteralExpressionSyntax original, LiteralExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Token,
    		    Modified = modified.Token
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, LiteralExpressionSyntax, LiteralExpressionSyntax>.Partners(LiteralExpressionSyntax original, LiteralExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class MakeRefExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, MakeRefExpressionSyntax, MakeRefExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(MakeRefExpressionSyntax, MakeRefExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, MakeRefExpressionSyntax, MakeRefExpressionSyntax}.Partners(MakeRefExpressionSyntax, MakeRefExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(MakeRefExpressionSyntax, MakeRefExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, MakeRefExpressionSyntax, MakeRefExpressionSyntax}.Partners(MakeRefExpressionSyntax, MakeRefExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(MakeRefExpressionSyntax original, MakeRefExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(MakeRefExpressionSyntax, MakeRefExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, MakeRefExpressionSyntax, MakeRefExpressionSyntax}.Partners(MakeRefExpressionSyntax, MakeRefExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(MakeRefExpressionSyntax original, MakeRefExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="MakeRefExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, MakeRefExpressionSyntax, MakeRefExpressionSyntax}.Partners(MakeRefExpressionSyntax, MakeRefExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(MakeRefExpressionSyntax original, MakeRefExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, MakeRefExpressionSyntax, MakeRefExpressionSyntax>.Partners(MakeRefExpressionSyntax original, MakeRefExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class RefTypeExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, RefTypeExpressionSyntax, RefTypeExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(RefTypeExpressionSyntax, RefTypeExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, RefTypeExpressionSyntax, RefTypeExpressionSyntax}.Partners(RefTypeExpressionSyntax, RefTypeExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(RefTypeExpressionSyntax, RefTypeExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, RefTypeExpressionSyntax, RefTypeExpressionSyntax}.Partners(RefTypeExpressionSyntax, RefTypeExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(RefTypeExpressionSyntax original, RefTypeExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(RefTypeExpressionSyntax, RefTypeExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, RefTypeExpressionSyntax, RefTypeExpressionSyntax}.Partners(RefTypeExpressionSyntax, RefTypeExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(RefTypeExpressionSyntax original, RefTypeExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="RefTypeExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, RefTypeExpressionSyntax, RefTypeExpressionSyntax}.Partners(RefTypeExpressionSyntax, RefTypeExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(RefTypeExpressionSyntax original, RefTypeExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, RefTypeExpressionSyntax, RefTypeExpressionSyntax>.Partners(RefTypeExpressionSyntax original, RefTypeExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class RefValueExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, RefValueExpressionSyntax, RefValueExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(RefValueExpressionSyntax, RefValueExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, RefValueExpressionSyntax, RefValueExpressionSyntax}.Partners(RefValueExpressionSyntax, RefValueExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(RefValueExpressionSyntax, RefValueExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, RefValueExpressionSyntax, RefValueExpressionSyntax}.Partners(RefValueExpressionSyntax, RefValueExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(RefValueExpressionSyntax original, RefValueExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(RefValueExpressionSyntax, RefValueExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, RefValueExpressionSyntax, RefValueExpressionSyntax}.Partners(RefValueExpressionSyntax, RefValueExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(RefValueExpressionSyntax original, RefValueExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="RefValueExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, RefValueExpressionSyntax, RefValueExpressionSyntax}.Partners(RefValueExpressionSyntax, RefValueExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(RefValueExpressionSyntax original, RefValueExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Comma,
    		    Modified = modified.Comma
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, RefValueExpressionSyntax, RefValueExpressionSyntax>.Partners(RefValueExpressionSyntax original, RefValueExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class CheckedExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, CheckedExpressionSyntax, CheckedExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(CheckedExpressionSyntax, CheckedExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, CheckedExpressionSyntax, CheckedExpressionSyntax}.Partners(CheckedExpressionSyntax, CheckedExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(CheckedExpressionSyntax, CheckedExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, CheckedExpressionSyntax, CheckedExpressionSyntax}.Partners(CheckedExpressionSyntax, CheckedExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(CheckedExpressionSyntax original, CheckedExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(CheckedExpressionSyntax, CheckedExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, CheckedExpressionSyntax, CheckedExpressionSyntax}.Partners(CheckedExpressionSyntax, CheckedExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(CheckedExpressionSyntax original, CheckedExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CheckedExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, CheckedExpressionSyntax, CheckedExpressionSyntax}.Partners(CheckedExpressionSyntax, CheckedExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(CheckedExpressionSyntax original, CheckedExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, CheckedExpressionSyntax, CheckedExpressionSyntax>.Partners(CheckedExpressionSyntax original, CheckedExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class DefaultExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, DefaultExpressionSyntax, DefaultExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(DefaultExpressionSyntax, DefaultExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, DefaultExpressionSyntax, DefaultExpressionSyntax}.Partners(DefaultExpressionSyntax, DefaultExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(DefaultExpressionSyntax, DefaultExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, DefaultExpressionSyntax, DefaultExpressionSyntax}.Partners(DefaultExpressionSyntax, DefaultExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(DefaultExpressionSyntax original, DefaultExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(DefaultExpressionSyntax, DefaultExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, DefaultExpressionSyntax, DefaultExpressionSyntax}.Partners(DefaultExpressionSyntax, DefaultExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(DefaultExpressionSyntax original, DefaultExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DefaultExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, DefaultExpressionSyntax, DefaultExpressionSyntax}.Partners(DefaultExpressionSyntax, DefaultExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(DefaultExpressionSyntax original, DefaultExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, DefaultExpressionSyntax, DefaultExpressionSyntax>.Partners(DefaultExpressionSyntax original, DefaultExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class TypeOfExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, TypeOfExpressionSyntax, TypeOfExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(TypeOfExpressionSyntax, TypeOfExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, TypeOfExpressionSyntax, TypeOfExpressionSyntax}.Partners(TypeOfExpressionSyntax, TypeOfExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(TypeOfExpressionSyntax, TypeOfExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, TypeOfExpressionSyntax, TypeOfExpressionSyntax}.Partners(TypeOfExpressionSyntax, TypeOfExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(TypeOfExpressionSyntax original, TypeOfExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(TypeOfExpressionSyntax, TypeOfExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, TypeOfExpressionSyntax, TypeOfExpressionSyntax}.Partners(TypeOfExpressionSyntax, TypeOfExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(TypeOfExpressionSyntax original, TypeOfExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TypeOfExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, TypeOfExpressionSyntax, TypeOfExpressionSyntax}.Partners(TypeOfExpressionSyntax, TypeOfExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(TypeOfExpressionSyntax original, TypeOfExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, TypeOfExpressionSyntax, TypeOfExpressionSyntax>.Partners(TypeOfExpressionSyntax original, TypeOfExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class SizeOfExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, SizeOfExpressionSyntax, SizeOfExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(SizeOfExpressionSyntax, SizeOfExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, SizeOfExpressionSyntax, SizeOfExpressionSyntax}.Partners(SizeOfExpressionSyntax, SizeOfExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(SizeOfExpressionSyntax, SizeOfExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, SizeOfExpressionSyntax, SizeOfExpressionSyntax}.Partners(SizeOfExpressionSyntax, SizeOfExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(SizeOfExpressionSyntax original, SizeOfExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(SizeOfExpressionSyntax, SizeOfExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, SizeOfExpressionSyntax, SizeOfExpressionSyntax}.Partners(SizeOfExpressionSyntax, SizeOfExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(SizeOfExpressionSyntax original, SizeOfExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="SizeOfExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, SizeOfExpressionSyntax, SizeOfExpressionSyntax}.Partners(SizeOfExpressionSyntax, SizeOfExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(SizeOfExpressionSyntax original, SizeOfExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, SizeOfExpressionSyntax, SizeOfExpressionSyntax>.Partners(SizeOfExpressionSyntax original, SizeOfExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class CastExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, CastExpressionSyntax, CastExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(CastExpressionSyntax, CastExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, CastExpressionSyntax, CastExpressionSyntax}.Partners(CastExpressionSyntax, CastExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(CastExpressionSyntax, CastExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, CastExpressionSyntax, CastExpressionSyntax}.Partners(CastExpressionSyntax, CastExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(CastExpressionSyntax original, CastExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(CastExpressionSyntax, CastExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, CastExpressionSyntax, CastExpressionSyntax}.Partners(CastExpressionSyntax, CastExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(CastExpressionSyntax original, CastExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CastExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, CastExpressionSyntax, CastExpressionSyntax}.Partners(CastExpressionSyntax, CastExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(CastExpressionSyntax original, CastExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, CastExpressionSyntax, CastExpressionSyntax>.Partners(CastExpressionSyntax original, CastExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class RefExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, RefExpressionSyntax, RefExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(RefExpressionSyntax, RefExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, RefExpressionSyntax, RefExpressionSyntax}.Partners(RefExpressionSyntax, RefExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(RefExpressionSyntax, RefExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, RefExpressionSyntax, RefExpressionSyntax}.Partners(RefExpressionSyntax, RefExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(RefExpressionSyntax original, RefExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(RefExpressionSyntax, RefExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, RefExpressionSyntax, RefExpressionSyntax}.Partners(RefExpressionSyntax, RefExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(RefExpressionSyntax original, RefExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="RefExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, RefExpressionSyntax, RefExpressionSyntax}.Partners(RefExpressionSyntax, RefExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(RefExpressionSyntax original, RefExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.RefKeyword,
    		    Modified = modified.RefKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, RefExpressionSyntax, RefExpressionSyntax>.Partners(RefExpressionSyntax original, RefExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class InitializerExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, InitializerExpressionSyntax, InitializerExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(InitializerExpressionSyntax, InitializerExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, InitializerExpressionSyntax, InitializerExpressionSyntax}.Partners(InitializerExpressionSyntax, InitializerExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(InitializerExpressionSyntax, InitializerExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, InitializerExpressionSyntax, InitializerExpressionSyntax}.Partners(InitializerExpressionSyntax, InitializerExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(InitializerExpressionSyntax original, InitializerExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(InitializerExpressionSyntax, InitializerExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, InitializerExpressionSyntax, InitializerExpressionSyntax}.Partners(InitializerExpressionSyntax, InitializerExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(InitializerExpressionSyntax original, InitializerExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="InitializerExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, InitializerExpressionSyntax, InitializerExpressionSyntax}.Partners(InitializerExpressionSyntax, InitializerExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(InitializerExpressionSyntax original, InitializerExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, InitializerExpressionSyntax, InitializerExpressionSyntax>.Partners(InitializerExpressionSyntax original, InitializerExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ObjectCreationExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax}.Partners(ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax}.Partners(ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ObjectCreationExpressionSyntax original, ObjectCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax}.Partners(ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ObjectCreationExpressionSyntax original, ObjectCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ObjectCreationExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax}.Partners(ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ObjectCreationExpressionSyntax original, ObjectCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.NewKeyword,
    		    Modified = modified.NewKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ObjectCreationExpressionSyntax, ObjectCreationExpressionSyntax>.Partners(ObjectCreationExpressionSyntax original, ObjectCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class AnonymousObjectCreationExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax}.Partners(AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax}.Partners(AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(AnonymousObjectCreationExpressionSyntax original, AnonymousObjectCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax}.Partners(AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(AnonymousObjectCreationExpressionSyntax original, AnonymousObjectCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AnonymousObjectCreationExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax}.Partners(AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(AnonymousObjectCreationExpressionSyntax original, AnonymousObjectCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.NewKeyword,
    		    Modified = modified.NewKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, AnonymousObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax>.Partners(AnonymousObjectCreationExpressionSyntax original, AnonymousObjectCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ArrayCreationExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax}.Partners(ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax}.Partners(ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ArrayCreationExpressionSyntax original, ArrayCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax}.Partners(ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ArrayCreationExpressionSyntax original, ArrayCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ArrayCreationExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax}.Partners(ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ArrayCreationExpressionSyntax original, ArrayCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.NewKeyword,
    		    Modified = modified.NewKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ArrayCreationExpressionSyntax, ArrayCreationExpressionSyntax>.Partners(ArrayCreationExpressionSyntax original, ArrayCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ImplicitArrayCreationExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax}.Partners(ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax}.Partners(ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ImplicitArrayCreationExpressionSyntax original, ImplicitArrayCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax}.Partners(ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ImplicitArrayCreationExpressionSyntax original, ImplicitArrayCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ImplicitArrayCreationExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax}.Partners(ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ImplicitArrayCreationExpressionSyntax original, ImplicitArrayCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.NewKeyword,
    		    Modified = modified.NewKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBracketToken,
    		    Modified = modified.OpenBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBracketToken,
    		    Modified = modified.CloseBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ImplicitArrayCreationExpressionSyntax, ImplicitArrayCreationExpressionSyntax>.Partners(ImplicitArrayCreationExpressionSyntax original, ImplicitArrayCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class StackAllocArrayCreationExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax}.Partners(StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax}.Partners(StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(StackAllocArrayCreationExpressionSyntax original, StackAllocArrayCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax}.Partners(StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(StackAllocArrayCreationExpressionSyntax original, StackAllocArrayCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="StackAllocArrayCreationExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax}.Partners(StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(StackAllocArrayCreationExpressionSyntax original, StackAllocArrayCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.StackAllocKeyword,
    		    Modified = modified.StackAllocKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, StackAllocArrayCreationExpressionSyntax, StackAllocArrayCreationExpressionSyntax>.Partners(StackAllocArrayCreationExpressionSyntax original, StackAllocArrayCreationExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class OmittedArraySizeExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax}.Partners(OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax}.Partners(OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(OmittedArraySizeExpressionSyntax original, OmittedArraySizeExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax}.Partners(OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(OmittedArraySizeExpressionSyntax original, OmittedArraySizeExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="OmittedArraySizeExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax}.Partners(OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(OmittedArraySizeExpressionSyntax original, OmittedArraySizeExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OmittedArraySizeExpressionToken,
    		    Modified = modified.OmittedArraySizeExpressionToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, OmittedArraySizeExpressionSyntax, OmittedArraySizeExpressionSyntax>.Partners(OmittedArraySizeExpressionSyntax original, OmittedArraySizeExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class InterpolatedStringExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax}.Partners(InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax}.Partners(InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(InterpolatedStringExpressionSyntax original, InterpolatedStringExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax}.Partners(InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(InterpolatedStringExpressionSyntax original, InterpolatedStringExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="InterpolatedStringExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax}.Partners(InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(InterpolatedStringExpressionSyntax original, InterpolatedStringExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.StringStartToken,
    		    Modified = modified.StringStartToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.StringEndToken,
    		    Modified = modified.StringEndToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, InterpolatedStringExpressionSyntax, InterpolatedStringExpressionSyntax>.Partners(InterpolatedStringExpressionSyntax original, InterpolatedStringExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class IsPatternExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, IsPatternExpressionSyntax, IsPatternExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(IsPatternExpressionSyntax, IsPatternExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, IsPatternExpressionSyntax, IsPatternExpressionSyntax}.Partners(IsPatternExpressionSyntax, IsPatternExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(IsPatternExpressionSyntax, IsPatternExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, IsPatternExpressionSyntax, IsPatternExpressionSyntax}.Partners(IsPatternExpressionSyntax, IsPatternExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(IsPatternExpressionSyntax original, IsPatternExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(IsPatternExpressionSyntax, IsPatternExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, IsPatternExpressionSyntax, IsPatternExpressionSyntax}.Partners(IsPatternExpressionSyntax, IsPatternExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(IsPatternExpressionSyntax original, IsPatternExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="IsPatternExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, IsPatternExpressionSyntax, IsPatternExpressionSyntax}.Partners(IsPatternExpressionSyntax, IsPatternExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(IsPatternExpressionSyntax original, IsPatternExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.IsKeyword,
    		    Modified = modified.IsKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, IsPatternExpressionSyntax, IsPatternExpressionSyntax>.Partners(IsPatternExpressionSyntax original, IsPatternExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ThrowExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, ThrowExpressionSyntax, ThrowExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ThrowExpressionSyntax, ThrowExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ThrowExpressionSyntax, ThrowExpressionSyntax}.Partners(ThrowExpressionSyntax, ThrowExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ThrowExpressionSyntax, ThrowExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ThrowExpressionSyntax, ThrowExpressionSyntax}.Partners(ThrowExpressionSyntax, ThrowExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ThrowExpressionSyntax original, ThrowExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ThrowExpressionSyntax, ThrowExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ThrowExpressionSyntax, ThrowExpressionSyntax}.Partners(ThrowExpressionSyntax, ThrowExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ThrowExpressionSyntax original, ThrowExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ThrowExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ThrowExpressionSyntax, ThrowExpressionSyntax}.Partners(ThrowExpressionSyntax, ThrowExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ThrowExpressionSyntax original, ThrowExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ThrowKeyword,
    		    Modified = modified.ThrowKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ThrowExpressionSyntax, ThrowExpressionSyntax>.Partners(ThrowExpressionSyntax original, ThrowExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class PredefinedTypeServiceProvider : IPartnership<SyntaxNodeOrToken?, PredefinedTypeSyntax, PredefinedTypeSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(PredefinedTypeSyntax, PredefinedTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, PredefinedTypeSyntax, PredefinedTypeSyntax}.Partners(PredefinedTypeSyntax, PredefinedTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(PredefinedTypeSyntax, PredefinedTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, PredefinedTypeSyntax, PredefinedTypeSyntax}.Partners(PredefinedTypeSyntax, PredefinedTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(PredefinedTypeSyntax original, PredefinedTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(PredefinedTypeSyntax, PredefinedTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, PredefinedTypeSyntax, PredefinedTypeSyntax}.Partners(PredefinedTypeSyntax, PredefinedTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(PredefinedTypeSyntax original, PredefinedTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="PredefinedTypeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, PredefinedTypeSyntax, PredefinedTypeSyntax}.Partners(PredefinedTypeSyntax, PredefinedTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(PredefinedTypeSyntax original, PredefinedTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, PredefinedTypeSyntax, PredefinedTypeSyntax>.Partners(PredefinedTypeSyntax original, PredefinedTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class PointerTypeServiceProvider : IPartnership<SyntaxNodeOrToken?, PointerTypeSyntax, PointerTypeSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(PointerTypeSyntax, PointerTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, PointerTypeSyntax, PointerTypeSyntax}.Partners(PointerTypeSyntax, PointerTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(PointerTypeSyntax, PointerTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, PointerTypeSyntax, PointerTypeSyntax}.Partners(PointerTypeSyntax, PointerTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(PointerTypeSyntax original, PointerTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(PointerTypeSyntax, PointerTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, PointerTypeSyntax, PointerTypeSyntax}.Partners(PointerTypeSyntax, PointerTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(PointerTypeSyntax original, PointerTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="PointerTypeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, PointerTypeSyntax, PointerTypeSyntax}.Partners(PointerTypeSyntax, PointerTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(PointerTypeSyntax original, PointerTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.AsteriskToken,
    		    Modified = modified.AsteriskToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, PointerTypeSyntax, PointerTypeSyntax>.Partners(PointerTypeSyntax original, PointerTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class NullableTypeServiceProvider : IPartnership<SyntaxNodeOrToken?, NullableTypeSyntax, NullableTypeSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(NullableTypeSyntax, NullableTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, NullableTypeSyntax, NullableTypeSyntax}.Partners(NullableTypeSyntax, NullableTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(NullableTypeSyntax, NullableTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, NullableTypeSyntax, NullableTypeSyntax}.Partners(NullableTypeSyntax, NullableTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(NullableTypeSyntax original, NullableTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(NullableTypeSyntax, NullableTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, NullableTypeSyntax, NullableTypeSyntax}.Partners(NullableTypeSyntax, NullableTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(NullableTypeSyntax original, NullableTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="NullableTypeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, NullableTypeSyntax, NullableTypeSyntax}.Partners(NullableTypeSyntax, NullableTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(NullableTypeSyntax original, NullableTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.QuestionToken,
    		    Modified = modified.QuestionToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, NullableTypeSyntax, NullableTypeSyntax>.Partners(NullableTypeSyntax original, NullableTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class TupleTypeServiceProvider : IPartnership<SyntaxNodeOrToken?, TupleTypeSyntax, TupleTypeSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(TupleTypeSyntax, TupleTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, TupleTypeSyntax, TupleTypeSyntax}.Partners(TupleTypeSyntax, TupleTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(TupleTypeSyntax, TupleTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, TupleTypeSyntax, TupleTypeSyntax}.Partners(TupleTypeSyntax, TupleTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(TupleTypeSyntax original, TupleTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(TupleTypeSyntax, TupleTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, TupleTypeSyntax, TupleTypeSyntax}.Partners(TupleTypeSyntax, TupleTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(TupleTypeSyntax original, TupleTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TupleTypeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, TupleTypeSyntax, TupleTypeSyntax}.Partners(TupleTypeSyntax, TupleTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(TupleTypeSyntax original, TupleTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, TupleTypeSyntax, TupleTypeSyntax>.Partners(TupleTypeSyntax original, TupleTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class OmittedTypeArgumentServiceProvider : IPartnership<SyntaxNodeOrToken?, OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax}.Partners(OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax}.Partners(OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(OmittedTypeArgumentSyntax original, OmittedTypeArgumentSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax}.Partners(OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(OmittedTypeArgumentSyntax original, OmittedTypeArgumentSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="OmittedTypeArgumentSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax}.Partners(OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(OmittedTypeArgumentSyntax original, OmittedTypeArgumentSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OmittedTypeArgumentToken,
    		    Modified = modified.OmittedTypeArgumentToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, OmittedTypeArgumentSyntax, OmittedTypeArgumentSyntax>.Partners(OmittedTypeArgumentSyntax original, OmittedTypeArgumentSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class RefTypeServiceProvider : IPartnership<SyntaxNodeOrToken?, RefTypeSyntax, RefTypeSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(RefTypeSyntax, RefTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, RefTypeSyntax, RefTypeSyntax}.Partners(RefTypeSyntax, RefTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(RefTypeSyntax, RefTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, RefTypeSyntax, RefTypeSyntax}.Partners(RefTypeSyntax, RefTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(RefTypeSyntax original, RefTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(RefTypeSyntax, RefTypeSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, RefTypeSyntax, RefTypeSyntax}.Partners(RefTypeSyntax, RefTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(RefTypeSyntax original, RefTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="RefTypeSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, RefTypeSyntax, RefTypeSyntax}.Partners(RefTypeSyntax, RefTypeSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(RefTypeSyntax original, RefTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.RefKeyword,
    		    Modified = modified.RefKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ReadOnlyKeyword,
    		    Modified = modified.ReadOnlyKeyword
    		};
    		if(original.ReadOnlyKeyword != null && modified.ReadOnlyKeyword != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.ReadOnlyKeyword != null)
    			matchingSet.Originals.DisableMatching(original.ReadOnlyKeyword);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.ReadOnlyKeyword);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, RefTypeSyntax, RefTypeSyntax>.Partners(RefTypeSyntax original, RefTypeSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class QualifiedNameServiceProvider : IPartnership<SyntaxNodeOrToken?, QualifiedNameSyntax, QualifiedNameSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(QualifiedNameSyntax, QualifiedNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, QualifiedNameSyntax, QualifiedNameSyntax}.Partners(QualifiedNameSyntax, QualifiedNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(QualifiedNameSyntax, QualifiedNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, QualifiedNameSyntax, QualifiedNameSyntax}.Partners(QualifiedNameSyntax, QualifiedNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(QualifiedNameSyntax original, QualifiedNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(QualifiedNameSyntax, QualifiedNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, QualifiedNameSyntax, QualifiedNameSyntax}.Partners(QualifiedNameSyntax, QualifiedNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(QualifiedNameSyntax original, QualifiedNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="QualifiedNameSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, QualifiedNameSyntax, QualifiedNameSyntax}.Partners(QualifiedNameSyntax, QualifiedNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(QualifiedNameSyntax original, QualifiedNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.DotToken,
    		    Modified = modified.DotToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, QualifiedNameSyntax, QualifiedNameSyntax>.Partners(QualifiedNameSyntax original, QualifiedNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class AliasQualifiedNameServiceProvider : IPartnership<SyntaxNodeOrToken?, AliasQualifiedNameSyntax, AliasQualifiedNameSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(AliasQualifiedNameSyntax, AliasQualifiedNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, AliasQualifiedNameSyntax, AliasQualifiedNameSyntax}.Partners(AliasQualifiedNameSyntax, AliasQualifiedNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(AliasQualifiedNameSyntax, AliasQualifiedNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, AliasQualifiedNameSyntax, AliasQualifiedNameSyntax}.Partners(AliasQualifiedNameSyntax, AliasQualifiedNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(AliasQualifiedNameSyntax original, AliasQualifiedNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(AliasQualifiedNameSyntax, AliasQualifiedNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, AliasQualifiedNameSyntax, AliasQualifiedNameSyntax}.Partners(AliasQualifiedNameSyntax, AliasQualifiedNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(AliasQualifiedNameSyntax original, AliasQualifiedNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AliasQualifiedNameSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, AliasQualifiedNameSyntax, AliasQualifiedNameSyntax}.Partners(AliasQualifiedNameSyntax, AliasQualifiedNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(AliasQualifiedNameSyntax original, AliasQualifiedNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonColonToken,
    		    Modified = modified.ColonColonToken
    		};
    		if(original.ColonColonToken != null && modified.ColonColonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.ColonColonToken != null)
    			matchingSet.Originals.DisableMatching(original.ColonColonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.ColonColonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, AliasQualifiedNameSyntax, AliasQualifiedNameSyntax>.Partners(AliasQualifiedNameSyntax original, AliasQualifiedNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class IdentifierNameServiceProvider : IPartnership<SyntaxNodeOrToken?, IdentifierNameSyntax, IdentifierNameSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(IdentifierNameSyntax, IdentifierNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, IdentifierNameSyntax, IdentifierNameSyntax}.Partners(IdentifierNameSyntax, IdentifierNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(IdentifierNameSyntax, IdentifierNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, IdentifierNameSyntax, IdentifierNameSyntax}.Partners(IdentifierNameSyntax, IdentifierNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(IdentifierNameSyntax original, IdentifierNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(IdentifierNameSyntax, IdentifierNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, IdentifierNameSyntax, IdentifierNameSyntax}.Partners(IdentifierNameSyntax, IdentifierNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(IdentifierNameSyntax original, IdentifierNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="IdentifierNameSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, IdentifierNameSyntax, IdentifierNameSyntax}.Partners(IdentifierNameSyntax, IdentifierNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(IdentifierNameSyntax original, IdentifierNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, IdentifierNameSyntax, IdentifierNameSyntax>.Partners(IdentifierNameSyntax original, IdentifierNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class GenericNameServiceProvider : IPartnership<SyntaxNodeOrToken?, GenericNameSyntax, GenericNameSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(GenericNameSyntax, GenericNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, GenericNameSyntax, GenericNameSyntax}.Partners(GenericNameSyntax, GenericNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(GenericNameSyntax, GenericNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, GenericNameSyntax, GenericNameSyntax}.Partners(GenericNameSyntax, GenericNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(GenericNameSyntax original, GenericNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(GenericNameSyntax, GenericNameSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, GenericNameSyntax, GenericNameSyntax}.Partners(GenericNameSyntax, GenericNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(GenericNameSyntax original, GenericNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="GenericNameSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, GenericNameSyntax, GenericNameSyntax}.Partners(GenericNameSyntax, GenericNameSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(GenericNameSyntax original, GenericNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, GenericNameSyntax, GenericNameSyntax>.Partners(GenericNameSyntax original, GenericNameSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ThisExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, ThisExpressionSyntax, ThisExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ThisExpressionSyntax, ThisExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ThisExpressionSyntax, ThisExpressionSyntax}.Partners(ThisExpressionSyntax, ThisExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ThisExpressionSyntax, ThisExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ThisExpressionSyntax, ThisExpressionSyntax}.Partners(ThisExpressionSyntax, ThisExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ThisExpressionSyntax original, ThisExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ThisExpressionSyntax, ThisExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ThisExpressionSyntax, ThisExpressionSyntax}.Partners(ThisExpressionSyntax, ThisExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ThisExpressionSyntax original, ThisExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ThisExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ThisExpressionSyntax, ThisExpressionSyntax}.Partners(ThisExpressionSyntax, ThisExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ThisExpressionSyntax original, ThisExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Token,
    		    Modified = modified.Token
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ThisExpressionSyntax, ThisExpressionSyntax>.Partners(ThisExpressionSyntax original, ThisExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class BaseExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, BaseExpressionSyntax, BaseExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(BaseExpressionSyntax, BaseExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, BaseExpressionSyntax, BaseExpressionSyntax}.Partners(BaseExpressionSyntax, BaseExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(BaseExpressionSyntax, BaseExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, BaseExpressionSyntax, BaseExpressionSyntax}.Partners(BaseExpressionSyntax, BaseExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(BaseExpressionSyntax original, BaseExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(BaseExpressionSyntax, BaseExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, BaseExpressionSyntax, BaseExpressionSyntax}.Partners(BaseExpressionSyntax, BaseExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(BaseExpressionSyntax original, BaseExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BaseExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, BaseExpressionSyntax, BaseExpressionSyntax}.Partners(BaseExpressionSyntax, BaseExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(BaseExpressionSyntax original, BaseExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Token,
    		    Modified = modified.Token
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, BaseExpressionSyntax, BaseExpressionSyntax>.Partners(BaseExpressionSyntax original, BaseExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class AnonymousMethodExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax}.Partners(AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax}.Partners(AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(AnonymousMethodExpressionSyntax original, AnonymousMethodExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax}.Partners(AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(AnonymousMethodExpressionSyntax original, AnonymousMethodExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="AnonymousMethodExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax}.Partners(AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(AnonymousMethodExpressionSyntax original, AnonymousMethodExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.AsyncKeyword,
    		    Modified = modified.AsyncKeyword
    		};
    		if(original.AsyncKeyword != null && modified.AsyncKeyword != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.AsyncKeyword != null)
    			matchingSet.Originals.DisableMatching(original.AsyncKeyword);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.AsyncKeyword);
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.DelegateKeyword,
    		    Modified = modified.DelegateKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, AnonymousMethodExpressionSyntax, AnonymousMethodExpressionSyntax>.Partners(AnonymousMethodExpressionSyntax original, AnonymousMethodExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class SimpleLambdaExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax}.Partners(SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax}.Partners(SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(SimpleLambdaExpressionSyntax original, SimpleLambdaExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax}.Partners(SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(SimpleLambdaExpressionSyntax original, SimpleLambdaExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="SimpleLambdaExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax}.Partners(SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(SimpleLambdaExpressionSyntax original, SimpleLambdaExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.AsyncKeyword,
    		    Modified = modified.AsyncKeyword
    		};
    		if(original.AsyncKeyword != null && modified.AsyncKeyword != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.AsyncKeyword != null)
    			matchingSet.Originals.DisableMatching(original.AsyncKeyword);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.AsyncKeyword);
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ArrowToken,
    		    Modified = modified.ArrowToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, SimpleLambdaExpressionSyntax, SimpleLambdaExpressionSyntax>.Partners(SimpleLambdaExpressionSyntax original, SimpleLambdaExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ParenthesizedLambdaExpressionServiceProvider : IPartnership<SyntaxNodeOrToken?, ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax}.Partners(ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax}.Partners(ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ParenthesizedLambdaExpressionSyntax original, ParenthesizedLambdaExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax}.Partners(ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ParenthesizedLambdaExpressionSyntax original, ParenthesizedLambdaExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ParenthesizedLambdaExpressionSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax}.Partners(ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ParenthesizedLambdaExpressionSyntax original, ParenthesizedLambdaExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.AsyncKeyword,
    		    Modified = modified.AsyncKeyword
    		};
    		if(original.AsyncKeyword != null && modified.AsyncKeyword != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.AsyncKeyword != null)
    			matchingSet.Originals.DisableMatching(original.AsyncKeyword);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.AsyncKeyword);
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ArrowToken,
    		    Modified = modified.ArrowToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ParenthesizedLambdaExpressionSyntax, ParenthesizedLambdaExpressionSyntax>.Partners(ParenthesizedLambdaExpressionSyntax original, ParenthesizedLambdaExpressionSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ArgumentListServiceProvider : IPartnership<SyntaxNodeOrToken?, ArgumentListSyntax, ArgumentListSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ArgumentListSyntax, ArgumentListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ArgumentListSyntax, ArgumentListSyntax}.Partners(ArgumentListSyntax, ArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ArgumentListSyntax, ArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ArgumentListSyntax, ArgumentListSyntax}.Partners(ArgumentListSyntax, ArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ArgumentListSyntax original, ArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ArgumentListSyntax, ArgumentListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ArgumentListSyntax, ArgumentListSyntax}.Partners(ArgumentListSyntax, ArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ArgumentListSyntax original, ArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ArgumentListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ArgumentListSyntax, ArgumentListSyntax}.Partners(ArgumentListSyntax, ArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ArgumentListSyntax original, ArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ArgumentListSyntax, ArgumentListSyntax>.Partners(ArgumentListSyntax original, ArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class BracketedArgumentListServiceProvider : IPartnership<SyntaxNodeOrToken?, BracketedArgumentListSyntax, BracketedArgumentListSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(BracketedArgumentListSyntax, BracketedArgumentListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, BracketedArgumentListSyntax, BracketedArgumentListSyntax}.Partners(BracketedArgumentListSyntax, BracketedArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(BracketedArgumentListSyntax, BracketedArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, BracketedArgumentListSyntax, BracketedArgumentListSyntax}.Partners(BracketedArgumentListSyntax, BracketedArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(BracketedArgumentListSyntax original, BracketedArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(BracketedArgumentListSyntax, BracketedArgumentListSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, BracketedArgumentListSyntax, BracketedArgumentListSyntax}.Partners(BracketedArgumentListSyntax, BracketedArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(BracketedArgumentListSyntax original, BracketedArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BracketedArgumentListSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, BracketedArgumentListSyntax, BracketedArgumentListSyntax}.Partners(BracketedArgumentListSyntax, BracketedArgumentListSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(BracketedArgumentListSyntax original, BracketedArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBracketToken,
    		    Modified = modified.OpenBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBracketToken,
    		    Modified = modified.CloseBracketToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, BracketedArgumentListSyntax, BracketedArgumentListSyntax>.Partners(BracketedArgumentListSyntax original, BracketedArgumentListSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class FromClauseServiceProvider : IPartnership<SyntaxNodeOrToken?, FromClauseSyntax, FromClauseSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(FromClauseSyntax, FromClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, FromClauseSyntax, FromClauseSyntax}.Partners(FromClauseSyntax, FromClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(FromClauseSyntax, FromClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, FromClauseSyntax, FromClauseSyntax}.Partners(FromClauseSyntax, FromClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(FromClauseSyntax original, FromClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(FromClauseSyntax, FromClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, FromClauseSyntax, FromClauseSyntax}.Partners(FromClauseSyntax, FromClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(FromClauseSyntax original, FromClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="FromClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, FromClauseSyntax, FromClauseSyntax}.Partners(FromClauseSyntax, FromClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(FromClauseSyntax original, FromClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.FromKeyword,
    		    Modified = modified.FromKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.InKeyword,
    		    Modified = modified.InKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, FromClauseSyntax, FromClauseSyntax>.Partners(FromClauseSyntax original, FromClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class LetClauseServiceProvider : IPartnership<SyntaxNodeOrToken?, LetClauseSyntax, LetClauseSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(LetClauseSyntax, LetClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, LetClauseSyntax, LetClauseSyntax}.Partners(LetClauseSyntax, LetClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(LetClauseSyntax, LetClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, LetClauseSyntax, LetClauseSyntax}.Partners(LetClauseSyntax, LetClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(LetClauseSyntax original, LetClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(LetClauseSyntax, LetClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, LetClauseSyntax, LetClauseSyntax}.Partners(LetClauseSyntax, LetClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(LetClauseSyntax original, LetClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LetClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, LetClauseSyntax, LetClauseSyntax}.Partners(LetClauseSyntax, LetClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(LetClauseSyntax original, LetClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LetKeyword,
    		    Modified = modified.LetKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EqualsToken,
    		    Modified = modified.EqualsToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, LetClauseSyntax, LetClauseSyntax>.Partners(LetClauseSyntax original, LetClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class JoinClauseServiceProvider : IPartnership<SyntaxNodeOrToken?, JoinClauseSyntax, JoinClauseSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(JoinClauseSyntax, JoinClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, JoinClauseSyntax, JoinClauseSyntax}.Partners(JoinClauseSyntax, JoinClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(JoinClauseSyntax, JoinClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, JoinClauseSyntax, JoinClauseSyntax}.Partners(JoinClauseSyntax, JoinClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(JoinClauseSyntax original, JoinClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(JoinClauseSyntax, JoinClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, JoinClauseSyntax, JoinClauseSyntax}.Partners(JoinClauseSyntax, JoinClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(JoinClauseSyntax original, JoinClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="JoinClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, JoinClauseSyntax, JoinClauseSyntax}.Partners(JoinClauseSyntax, JoinClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(JoinClauseSyntax original, JoinClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.JoinKeyword,
    		    Modified = modified.JoinKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.InKeyword,
    		    Modified = modified.InKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OnKeyword,
    		    Modified = modified.OnKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.EqualsKeyword,
    		    Modified = modified.EqualsKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, JoinClauseSyntax, JoinClauseSyntax>.Partners(JoinClauseSyntax original, JoinClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class WhereClauseServiceProvider : IPartnership<SyntaxNodeOrToken?, WhereClauseSyntax, WhereClauseSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(WhereClauseSyntax, WhereClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, WhereClauseSyntax, WhereClauseSyntax}.Partners(WhereClauseSyntax, WhereClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(WhereClauseSyntax, WhereClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, WhereClauseSyntax, WhereClauseSyntax}.Partners(WhereClauseSyntax, WhereClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(WhereClauseSyntax original, WhereClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(WhereClauseSyntax, WhereClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, WhereClauseSyntax, WhereClauseSyntax}.Partners(WhereClauseSyntax, WhereClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(WhereClauseSyntax original, WhereClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="WhereClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, WhereClauseSyntax, WhereClauseSyntax}.Partners(WhereClauseSyntax, WhereClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(WhereClauseSyntax original, WhereClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.WhereKeyword,
    		    Modified = modified.WhereKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, WhereClauseSyntax, WhereClauseSyntax>.Partners(WhereClauseSyntax original, WhereClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class OrderByClauseServiceProvider : IPartnership<SyntaxNodeOrToken?, OrderByClauseSyntax, OrderByClauseSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(OrderByClauseSyntax, OrderByClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, OrderByClauseSyntax, OrderByClauseSyntax}.Partners(OrderByClauseSyntax, OrderByClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(OrderByClauseSyntax, OrderByClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, OrderByClauseSyntax, OrderByClauseSyntax}.Partners(OrderByClauseSyntax, OrderByClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(OrderByClauseSyntax original, OrderByClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(OrderByClauseSyntax, OrderByClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, OrderByClauseSyntax, OrderByClauseSyntax}.Partners(OrderByClauseSyntax, OrderByClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(OrderByClauseSyntax original, OrderByClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="OrderByClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, OrderByClauseSyntax, OrderByClauseSyntax}.Partners(OrderByClauseSyntax, OrderByClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(OrderByClauseSyntax original, OrderByClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OrderByKeyword,
    		    Modified = modified.OrderByKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, OrderByClauseSyntax, OrderByClauseSyntax>.Partners(OrderByClauseSyntax original, OrderByClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class SelectClauseServiceProvider : IPartnership<SyntaxNodeOrToken?, SelectClauseSyntax, SelectClauseSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(SelectClauseSyntax, SelectClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, SelectClauseSyntax, SelectClauseSyntax}.Partners(SelectClauseSyntax, SelectClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(SelectClauseSyntax, SelectClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, SelectClauseSyntax, SelectClauseSyntax}.Partners(SelectClauseSyntax, SelectClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(SelectClauseSyntax original, SelectClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(SelectClauseSyntax, SelectClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, SelectClauseSyntax, SelectClauseSyntax}.Partners(SelectClauseSyntax, SelectClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(SelectClauseSyntax original, SelectClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="SelectClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, SelectClauseSyntax, SelectClauseSyntax}.Partners(SelectClauseSyntax, SelectClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(SelectClauseSyntax original, SelectClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SelectKeyword,
    		    Modified = modified.SelectKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, SelectClauseSyntax, SelectClauseSyntax>.Partners(SelectClauseSyntax original, SelectClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class GroupClauseServiceProvider : IPartnership<SyntaxNodeOrToken?, GroupClauseSyntax, GroupClauseSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(GroupClauseSyntax, GroupClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, GroupClauseSyntax, GroupClauseSyntax}.Partners(GroupClauseSyntax, GroupClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(GroupClauseSyntax, GroupClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, GroupClauseSyntax, GroupClauseSyntax}.Partners(GroupClauseSyntax, GroupClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(GroupClauseSyntax original, GroupClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(GroupClauseSyntax, GroupClauseSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, GroupClauseSyntax, GroupClauseSyntax}.Partners(GroupClauseSyntax, GroupClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(GroupClauseSyntax original, GroupClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="GroupClauseSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, GroupClauseSyntax, GroupClauseSyntax}.Partners(GroupClauseSyntax, GroupClauseSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(GroupClauseSyntax original, GroupClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.GroupKeyword,
    		    Modified = modified.GroupKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ByKeyword,
    		    Modified = modified.ByKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, GroupClauseSyntax, GroupClauseSyntax>.Partners(GroupClauseSyntax original, GroupClauseSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class InterpolatedStringTextServiceProvider : IPartnership<SyntaxNodeOrToken?, InterpolatedStringTextSyntax, InterpolatedStringTextSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(InterpolatedStringTextSyntax, InterpolatedStringTextSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, InterpolatedStringTextSyntax, InterpolatedStringTextSyntax}.Partners(InterpolatedStringTextSyntax, InterpolatedStringTextSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(InterpolatedStringTextSyntax, InterpolatedStringTextSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, InterpolatedStringTextSyntax, InterpolatedStringTextSyntax}.Partners(InterpolatedStringTextSyntax, InterpolatedStringTextSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(InterpolatedStringTextSyntax original, InterpolatedStringTextSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(InterpolatedStringTextSyntax, InterpolatedStringTextSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, InterpolatedStringTextSyntax, InterpolatedStringTextSyntax}.Partners(InterpolatedStringTextSyntax, InterpolatedStringTextSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(InterpolatedStringTextSyntax original, InterpolatedStringTextSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="InterpolatedStringTextSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, InterpolatedStringTextSyntax, InterpolatedStringTextSyntax}.Partners(InterpolatedStringTextSyntax, InterpolatedStringTextSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(InterpolatedStringTextSyntax original, InterpolatedStringTextSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.TextToken,
    		    Modified = modified.TextToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, InterpolatedStringTextSyntax, InterpolatedStringTextSyntax>.Partners(InterpolatedStringTextSyntax original, InterpolatedStringTextSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class InterpolationServiceProvider : IPartnership<SyntaxNodeOrToken?, InterpolationSyntax, InterpolationSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(InterpolationSyntax, InterpolationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, InterpolationSyntax, InterpolationSyntax}.Partners(InterpolationSyntax, InterpolationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(InterpolationSyntax, InterpolationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, InterpolationSyntax, InterpolationSyntax}.Partners(InterpolationSyntax, InterpolationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(InterpolationSyntax original, InterpolationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(InterpolationSyntax, InterpolationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, InterpolationSyntax, InterpolationSyntax}.Partners(InterpolationSyntax, InterpolationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(InterpolationSyntax original, InterpolationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="InterpolationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, InterpolationSyntax, InterpolationSyntax}.Partners(InterpolationSyntax, InterpolationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(InterpolationSyntax original, InterpolationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, InterpolationSyntax, InterpolationSyntax>.Partners(InterpolationSyntax original, InterpolationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class BlockServiceProvider : IPartnership<SyntaxNodeOrToken?, BlockSyntax, BlockSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(BlockSyntax, BlockSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, BlockSyntax, BlockSyntax}.Partners(BlockSyntax, BlockSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(BlockSyntax, BlockSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, BlockSyntax, BlockSyntax}.Partners(BlockSyntax, BlockSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(BlockSyntax original, BlockSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(BlockSyntax, BlockSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, BlockSyntax, BlockSyntax}.Partners(BlockSyntax, BlockSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(BlockSyntax original, BlockSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BlockSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, BlockSyntax, BlockSyntax}.Partners(BlockSyntax, BlockSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(BlockSyntax original, BlockSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, BlockSyntax, BlockSyntax>.Partners(BlockSyntax original, BlockSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class LocalFunctionStatementServiceProvider : IPartnership<SyntaxNodeOrToken?, LocalFunctionStatementSyntax, LocalFunctionStatementSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(LocalFunctionStatementSyntax, LocalFunctionStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, LocalFunctionStatementSyntax, LocalFunctionStatementSyntax}.Partners(LocalFunctionStatementSyntax, LocalFunctionStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(LocalFunctionStatementSyntax, LocalFunctionStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, LocalFunctionStatementSyntax, LocalFunctionStatementSyntax}.Partners(LocalFunctionStatementSyntax, LocalFunctionStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(LocalFunctionStatementSyntax original, LocalFunctionStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(LocalFunctionStatementSyntax, LocalFunctionStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, LocalFunctionStatementSyntax, LocalFunctionStatementSyntax}.Partners(LocalFunctionStatementSyntax, LocalFunctionStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(LocalFunctionStatementSyntax original, LocalFunctionStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LocalFunctionStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, LocalFunctionStatementSyntax, LocalFunctionStatementSyntax}.Partners(LocalFunctionStatementSyntax, LocalFunctionStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(LocalFunctionStatementSyntax original, LocalFunctionStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
    		if(original.SemicolonToken != null && modified.SemicolonToken != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.SemicolonToken != null)
    			matchingSet.Originals.DisableMatching(original.SemicolonToken);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.SemicolonToken);
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, LocalFunctionStatementSyntax, LocalFunctionStatementSyntax>.Partners(LocalFunctionStatementSyntax original, LocalFunctionStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class LocalDeclarationStatementServiceProvider : IPartnership<SyntaxNodeOrToken?, LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax}.Partners(LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax}.Partners(LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(LocalDeclarationStatementSyntax original, LocalDeclarationStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax}.Partners(LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(LocalDeclarationStatementSyntax original, LocalDeclarationStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LocalDeclarationStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax}.Partners(LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(LocalDeclarationStatementSyntax original, LocalDeclarationStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, LocalDeclarationStatementSyntax, LocalDeclarationStatementSyntax>.Partners(LocalDeclarationStatementSyntax original, LocalDeclarationStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ExpressionStatementServiceProvider : IPartnership<SyntaxNodeOrToken?, ExpressionStatementSyntax, ExpressionStatementSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ExpressionStatementSyntax, ExpressionStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ExpressionStatementSyntax, ExpressionStatementSyntax}.Partners(ExpressionStatementSyntax, ExpressionStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ExpressionStatementSyntax, ExpressionStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ExpressionStatementSyntax, ExpressionStatementSyntax}.Partners(ExpressionStatementSyntax, ExpressionStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ExpressionStatementSyntax original, ExpressionStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ExpressionStatementSyntax, ExpressionStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ExpressionStatementSyntax, ExpressionStatementSyntax}.Partners(ExpressionStatementSyntax, ExpressionStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ExpressionStatementSyntax original, ExpressionStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ExpressionStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ExpressionStatementSyntax, ExpressionStatementSyntax}.Partners(ExpressionStatementSyntax, ExpressionStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ExpressionStatementSyntax original, ExpressionStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ExpressionStatementSyntax, ExpressionStatementSyntax>.Partners(ExpressionStatementSyntax original, ExpressionStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class EmptyStatementServiceProvider : IPartnership<SyntaxNodeOrToken?, EmptyStatementSyntax, EmptyStatementSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(EmptyStatementSyntax, EmptyStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, EmptyStatementSyntax, EmptyStatementSyntax}.Partners(EmptyStatementSyntax, EmptyStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(EmptyStatementSyntax, EmptyStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, EmptyStatementSyntax, EmptyStatementSyntax}.Partners(EmptyStatementSyntax, EmptyStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(EmptyStatementSyntax original, EmptyStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(EmptyStatementSyntax, EmptyStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, EmptyStatementSyntax, EmptyStatementSyntax}.Partners(EmptyStatementSyntax, EmptyStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(EmptyStatementSyntax original, EmptyStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="EmptyStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, EmptyStatementSyntax, EmptyStatementSyntax}.Partners(EmptyStatementSyntax, EmptyStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(EmptyStatementSyntax original, EmptyStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, EmptyStatementSyntax, EmptyStatementSyntax>.Partners(EmptyStatementSyntax original, EmptyStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class LabeledStatementServiceProvider : IPartnership<SyntaxNodeOrToken?, LabeledStatementSyntax, LabeledStatementSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(LabeledStatementSyntax, LabeledStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, LabeledStatementSyntax, LabeledStatementSyntax}.Partners(LabeledStatementSyntax, LabeledStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(LabeledStatementSyntax, LabeledStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, LabeledStatementSyntax, LabeledStatementSyntax}.Partners(LabeledStatementSyntax, LabeledStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(LabeledStatementSyntax original, LabeledStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(LabeledStatementSyntax, LabeledStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, LabeledStatementSyntax, LabeledStatementSyntax}.Partners(LabeledStatementSyntax, LabeledStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(LabeledStatementSyntax original, LabeledStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LabeledStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, LabeledStatementSyntax, LabeledStatementSyntax}.Partners(LabeledStatementSyntax, LabeledStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(LabeledStatementSyntax original, LabeledStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, LabeledStatementSyntax, LabeledStatementSyntax>.Partners(LabeledStatementSyntax original, LabeledStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class GotoStatementServiceProvider : IPartnership<SyntaxNodeOrToken?, GotoStatementSyntax, GotoStatementSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(GotoStatementSyntax, GotoStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, GotoStatementSyntax, GotoStatementSyntax}.Partners(GotoStatementSyntax, GotoStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(GotoStatementSyntax, GotoStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, GotoStatementSyntax, GotoStatementSyntax}.Partners(GotoStatementSyntax, GotoStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(GotoStatementSyntax original, GotoStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(GotoStatementSyntax, GotoStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, GotoStatementSyntax, GotoStatementSyntax}.Partners(GotoStatementSyntax, GotoStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(GotoStatementSyntax original, GotoStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="GotoStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, GotoStatementSyntax, GotoStatementSyntax}.Partners(GotoStatementSyntax, GotoStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(GotoStatementSyntax original, GotoStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.GotoKeyword,
    		    Modified = modified.GotoKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CaseOrDefaultKeyword,
    		    Modified = modified.CaseOrDefaultKeyword
    		};
    		if(original.CaseOrDefaultKeyword != null && modified.CaseOrDefaultKeyword != null)
    		{
        		if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    		}
    		else if(original.CaseOrDefaultKeyword != null)
    			matchingSet.Originals.DisableMatching(original.CaseOrDefaultKeyword);
    		else
    			matchingSet.Modifieds.DisableMatching(modified.CaseOrDefaultKeyword);
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, GotoStatementSyntax, GotoStatementSyntax>.Partners(GotoStatementSyntax original, GotoStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class BreakStatementServiceProvider : IPartnership<SyntaxNodeOrToken?, BreakStatementSyntax, BreakStatementSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(BreakStatementSyntax, BreakStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, BreakStatementSyntax, BreakStatementSyntax}.Partners(BreakStatementSyntax, BreakStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(BreakStatementSyntax, BreakStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, BreakStatementSyntax, BreakStatementSyntax}.Partners(BreakStatementSyntax, BreakStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(BreakStatementSyntax original, BreakStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(BreakStatementSyntax, BreakStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, BreakStatementSyntax, BreakStatementSyntax}.Partners(BreakStatementSyntax, BreakStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(BreakStatementSyntax original, BreakStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="BreakStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, BreakStatementSyntax, BreakStatementSyntax}.Partners(BreakStatementSyntax, BreakStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(BreakStatementSyntax original, BreakStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.BreakKeyword,
    		    Modified = modified.BreakKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, BreakStatementSyntax, BreakStatementSyntax>.Partners(BreakStatementSyntax original, BreakStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ContinueStatementServiceProvider : IPartnership<SyntaxNodeOrToken?, ContinueStatementSyntax, ContinueStatementSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ContinueStatementSyntax, ContinueStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ContinueStatementSyntax, ContinueStatementSyntax}.Partners(ContinueStatementSyntax, ContinueStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ContinueStatementSyntax, ContinueStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ContinueStatementSyntax, ContinueStatementSyntax}.Partners(ContinueStatementSyntax, ContinueStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ContinueStatementSyntax original, ContinueStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ContinueStatementSyntax, ContinueStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ContinueStatementSyntax, ContinueStatementSyntax}.Partners(ContinueStatementSyntax, ContinueStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ContinueStatementSyntax original, ContinueStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ContinueStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ContinueStatementSyntax, ContinueStatementSyntax}.Partners(ContinueStatementSyntax, ContinueStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ContinueStatementSyntax original, ContinueStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ContinueKeyword,
    		    Modified = modified.ContinueKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ContinueStatementSyntax, ContinueStatementSyntax>.Partners(ContinueStatementSyntax original, ContinueStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ReturnStatementServiceProvider : IPartnership<SyntaxNodeOrToken?, ReturnStatementSyntax, ReturnStatementSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ReturnStatementSyntax, ReturnStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ReturnStatementSyntax, ReturnStatementSyntax}.Partners(ReturnStatementSyntax, ReturnStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ReturnStatementSyntax, ReturnStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ReturnStatementSyntax, ReturnStatementSyntax}.Partners(ReturnStatementSyntax, ReturnStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ReturnStatementSyntax original, ReturnStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ReturnStatementSyntax, ReturnStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ReturnStatementSyntax, ReturnStatementSyntax}.Partners(ReturnStatementSyntax, ReturnStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ReturnStatementSyntax original, ReturnStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ReturnStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ReturnStatementSyntax, ReturnStatementSyntax}.Partners(ReturnStatementSyntax, ReturnStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ReturnStatementSyntax original, ReturnStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ReturnKeyword,
    		    Modified = modified.ReturnKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ReturnStatementSyntax, ReturnStatementSyntax>.Partners(ReturnStatementSyntax original, ReturnStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ThrowStatementServiceProvider : IPartnership<SyntaxNodeOrToken?, ThrowStatementSyntax, ThrowStatementSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ThrowStatementSyntax, ThrowStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ThrowStatementSyntax, ThrowStatementSyntax}.Partners(ThrowStatementSyntax, ThrowStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ThrowStatementSyntax, ThrowStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ThrowStatementSyntax, ThrowStatementSyntax}.Partners(ThrowStatementSyntax, ThrowStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ThrowStatementSyntax original, ThrowStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ThrowStatementSyntax, ThrowStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ThrowStatementSyntax, ThrowStatementSyntax}.Partners(ThrowStatementSyntax, ThrowStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ThrowStatementSyntax original, ThrowStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ThrowStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ThrowStatementSyntax, ThrowStatementSyntax}.Partners(ThrowStatementSyntax, ThrowStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ThrowStatementSyntax original, ThrowStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ThrowKeyword,
    		    Modified = modified.ThrowKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ThrowStatementSyntax, ThrowStatementSyntax>.Partners(ThrowStatementSyntax original, ThrowStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class YieldStatementServiceProvider : IPartnership<SyntaxNodeOrToken?, YieldStatementSyntax, YieldStatementSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(YieldStatementSyntax, YieldStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, YieldStatementSyntax, YieldStatementSyntax}.Partners(YieldStatementSyntax, YieldStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(YieldStatementSyntax, YieldStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, YieldStatementSyntax, YieldStatementSyntax}.Partners(YieldStatementSyntax, YieldStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(YieldStatementSyntax original, YieldStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(YieldStatementSyntax, YieldStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, YieldStatementSyntax, YieldStatementSyntax}.Partners(YieldStatementSyntax, YieldStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(YieldStatementSyntax original, YieldStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="YieldStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, YieldStatementSyntax, YieldStatementSyntax}.Partners(YieldStatementSyntax, YieldStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(YieldStatementSyntax original, YieldStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.YieldKeyword,
    		    Modified = modified.YieldKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ReturnOrBreakKeyword,
    		    Modified = modified.ReturnOrBreakKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, YieldStatementSyntax, YieldStatementSyntax>.Partners(YieldStatementSyntax original, YieldStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class WhileStatementServiceProvider : IPartnership<SyntaxNodeOrToken?, WhileStatementSyntax, WhileStatementSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(WhileStatementSyntax, WhileStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, WhileStatementSyntax, WhileStatementSyntax}.Partners(WhileStatementSyntax, WhileStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(WhileStatementSyntax, WhileStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, WhileStatementSyntax, WhileStatementSyntax}.Partners(WhileStatementSyntax, WhileStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(WhileStatementSyntax original, WhileStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(WhileStatementSyntax, WhileStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, WhileStatementSyntax, WhileStatementSyntax}.Partners(WhileStatementSyntax, WhileStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(WhileStatementSyntax original, WhileStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="WhileStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, WhileStatementSyntax, WhileStatementSyntax}.Partners(WhileStatementSyntax, WhileStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(WhileStatementSyntax original, WhileStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.WhileKeyword,
    		    Modified = modified.WhileKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, WhileStatementSyntax, WhileStatementSyntax>.Partners(WhileStatementSyntax original, WhileStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class DoStatementServiceProvider : IPartnership<SyntaxNodeOrToken?, DoStatementSyntax, DoStatementSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(DoStatementSyntax, DoStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, DoStatementSyntax, DoStatementSyntax}.Partners(DoStatementSyntax, DoStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(DoStatementSyntax, DoStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, DoStatementSyntax, DoStatementSyntax}.Partners(DoStatementSyntax, DoStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(DoStatementSyntax original, DoStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(DoStatementSyntax, DoStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, DoStatementSyntax, DoStatementSyntax}.Partners(DoStatementSyntax, DoStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(DoStatementSyntax original, DoStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DoStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, DoStatementSyntax, DoStatementSyntax}.Partners(DoStatementSyntax, DoStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(DoStatementSyntax original, DoStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.DoKeyword,
    		    Modified = modified.DoKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.WhileKeyword,
    		    Modified = modified.WhileKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SemicolonToken,
    		    Modified = modified.SemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, DoStatementSyntax, DoStatementSyntax>.Partners(DoStatementSyntax original, DoStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ForStatementServiceProvider : IPartnership<SyntaxNodeOrToken?, ForStatementSyntax, ForStatementSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ForStatementSyntax, ForStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ForStatementSyntax, ForStatementSyntax}.Partners(ForStatementSyntax, ForStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ForStatementSyntax, ForStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ForStatementSyntax, ForStatementSyntax}.Partners(ForStatementSyntax, ForStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ForStatementSyntax original, ForStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ForStatementSyntax, ForStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ForStatementSyntax, ForStatementSyntax}.Partners(ForStatementSyntax, ForStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ForStatementSyntax original, ForStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ForStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ForStatementSyntax, ForStatementSyntax}.Partners(ForStatementSyntax, ForStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ForStatementSyntax original, ForStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ForKeyword,
    		    Modified = modified.ForKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.FirstSemicolonToken,
    		    Modified = modified.FirstSemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SecondSemicolonToken,
    		    Modified = modified.SecondSemicolonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ForStatementSyntax, ForStatementSyntax>.Partners(ForStatementSyntax original, ForStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class UsingStatementServiceProvider : IPartnership<SyntaxNodeOrToken?, UsingStatementSyntax, UsingStatementSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(UsingStatementSyntax, UsingStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, UsingStatementSyntax, UsingStatementSyntax}.Partners(UsingStatementSyntax, UsingStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(UsingStatementSyntax, UsingStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, UsingStatementSyntax, UsingStatementSyntax}.Partners(UsingStatementSyntax, UsingStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(UsingStatementSyntax original, UsingStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(UsingStatementSyntax, UsingStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, UsingStatementSyntax, UsingStatementSyntax}.Partners(UsingStatementSyntax, UsingStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(UsingStatementSyntax original, UsingStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="UsingStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, UsingStatementSyntax, UsingStatementSyntax}.Partners(UsingStatementSyntax, UsingStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(UsingStatementSyntax original, UsingStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.UsingKeyword,
    		    Modified = modified.UsingKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, UsingStatementSyntax, UsingStatementSyntax>.Partners(UsingStatementSyntax original, UsingStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class FixedStatementServiceProvider : IPartnership<SyntaxNodeOrToken?, FixedStatementSyntax, FixedStatementSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(FixedStatementSyntax, FixedStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, FixedStatementSyntax, FixedStatementSyntax}.Partners(FixedStatementSyntax, FixedStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(FixedStatementSyntax, FixedStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, FixedStatementSyntax, FixedStatementSyntax}.Partners(FixedStatementSyntax, FixedStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(FixedStatementSyntax original, FixedStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(FixedStatementSyntax, FixedStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, FixedStatementSyntax, FixedStatementSyntax}.Partners(FixedStatementSyntax, FixedStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(FixedStatementSyntax original, FixedStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="FixedStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, FixedStatementSyntax, FixedStatementSyntax}.Partners(FixedStatementSyntax, FixedStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(FixedStatementSyntax original, FixedStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.FixedKeyword,
    		    Modified = modified.FixedKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, FixedStatementSyntax, FixedStatementSyntax>.Partners(FixedStatementSyntax original, FixedStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class CheckedStatementServiceProvider : IPartnership<SyntaxNodeOrToken?, CheckedStatementSyntax, CheckedStatementSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(CheckedStatementSyntax, CheckedStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, CheckedStatementSyntax, CheckedStatementSyntax}.Partners(CheckedStatementSyntax, CheckedStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(CheckedStatementSyntax, CheckedStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, CheckedStatementSyntax, CheckedStatementSyntax}.Partners(CheckedStatementSyntax, CheckedStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(CheckedStatementSyntax original, CheckedStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(CheckedStatementSyntax, CheckedStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, CheckedStatementSyntax, CheckedStatementSyntax}.Partners(CheckedStatementSyntax, CheckedStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(CheckedStatementSyntax original, CheckedStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CheckedStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, CheckedStatementSyntax, CheckedStatementSyntax}.Partners(CheckedStatementSyntax, CheckedStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(CheckedStatementSyntax original, CheckedStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, CheckedStatementSyntax, CheckedStatementSyntax>.Partners(CheckedStatementSyntax original, CheckedStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class UnsafeStatementServiceProvider : IPartnership<SyntaxNodeOrToken?, UnsafeStatementSyntax, UnsafeStatementSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(UnsafeStatementSyntax, UnsafeStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, UnsafeStatementSyntax, UnsafeStatementSyntax}.Partners(UnsafeStatementSyntax, UnsafeStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(UnsafeStatementSyntax, UnsafeStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, UnsafeStatementSyntax, UnsafeStatementSyntax}.Partners(UnsafeStatementSyntax, UnsafeStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(UnsafeStatementSyntax original, UnsafeStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(UnsafeStatementSyntax, UnsafeStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, UnsafeStatementSyntax, UnsafeStatementSyntax}.Partners(UnsafeStatementSyntax, UnsafeStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(UnsafeStatementSyntax original, UnsafeStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="UnsafeStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, UnsafeStatementSyntax, UnsafeStatementSyntax}.Partners(UnsafeStatementSyntax, UnsafeStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(UnsafeStatementSyntax original, UnsafeStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.UnsafeKeyword,
    		    Modified = modified.UnsafeKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, UnsafeStatementSyntax, UnsafeStatementSyntax>.Partners(UnsafeStatementSyntax original, UnsafeStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class LockStatementServiceProvider : IPartnership<SyntaxNodeOrToken?, LockStatementSyntax, LockStatementSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(LockStatementSyntax, LockStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, LockStatementSyntax, LockStatementSyntax}.Partners(LockStatementSyntax, LockStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(LockStatementSyntax, LockStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, LockStatementSyntax, LockStatementSyntax}.Partners(LockStatementSyntax, LockStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(LockStatementSyntax original, LockStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(LockStatementSyntax, LockStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, LockStatementSyntax, LockStatementSyntax}.Partners(LockStatementSyntax, LockStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(LockStatementSyntax original, LockStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="LockStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, LockStatementSyntax, LockStatementSyntax}.Partners(LockStatementSyntax, LockStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(LockStatementSyntax original, LockStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.LockKeyword,
    		    Modified = modified.LockKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, LockStatementSyntax, LockStatementSyntax>.Partners(LockStatementSyntax original, LockStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class IfStatementServiceProvider : IPartnership<SyntaxNodeOrToken?, IfStatementSyntax, IfStatementSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(IfStatementSyntax, IfStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, IfStatementSyntax, IfStatementSyntax}.Partners(IfStatementSyntax, IfStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(IfStatementSyntax, IfStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, IfStatementSyntax, IfStatementSyntax}.Partners(IfStatementSyntax, IfStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(IfStatementSyntax original, IfStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(IfStatementSyntax, IfStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, IfStatementSyntax, IfStatementSyntax}.Partners(IfStatementSyntax, IfStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(IfStatementSyntax original, IfStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="IfStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, IfStatementSyntax, IfStatementSyntax}.Partners(IfStatementSyntax, IfStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(IfStatementSyntax original, IfStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.IfKeyword,
    		    Modified = modified.IfKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, IfStatementSyntax, IfStatementSyntax>.Partners(IfStatementSyntax original, IfStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class SwitchStatementServiceProvider : IPartnership<SyntaxNodeOrToken?, SwitchStatementSyntax, SwitchStatementSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(SwitchStatementSyntax, SwitchStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, SwitchStatementSyntax, SwitchStatementSyntax}.Partners(SwitchStatementSyntax, SwitchStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(SwitchStatementSyntax, SwitchStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, SwitchStatementSyntax, SwitchStatementSyntax}.Partners(SwitchStatementSyntax, SwitchStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(SwitchStatementSyntax original, SwitchStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(SwitchStatementSyntax, SwitchStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, SwitchStatementSyntax, SwitchStatementSyntax}.Partners(SwitchStatementSyntax, SwitchStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(SwitchStatementSyntax original, SwitchStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="SwitchStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, SwitchStatementSyntax, SwitchStatementSyntax}.Partners(SwitchStatementSyntax, SwitchStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(SwitchStatementSyntax original, SwitchStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.SwitchKeyword,
    		    Modified = modified.SwitchKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenBraceToken,
    		    Modified = modified.OpenBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseBraceToken,
    		    Modified = modified.CloseBraceToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, SwitchStatementSyntax, SwitchStatementSyntax>.Partners(SwitchStatementSyntax original, SwitchStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class TryStatementServiceProvider : IPartnership<SyntaxNodeOrToken?, TryStatementSyntax, TryStatementSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(TryStatementSyntax, TryStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, TryStatementSyntax, TryStatementSyntax}.Partners(TryStatementSyntax, TryStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(TryStatementSyntax, TryStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, TryStatementSyntax, TryStatementSyntax}.Partners(TryStatementSyntax, TryStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(TryStatementSyntax original, TryStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(TryStatementSyntax, TryStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, TryStatementSyntax, TryStatementSyntax}.Partners(TryStatementSyntax, TryStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(TryStatementSyntax original, TryStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="TryStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, TryStatementSyntax, TryStatementSyntax}.Partners(TryStatementSyntax, TryStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(TryStatementSyntax original, TryStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.TryKeyword,
    		    Modified = modified.TryKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, TryStatementSyntax, TryStatementSyntax>.Partners(TryStatementSyntax original, TryStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ForEachStatementServiceProvider : IPartnership<SyntaxNodeOrToken?, ForEachStatementSyntax, ForEachStatementSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ForEachStatementSyntax, ForEachStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ForEachStatementSyntax, ForEachStatementSyntax}.Partners(ForEachStatementSyntax, ForEachStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ForEachStatementSyntax, ForEachStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ForEachStatementSyntax, ForEachStatementSyntax}.Partners(ForEachStatementSyntax, ForEachStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ForEachStatementSyntax original, ForEachStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ForEachStatementSyntax, ForEachStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ForEachStatementSyntax, ForEachStatementSyntax}.Partners(ForEachStatementSyntax, ForEachStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ForEachStatementSyntax original, ForEachStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ForEachStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ForEachStatementSyntax, ForEachStatementSyntax}.Partners(ForEachStatementSyntax, ForEachStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ForEachStatementSyntax original, ForEachStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ForEachKeyword,
    		    Modified = modified.ForEachKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.InKeyword,
    		    Modified = modified.InKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ForEachStatementSyntax, ForEachStatementSyntax>.Partners(ForEachStatementSyntax original, ForEachStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ForEachVariableStatementServiceProvider : IPartnership<SyntaxNodeOrToken?, ForEachVariableStatementSyntax, ForEachVariableStatementSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ForEachVariableStatementSyntax, ForEachVariableStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ForEachVariableStatementSyntax, ForEachVariableStatementSyntax}.Partners(ForEachVariableStatementSyntax, ForEachVariableStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ForEachVariableStatementSyntax, ForEachVariableStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ForEachVariableStatementSyntax, ForEachVariableStatementSyntax}.Partners(ForEachVariableStatementSyntax, ForEachVariableStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ForEachVariableStatementSyntax original, ForEachVariableStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ForEachVariableStatementSyntax, ForEachVariableStatementSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ForEachVariableStatementSyntax, ForEachVariableStatementSyntax}.Partners(ForEachVariableStatementSyntax, ForEachVariableStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ForEachVariableStatementSyntax original, ForEachVariableStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ForEachVariableStatementSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ForEachVariableStatementSyntax, ForEachVariableStatementSyntax}.Partners(ForEachVariableStatementSyntax, ForEachVariableStatementSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ForEachVariableStatementSyntax original, ForEachVariableStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ForEachKeyword,
    		    Modified = modified.ForEachKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.InKeyword,
    		    Modified = modified.InKeyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ForEachVariableStatementSyntax, ForEachVariableStatementSyntax>.Partners(ForEachVariableStatementSyntax original, ForEachVariableStatementSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class SingleVariableDesignationServiceProvider : IPartnership<SyntaxNodeOrToken?, SingleVariableDesignationSyntax, SingleVariableDesignationSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(SingleVariableDesignationSyntax, SingleVariableDesignationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, SingleVariableDesignationSyntax, SingleVariableDesignationSyntax}.Partners(SingleVariableDesignationSyntax, SingleVariableDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(SingleVariableDesignationSyntax, SingleVariableDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, SingleVariableDesignationSyntax, SingleVariableDesignationSyntax}.Partners(SingleVariableDesignationSyntax, SingleVariableDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(SingleVariableDesignationSyntax original, SingleVariableDesignationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(SingleVariableDesignationSyntax, SingleVariableDesignationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, SingleVariableDesignationSyntax, SingleVariableDesignationSyntax}.Partners(SingleVariableDesignationSyntax, SingleVariableDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(SingleVariableDesignationSyntax original, SingleVariableDesignationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="SingleVariableDesignationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, SingleVariableDesignationSyntax, SingleVariableDesignationSyntax}.Partners(SingleVariableDesignationSyntax, SingleVariableDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(SingleVariableDesignationSyntax original, SingleVariableDesignationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Identifier,
    		    Modified = modified.Identifier
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, SingleVariableDesignationSyntax, SingleVariableDesignationSyntax>.Partners(SingleVariableDesignationSyntax original, SingleVariableDesignationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class DiscardDesignationServiceProvider : IPartnership<SyntaxNodeOrToken?, DiscardDesignationSyntax, DiscardDesignationSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(DiscardDesignationSyntax, DiscardDesignationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, DiscardDesignationSyntax, DiscardDesignationSyntax}.Partners(DiscardDesignationSyntax, DiscardDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(DiscardDesignationSyntax, DiscardDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, DiscardDesignationSyntax, DiscardDesignationSyntax}.Partners(DiscardDesignationSyntax, DiscardDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(DiscardDesignationSyntax original, DiscardDesignationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(DiscardDesignationSyntax, DiscardDesignationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, DiscardDesignationSyntax, DiscardDesignationSyntax}.Partners(DiscardDesignationSyntax, DiscardDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(DiscardDesignationSyntax original, DiscardDesignationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DiscardDesignationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, DiscardDesignationSyntax, DiscardDesignationSyntax}.Partners(DiscardDesignationSyntax, DiscardDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(DiscardDesignationSyntax original, DiscardDesignationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.UnderscoreToken,
    		    Modified = modified.UnderscoreToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, DiscardDesignationSyntax, DiscardDesignationSyntax>.Partners(DiscardDesignationSyntax original, DiscardDesignationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class ParenthesizedVariableDesignationServiceProvider : IPartnership<SyntaxNodeOrToken?, ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax}.Partners(ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax}.Partners(ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(ParenthesizedVariableDesignationSyntax original, ParenthesizedVariableDesignationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax}.Partners(ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(ParenthesizedVariableDesignationSyntax original, ParenthesizedVariableDesignationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="ParenthesizedVariableDesignationSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax}.Partners(ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(ParenthesizedVariableDesignationSyntax original, ParenthesizedVariableDesignationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.OpenParenToken,
    		    Modified = modified.OpenParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.CloseParenToken,
    		    Modified = modified.CloseParenToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, ParenthesizedVariableDesignationSyntax, ParenthesizedVariableDesignationSyntax>.Partners(ParenthesizedVariableDesignationSyntax original, ParenthesizedVariableDesignationSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class CasePatternSwitchLabelServiceProvider : IPartnership<SyntaxNodeOrToken?, CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax}.Partners(CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax}.Partners(CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(CasePatternSwitchLabelSyntax original, CasePatternSwitchLabelSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax}.Partners(CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(CasePatternSwitchLabelSyntax original, CasePatternSwitchLabelSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CasePatternSwitchLabelSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax}.Partners(CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(CasePatternSwitchLabelSyntax original, CasePatternSwitchLabelSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, CasePatternSwitchLabelSyntax, CasePatternSwitchLabelSyntax>.Partners(CasePatternSwitchLabelSyntax original, CasePatternSwitchLabelSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class CaseSwitchLabelServiceProvider : IPartnership<SyntaxNodeOrToken?, CaseSwitchLabelSyntax, CaseSwitchLabelSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(CaseSwitchLabelSyntax, CaseSwitchLabelSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, CaseSwitchLabelSyntax, CaseSwitchLabelSyntax}.Partners(CaseSwitchLabelSyntax, CaseSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(CaseSwitchLabelSyntax, CaseSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, CaseSwitchLabelSyntax, CaseSwitchLabelSyntax}.Partners(CaseSwitchLabelSyntax, CaseSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(CaseSwitchLabelSyntax original, CaseSwitchLabelSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(CaseSwitchLabelSyntax, CaseSwitchLabelSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, CaseSwitchLabelSyntax, CaseSwitchLabelSyntax}.Partners(CaseSwitchLabelSyntax, CaseSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(CaseSwitchLabelSyntax original, CaseSwitchLabelSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="CaseSwitchLabelSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, CaseSwitchLabelSyntax, CaseSwitchLabelSyntax}.Partners(CaseSwitchLabelSyntax, CaseSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(CaseSwitchLabelSyntax original, CaseSwitchLabelSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, CaseSwitchLabelSyntax, CaseSwitchLabelSyntax>.Partners(CaseSwitchLabelSyntax original, CaseSwitchLabelSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
    partial class DefaultSwitchLabelServiceProvider : IPartnership<SyntaxNodeOrToken?, DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax>
    {
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="NameExactlyEqualCore(DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax}.Partners(DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="PartnersCore(DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/> is not executed and <see cref="IPartnership{SyntaxNodeOrToken?, DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax}.Partners(DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/> returns the current value of <paramref name="result"/>.</param>
        partial void PartnersBefore(DefaultSwitchLabelSyntax original, DefaultSwitchLabelSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="NameExactlyEqualCore(DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax)"/>.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <param name="result">Mechanism to modify the result of <see cref="IPartnership{SyntaxNodeOrToken?, DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax}.Partners(DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</param>
        partial void PartnersAfter(DefaultSwitchLabelSyntax original, DefaultSwitchLabelSyntax modified, MatchingContext<SyntaxNodeOrToken?> context, ref IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result);
    
        /// <summary>
        /// Determines if two <see cref="DefaultSwitchLabelSyntax"/> elements are name-based exactly equal.
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        /// <returns>true if they are exactly equal, otherwise returns false.</returns>
        /// <remarks>This is the default implementation for <see cref="IPartnership{SyntaxNodeOrToken?, DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax}.Partners(DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax, MatchingContext{SyntaxNodeOrToken?})"/>.</remarks>
        protected virtual IEnumerable<MatchInfo<SyntaxNodeOrToken?>> PartnersCore(DefaultSwitchLabelSyntax original, DefaultSwitchLabelSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		if(original == null) 
    			throw new ArgumentNullException(nameof(original));
    
    		if(modified == null) 
    			throw new ArgumentNullException(nameof(modified));
    
    		var matchingSet = context.Approach.MatchingSet();
    		MatchInfo<SyntaxNodeOrToken?> matchInfo = null;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.Keyword,
    		    Modified = modified.Keyword
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    
    		matchInfo = new PairwiseMatchInfo<SyntaxNodeOrToken?>.Tunneling
    		{
    		    On = new RevisionPair<SyntaxNodeOrToken?> { Original = original, Modified = modified },
    		    Original = original.ColonToken,
    		    Modified = modified.ColonToken
    		};
        	if(matchingSet.PartnersIfAvailable(matchInfo))
    				yield return matchInfo;
    	}    
    
    	/// <summary>
        /// Notifies that two comparing versions have been finally identified as a match (i.e., they are matching partners).
        /// </summary>
        /// <param name="original">the original version.</param>
        /// <param name="modified">the modified version.</param>
        /// <param name="context">the context wherein certain matching criterion is currently running.</param>
        /// <returns>Matches inferable after taking for granted the match among the given versions.</returns>
        IEnumerable<MatchInfo<SyntaxNodeOrToken?>> IPartnership<SyntaxNodeOrToken?, DefaultSwitchLabelSyntax, DefaultSwitchLabelSyntax>.Partners(DefaultSwitchLabelSyntax original, DefaultSwitchLabelSyntax modified, MatchingContext<SyntaxNodeOrToken?> context)
    	{
    		IEnumerable<MatchInfo<SyntaxNodeOrToken?>> result = null;
    		var ignoreCore = false;
    		PartnersBefore(original, modified, context, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.PartnersCore(original, modified, context);
    		PartnersAfter(original, modified, context, ref result);
    		return result;
    	}
    }
    
}
// Generated helper templates
// Generated items
